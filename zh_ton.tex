\documentclass[12pt,oneside]{article}
\usepackage{xeCJK}
\setCJKmainfont{SimSun}

\usepackage[T1]{fontenc}
%\usepackage{euler}
\usepackage{amssymb, amsmath, amsfonts, stmaryrd}
\usepackage[mathscr]{euscript}
\usepackage{mathrsfs}
\usepackage{theorem}
\usepackage[english]{babel}
\usepackage{bm}
\usepackage[all]{xy}
%\usepackage{chngcntr}
%\CompileMatrices
\usepackage[bookmarks=false,pdfauthor={Nikolai Durov},pdftitle={Telegram Open Network}]{hyperref}
\usepackage{fancyhdr}
\usepackage{caption}
%
\setlength{\headheight}{15.2pt}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.5pt}
%
\def\makepoint#1{\medbreak\noindent{\bf #1.\ }}
\def\zeropoint{\setcounter{subsection}{-1}}
\def\zerosubpoint{\setcounter{subsubsection}{-1}}
\def\nxpoint{\refstepcounter{subsection}%
  \smallbreak\makepoint{\thesubsection}}
\def\nxsubpoint{\refstepcounter{subsubsection}%
  \smallbreak\makepoint{\thesubsubsection}}
\def\nxsubsubpoint{\refstepcounter{paragraph}%
  \makepoint{\paragraph}}
%\setcounter{secnumdepth}{4}
%\counterwithin{paragraph}{subsubsection}
\def\refpoint#1{{\rm\textbf{\ref{#1}}}}
\let\ptref=\refpoint
\def\embt(#1.){\textbf{#1.}}
\def\embtx(#1){\textbf{#1}}
\long\def\nodo#1{}
%
%\def\markbothsame#1{\markboth{#1}{#1}}
\fancyhf{}
\fancyfoot[C]{\thepage}
\def\markbothsame#1{\fancyhead[C]{#1}}
\def\mysection#1{\section{#1}\fancyhead[C]{\textsc{Chapter \textbf{\thesection.} #1}}}
\def\mysubsection#1{\subsection{#1}\fancyhead[C]{\small{\textsc{\textrm{\thesubsection.} #1}}}}
\def\myappendix#1{\section{#1}\fancyhead[C]{\textsc{Appendix \textbf{\thesection.} #1}}}
%
\let\tp=\textit
\let\vr=\textit
\def\workchainid{\vr{workchain\_id\/}}
\def\shardpfx{\vr{shard\_prefix}}
\def\accountid{\vr{account\_id\/}}
\def\currencyid{\vr{currency\_id\/}}
\def\uint{\tp{uint}}
\def\opsc#1{\operatorname{\textsc{#1}}}
\def\blkseqno{\opsc{blk-seqno}}
\def\blkprev{\opsc{blk-prev}}
\def\blkhash{\opsc{blk-hash}}
\def\Hash{\opsc{Hash}}
\def\Sha{\opsc{sha256}}
\def\height{\opsc{height}}
\def\len{\opsc{len}}
\def\leaf{\opsc{Leaf}}
\def\node{\opsc{Node}}
\def\root{\opsc{Root}}
\def\emptyroot{\opsc{EmptyRoot}}
\def\code{\opsc{code}}
\def\Ping{\opsc{Ping}}
\def\Store{\opsc{Store}}
\def\FindNode{\opsc{Find\_Node}}
\def\FindValue{\opsc{Find\_Value}}
\def\Bytes{\tp{Bytes}}
\def\Transaction{\tp{Transaction}}
\def\Account{\tp{Account}}
\def\State{\tp{State}}
\def\Maybe{\opsc{Maybe}}
\def\List{\opsc{List}}
\def\Block{\tp{Block}}
\def\Blockchain{\tp{Blockchain}}
\def\isValidBc{\tp{isValidBc}}
\def\evtrans{\vr{ev\_trans}}
\def\evblock{\vr{ev\_block}}
\def\Hashmap{\tp{Hashmap}}
\def\Type{\tp{Type}}
\def\nat{\tp{nat\/}}
\def\hget{\vr{hget\/}}
\def\bbB{{\mathbb{B}}}
\def\st#1{{\mathbf{#1}}}
%
\hfuzz=0.8pt

\title{Telegram Open Network}
\author{Nikolai Durov\\
TL: Dr Awesome Doge}% a.k.a. K.O.T.
\begin{document}

%\pagestyle{myheadings}
\maketitle

\begin{abstract}
  本論文旨在首次詳述Telegram Open Network (TON) 以及相關的區塊鏈、P2P (點對點)、分散式儲存及服務託管技術。為了確保本文件的篇幅在合理的範疇內，我們主要針對TON平台中具有獨特性和關鍵定義的功能進行探討，這些功能對於實現其明確設定的目標具有核心重要性。
\end{abstract}

\section*{緒論}
\markbothsame{緒論}

{\em Telegram Open Network (TON)} 是一個快速、安全且可擴展的區塊鏈和網絡專案，如有必要，它能夠處理每秒數百萬筆交易，對使用者和服務提供者都非常友好。我們希望它能夠承載所有目前提議和構想的合理應用程式。人們可以將TON視為一個巨大的分散式超級電腦，或者更恰當地說，一個巨大的``超級伺服器''，旨在托管和提供各種服務。

本文並非關於所有實作細節的終極參考。在開發和測試階段，部分具體內容有可能發生變更。

\clearpage
\tableofcontents

\clearpage
\mysection{TON組件的簡要描述}\label{sect:ton.components}

{\em Telegram Open Network (TON)} 結合了以下組件：
\begin{itemize}
\item 一個靈活的多區塊鏈平台 ({\em TON Blockchain}; 參考第~\ptref{sect:blockchain}章)，能夠處理每秒數百萬筆交易，擁有圖靈完全智能合約、可升級的正式區塊鏈規格、多加密貨幣價值轉移、支持微支付通道和鏈下支付網絡。{\em TON Blockchain\/} 提供了一些新的和獨特的功能，例如「自我修復」垂直區塊鏈機制 (參考~\ptref{sp:inv.sh.blk.corr}) 和 Instant Hypercube Routing (參考~\ptref{sp:instant.hypercube})，使其同時快速、可靠、可擴展和自我一致。
\item 一個點對點網絡 ({\em TON P2P Network}, 或簡稱 {\em TON Network}; 參考第~\ptref{sect:network}章)，用於訪問TON區塊鏈、發送交易候選者，以及只接收客戶端感興趣的區塊鏈的部分更新（例如，與客戶端的賬戶和智能合約相關的部分），但也能支持任意分散服務，無論是否與區塊鏈相關。
\item 一種分散的文件存儲技術 {\em (TON Storage);} (參考~\ptref{sp:ex.ton.storage})，通過 {\em TON Network} 訪問，由TON Blockchain用於存儲區塊和狀態數據（快照）的存檔副本，但也可以用於存儲平台上的使用者或其他服務的任意文件，使用類似於torrent的訪問技術。
\item 一個網絡代理/匿名層 {\em (TON Proxy);} (參考~\ptref{sp:ex.ton.proxy} 和~\ptref{sp:tunnels})，類似於 $I^2P$ (Invisible Internet Project)，如有必要（例如，從擁有大量加密貨幣的賬戶提交交易的節點，或希望隱藏其確切IP地址和地理位置以對抗DDoS攻擊的高風險區塊鏈驗證器節點），用於隱藏 {\em TON Network\/} 節點的身份和IP地址。
\item 一個類似Kademlia的分散式哈希表 ({\em TON DHT}; 參考~\ptref{sect:kademlia})，用作 {\em TON Storage} 的「torrent tracker」(參考~\ptref{sp:distr.torr.tr})，作為 {\em TON Proxy\/} 的「input tunnel locator」(參考~\ptref{sp:loc.abs.addr})，以及作為 {\em TON Services} 的服務定位器 (參考~\ptref{sp:loc.serv})。
\item 一個提供任意服務的平台 ({\em TON Services}; 參考第~\ptref{sect:services}章)，居住在並可通過 {\em TON Network\/} 和 {\em TON Proxy} 訪問，具有正式化的界面 (參考~\ptref{sp:pub.int.smartc}) 使得瀏覽器或智能手機應用程序可以互動。這些正式界面和持久的服務入口點可以在TON Blockchain中發布 (參考~\ptref{sp:ui.ton.dns})；提供服務的實際節點可以從在TON Blockchain中發布的信息開始，通過 {\em TON DHT\/} 查找 (參考~\ptref{sp:loc.serv})。服務可以在TON Blockchain中創建智能合約，為其客戶提供一些保證 (參考~\ptref{sp:mixed.serv})。
\item {\em TON DNS\/} (參考~\ptref{sp:ton.dns})，用於為賬戶、智能合約、服務和網絡節點分配易讀的名稱。
\item {\em TON Payments\/} (參考第~\ptref{sect:payments}章)，一個用於微支付、微支付通道和微支付通道網絡的平台。它可用於快速的鏈下價值轉移，以及支付由 {\em TON Services} 提供的服務。
\item TON將允許輕鬆集成第三方消息和社交網絡應用程序，從而使區塊鏈技術和分散服務終於可用且可被普通使用者訪問 (參考~\ptref{sp:ton.www})，而不僅僅是少數早期的加密貨幣採用者。我們將在我們的另一個項目中，Telegram Messenger (參考~\ptref{sp:telegram.integr})，提供這樣的集成例子。
\end{itemize}

雖然 TON Blockchain 是 TON 專案的核心，而其他組件可能被視為對區塊鏈扮演輔助角色，但它們自身也具有有趣和實用的功能。結合使用，它們允許平台容納比僅使用 TON Blockchain 更多樣化的應用程式 (參考~\ptref{sp:blockchain.facebook} 和~\ptref{sect:ton.service.impl})。

\clearpage
\mysection{TON Blockchain}\label{sect:blockchain}

我們從描述 Telegram Open Network (TON) Blockchain 開始，這是該專案的核心組件。我們這裡的方法是「由上而下」：我們首先給出整體的一般描述，然後提供每個組件的更多細節。

為了簡單起見，我們在此談論 {\em the/} TON Blockchain，即使原則上這種區塊鏈協議可能有多個獨立運行的實例（例如，由於硬分叉的結果）。我們只考慮其中之一。

\mysubsection{TON Blockchain 作為 2-區塊鏈的集合}

TON Blockchain 實際上是區塊鏈的{\em 集合}（甚至是區塊鏈的區塊鏈集合，或稱為{\em 2-區塊鏈}---這一點將在~\ptref{sp:inv.sh.blk.corr}中進一步說明），因為沒有單一的區塊鏈專案能夠達到我們每秒處理數百萬交易的目標，而不是現在的每秒數十次交易的標準。


\nxsubpoint\label{sp:list.blkch.typ}
\embt(List of blockchain types.) 此系列中的區塊鏈包括：
\begin{itemize}
\item 唯一的{\em master blockchain}，或簡稱為{\em masterchain}，該區塊鏈包含有關協議的一般資訊、其參數的當前值、驗證者集合和他們的股份、當前活躍的工作鏈(workchains)及其"shards"，以及最重要的，所有workchains和shardchains的最近區塊的哈希集合。
\item 數個(最多 $2^{32}$)的{\em working blockchains}，或簡稱為{\em workchains}，實際上是這系統的"工作馬"，包含價值轉移和智慧合約交易。不同的workchains可能有不同的"規則"，意味著帳戶地址的不同格式、交易的不同格式、智慧合約的不同虛擬機(VMs)、不同的基本加密貨幣等等。然而，它們都必須滿足某些基本的互操作性標準，以確保不同的workchains之間的互動簡單和可能。在這方面，TON Blockchain是{\em heterogeneous}（參考~\ptref{sp:blkch.hom.het}），類似於EOS（參考~\ptref{sp:discuss.EOS}）和PolkaDot（參考~\ptref{sp:discuss.PolkaDot}）項目。
\item 每個workchain會進一步細分為多達 $2^{60}$ 的{\em shard blockchains}，或簡稱為{\em shardchains}，它們具有與workchain本身相同的規則和區塊格式，但只對帳戶的某個子集負責，這取決於帳戶地址的幾個首位(最重要的位)。換句話說，這系統內建了一種分片(sharding)的形式（參考~\ptref{sp:shard.supp}）。因為所有這些shardchains共享通用的區塊格式和規則，TON Blockchain在這方面是{\em homogeneous}（參考~\ptref{sp:blkch.hom.het}），這與Ethereum的某個擴展建議相似。\footnote{\url{https://github.com/ethereum/wiki/wiki/Sharding-FAQ}}
\item shardchain（和masterchain）中的每個區塊實際上不只是一個區塊，而是一個小區塊鏈。通常，這"block blockchain"或"vertical blockchain"只包含一個區塊，然後我們可能會認為這只是shardchain的相對應區塊（在這種情況下也稱為"horizontal blockchain"）。但是，如果需要修正不正確的shardchain區塊，新的區塊將被提交到"vertical blockchain"，包含無效"horizontal blockchain"區塊的替代品，或一個"block difference"，只包含該區塊先前版本中需要更改的部分的描述。這是一個TON特有的機制，用於替換檢測到的無效區塊，而不會真正地分叉所有涉及的shardchains；這將在~\ptref{sp:inv.sh.blk.corr}中詳細解釋。目前，我們只需指出，每個shardchain（和masterchain）不是一個常規的區塊鏈，而是一個{\em blockchain of blockchains}，或{\em 2D-blockchain}，或只是一個{\em 2-blockchain}。
\end{itemize}

\nxsubpoint\label{sp:ISP} \embt(Infinite Sharding Paradigm.)無限分片範式。 幾乎所有的區塊鏈分片提案都是「自上而下」：首先想像一個單一的區塊鏈，然後討論如何將它分割成幾個互動的分片鏈以提高效能和達到可擴展性。

TON的分片方法是「自下而上」，如下所述。

想像分片已被極端化，以至於每個分片鏈中只剩下一個帳戶或智能合約。然後我們有大量的「帳戶鏈」，每個鏈描述只有一個帳戶的狀態和狀態過渡，並向彼此發送具有價值的消息以傳輸價值和信息。

當然，擁有數億的區塊鏈是不切實際的，每個鏈中的更新（即新的區塊）通常出現得相對較少。為了更有效地實施它們，我們將這些「帳戶鏈」組合成「分片鏈」，以便分片鏈的每個區塊基本上是已分配給此分片的帳戶鏈的區塊的集合。因此，「帳戶鏈」只在「分片鏈」內部擁有純粹的虛擬或邏輯存在。

我們稱這種觀點為「無限分片範式」。它解釋了TON區塊鏈的許多設計決策。

\nxsubpoint\label{sp:msg.IHR} \embt(Messages. Instant Hypercube Routing.)消息。即時超立方路由。 無限分片範式告訴我們將每個帳戶（或智能合約）視為它自己的分片鏈中。然後，一個帳戶可能影響另一帳戶的狀態的唯一方式是向它發送一個「消息」（這是所謂的Actor模型的特殊實例，其中帳戶作為Actors；cf.~\ptref{sp:actors}）。因此，帳戶間（和分片鏈間，因為源帳戶和目的地帳戶，一般來說，位於不同的分片鏈中）的消息系統對於像TON區塊鏈這樣的可擴展系統非常重要。事實上，TON區塊鏈的一個新特性，稱為「即時超立方路由」（cf.~\ptref{sp:instant.hypercube}），使它能夠將消息從一個分片鏈的區塊傳遞和處理到目的地分片鏈的下一個區塊，{\em 不考慮系統中的分片鏈總數。}

\nxsubpoint \embt(Quantity of masterchains, workchains and shardchains.) TON 區塊鏈中恰有一個主鏈(masterchain)。但是，此系統有潛能容納高達 \(2^{32}\) 的工作鏈(workchains)，每個工作鏈都可細分為高達 \(2^{60}\) 的分片鏈(shardchains)。

\nxsubpoint \embt(Workchains can be virtual blockchains, not true blockchains.) 由於工作鏈通常被細分為分片鏈，工作鏈的存在是「虛擬的」，這意味著它不是一個真正的區塊鏈，如~\ptref{sp:gen.blkch.def}下提供的一般定義所描述，而只是一組分片鏈的集合。當只有一個分片鏈對應到一個工作鏈時，這個獨特的分片鏈可能與工作鏈相同，這樣它在某個時間點變成一個「真正的」區塊鏈，進而與常規的單一區塊鏈設計有相似性。然而，無限分片範式 (cf.~\ptref{sp:ISP}) 告訴我們這種相似性確實是表面的：能夠將潛在的大量「帳戶鏈」暫時分組到一個區塊鏈只是一個巧合。

\nxsubpoint \embt(Identification of workchains.) 每一個工作鏈都由其{\em number\/}或{\em workchain identifier\/}（\(\workchainid:\uint_{32}\)）來識別，它只是一個無符號的32位整數。工作鏈是由主鏈中的特殊交易所創建，定義（先前未使用的）工作鏈識別符和工作鏈的正式描述，至少足以讓此工作鏈與其他工作鏈互動以及對此工作鏈的區塊進行表面驗證。

\nxsubpoint \embt(Creation and activation of new workchains.) 新的工作鏈的創建可以由社區中的任何成員啟動，只要他們準備支付發佈新工作鏈的正式規範所需的（高額）主鏈交易費用。但是，為了使新的工作鏈變得活躍，需要三分之二的驗證者達成共識，因為他們需要升級他們的軟件以處理新工作鏈的區塊，並通過特殊的主鏈交易表示他們準備好與新的工作鏈一起工作。對新工作鏈的啟動感興趣的方可能會提供某些激勵，讓驗證者透過智能合約分發的某些獎勵來支持新的工作鏈。

\nxsubpoint\label{sp:shard.ident} \embt(Identification of shardchains.) 每個分片鏈(shardchain)都由一對 $(w,s)=(\workchainid, \shardpfx)$ 來識別，其中 $\workchainid:\uint_{32}$ 識別相應的工作鏈(workchain)，而 $\shardpfx:\st2^{0\ldots60}$ 是一個最長為60的位元串，定義此分片鏈所負責的帳戶子集。換句話說，所有以 $\shardpfx$ 開頭的帳戶 $\accountid$ （即，具有 $\shardpfx$ 作為最重要位元）都將被分配到這個分片鏈。

\nxsubpoint \embt(Identification of account-chains.) 回憶一下，帳戶鏈(account-chains)只有虛擬存在 (cf.~\ptref{sp:ISP})。然而，它們有一個自然的識別符——即，$(\workchainid,\accountid)$——因為任何帳戶鏈都包含關於恰好一個帳戶（無論是簡單帳戶還是智慧合約——這裡的區別不重要）的狀態和更新的信息。

\nxsubpoint\label{sp:dyn.split.merge} \embt(Dynamic splitting and merging of shardchains; cf.~\ptref{sect:split.merge}.) 一個較不複雜的系統可能使用{\em static sharding}，例如，使用 $\accountid$ 的前八位來選擇256個預定義的碎片之一。

TON 區塊鏈的一個重要特點是它實現了{\em dynamic sharding}，這意味著碎片的數量不是固定的。相反，如果滿足某些正式條件（基本上，如果原始碎片上的交易負載在很長的時間內都足夠高），分片 $(w,s)$ 可以自動細分為分片 $(w,s.0)$ 和 $(w,s.1)$。相反，如果負載在一段時間內保持得太低，分片 $(w,s.0)$ 和 $(w,s.1)$ 可以自動合併回分片 $(w,s)$。

最初，只為工作鏈 $w$ 創建了一個分片 $(w,\emptyset)$。稍後，當這變得必要時，它被細分為更多的分片 (cf.~\ptref{sp:split.necess} and~\ptref{sp:merge.necess})。

\nxsubpoint\label{sp:basic.workchain} \embt(Basic workchain or Workchain Zero.) 雖然可以定義高達 $2^{32}$ 的工作鏈(workchains)並有其特定的規則和交易，但我們一開始只定義一個，即 $\workchainid=0$。這個工作鏈被稱為Workchain Zero或基礎工作鏈，它是用於操作{\em TON smart contracts\/} 和轉移{\em TON coins}，也稱為{\em Grams\/} (cf.\ Appendix~\ref{app:coins})。大多數應用可能只需要Workchain Zero。基礎工作鏈的分片鏈會被稱為{\em basic shardchains}。

\nxsubpoint \embt(Block generation intervals.) 我們預計每個分片鏈和主鏈大約每五秒會生成一個新的區塊。這將導致相對較小的交易確認時間。所有分片鏈的新區塊大約同時生成；主鏈的新區塊大約在一秒後生成，因為它必須包含所有分片鏈的最新區塊的雜湊值。

\nxsubpoint\label{sp:sc.hash.mc} \embt(Using the masterchain to make workchains and shardchains tightly coupled.) 一旦分片鏈的區塊的雜湊值被合併到主鏈的區塊中，該分片鏈區塊及其所有祖先都被認為是「正規的」，這意味著它們可以被所有分片鏈的後續區塊引用為固定且不可變的內容。實際上，每個新的分片鏈區塊都包含最近的主鏈區塊的雜湊值，並且從該主鏈區塊引用的所有分片鏈區塊在新區塊中都被認為是不可變的。

從本質上講，這意味著在分片鏈區塊中提交的交易或消息可以在其他分片鏈的下一個區塊中安全地使用，而不需要等待，例如，二十次確認（即在同一區塊鏈中在原始區塊之後生成的二十個區塊）之前轉發消息或基於之前的交易採取其他操作，這在大多數建議的「鬆散連接」系統中很常見(cf.~\ptref{sp:blkch.interact})，如EOS。我們相信，這種能力在提交後的五秒內在其他分片鏈中使用交易和消息是我們這種「緊密連接」系統能夠提供前所未有的性能的原因之一(cf.~\ptref{sp:shard.supp} and~\ptref{sp:blkch.interact})。

\nxsubpoint \embt(Masterchain block hash as a global state.) 根據~\ptref{sp:sc.hash.mc}，最後一個主鏈區塊的雜湊完全確定了外部觀察者的整體系統狀態。人們不需要單獨監視所有分片鏈的狀態。

\nxsubpoint \embt(Generation of new blocks by validators; cf.~\ptref{sect:validators}.) TON 區塊鏈使用 Proof-of-Stake (PoS) 方法在分片鏈和主鏈中生成新的區塊。這意味著有一組，例如，多達幾百個的{\em validators}---特殊的節點，透過特殊的主鏈交易存放{\em stakes\/}（大量的 TON coins）以符合生成和驗證新區塊的資格。

然後，小部分的驗證器被分配給每一個分片 $(w,s)$，這是以決定性的偽隨機方式進行的，每1024個區塊大約會改變一次。這部分的驗證器建議並在下一個分片鏈區塊應是什麼上達成共識，通過從客戶端收集適當的建議交易到新的有效的區塊候選。對於每個區塊，驗證器上有一個偽隨機選定的順序，以確定誰的區塊候選在每一輪中有最高的優先順序被提交。

驗證器和其他節點檢查所提議的區塊候選的有效性；如果驗證器簽署了一個無效的區塊候選，它可能會自動被懲罰，失去部分或全部的 stake，或被暫停從驗證器集合一段時間。之後，驗證器應達成對下一個區塊的選擇的共識，本質上是 BFT (Byzantine Fault Tolerant; cf.~\ptref{sp:dpos.bft}) 共識協議的高效變體，類似於 PBFT~\cite{PBFT} 或 Honey Badger BFT~\cite{HoneyBadger}。如果達到共識，將創建新的區塊，且驗證器在交易費用上進行分割，包括交易，加上一些新創建的（“鑄造的”）硬幣。

每個驗證器可以被選舉參與多個驗證器子集；在這種情況下，預計它將平行運行所有的驗證和共識算法。

在生成所有新的分片鏈區塊之後或超時之後，將生成一個新的主鏈區塊，包括所有分片鏈的最新區塊的雜湊值。這是通過{\em all\/} 驗證器的 BFT 共識完成的。\footnote{實際上，兩個三分之一的 stake 就足夠達成共識，但努力收集盡可能多的簽名。}

TON PoS 方法及其經濟模型的更多細節提供在 section~\ptref{sect:validators}。

\nxsubpoint \embt(Forks of the masterchain.) 我們緊密耦合的方法帶來的一個複雜性是，切換到主鏈的不同分叉幾乎必然需要在至少一些分片鏈中切換到另一個分叉。另一方面，只要主鏈中沒有分叉，分片鏈中的分叉甚至都是不可能的，因為分片鏈的替代分叉中的沒有區塊可以通過將其哈希值納入主鏈區塊而變得「標準化」。

一般的規則是，{\em 如果主鏈區塊 $B'$ 是 $B$ 的前輩，$B'$ 包括 $(w,s)$-分片鏈區塊 $B'_{w,s}$ 的哈希 $\Hash(B'_{w,s})$，且 $B$ 包括哈希 $\Hash(B_{w,s})$，那麼 $B'_{w,s}$ {\bf 必須}是 $B_{w,s}$ 的前輩; 否則，主鏈區塊 $B$ 就是無效的。}

我們預期主鏈分叉將會很少，幾乎不存在，因為在由 TON 區塊鏈所採用的 BFT 範疇中，它們只能在{\em 大部分\/} 驗證器行為不正確的情況下發生（參見~\ptref{sp:validators} 和~\ptref{sp:new.master.blk}），這將意味著由違反者承擔的重大的 stake 損失。因此，不應期待分片鏈中存在真正的分叉。相反，如果檢測到一個無效的分片鏈區塊，將通過 2-blockchain 的「垂直區塊鏈」機制進行修正（參見~\ptref{sp:inv.sh.blk.corr}），這可以在不分叉「水平區塊鏈」（即，分片鏈）的情況下實現此目標。同樣的機制也可以用來修正主鏈區塊中的非致命性錯誤。

\nxsubpoint\label{sp:inv.sh.blk.corr} \embt(Correcting invalid shardchain blocks.) 通常，只有有效的分片鏈區塊會被提交，因為分配給分片鏈的驗證器在新區塊可以被提交之前必須達到三分之二的拜占庭共識。然而，系統必須允許檢測先前提交的無效區塊及其校正。

當然，一旦找到一個無效的分片鏈區塊 —— 不論是由一個驗證器（不一定分配到這個分片鏈）還是一個「漁夫」（系統的任何節點，它已經支付了某個存款以便對區塊有效性提出疑問；參見~\ptref{sp:fish}）—— 無效性的主張及其證明都會被提交到主鏈，而已經簽署無效區塊的驗證器將被懲罰，部分或全部扣除他們的 stake，和/或暫時從驗證器集合中被停權（後者的措施對於攻擊者竊取本質上良性的驗證器的私有簽名鍵非常重要）。

然而，這還不夠，因為由於先前提交的無效分片鏈區塊，系統（TON 區塊鏈）的整體狀態結果是無效的。這個無效區塊必須被一個新的有效版本替換。

大多數系統會通過「回滾」到該分片鏈中的無效區塊之前的最後一個區塊，以及每個其他分片鏈中不受從無效區塊傳播的消息影響的最後區塊，並從這些區塊創建一個新的分叉來實現這一點。這種方法的缺點是，大量本來正確且已提交的交易突然被回滾，且不清楚它們是否會在稍後再次被包括。

TON 區塊鏈通過使每個分片鏈和主鏈的每個「區塊」（「水平區塊鏈」）本身都成為一個小型區塊鏈（「垂直區塊鏈」），包含這個「區塊」的不同版本，或其「差異」來解決這個問題。通常，垂直區塊鏈只包含一個區塊，而分片鏈看起來像一個經典的區塊鏈。但是，一旦一個區塊的無效性被確認並提交到主鏈區塊中，該無效區塊的「垂直區塊鏈」就被允許在垂直方向上增加一個新區塊，替換或編輯無效區塊。這個新區塊是由當前問題分片鏈的驗證器子集生成的。


新的“垂直”區塊要有效的規則非常嚴格。特別是，如果無效區塊中包含的虛擬“帳戶鏈區塊”（參見 \ptref{sp:ISP}）本身是有效的，則它必須被新的垂直區塊保持不變。

一旦在無效區塊上方提交了新的“垂直”區塊，它的哈希就會在新的Masterchain區塊中公布（或者更正確地說，在原始Masterchain區塊上方的新“垂直”區塊中公布，該區塊中最初發布了無效Shardchain區塊的哈希），並且進一步將更改傳播到任何參照此區塊的Shardchain區塊（例如，那些從不正確的區塊接收消息的區塊）。這可以通過在先前參照“不正確”區塊的所有區塊的垂直區塊鏈中提交新的“垂直”區塊來進行修正；新的垂直區塊將參照最新（已更正）的版本。同樣，嚴格的規則禁止更改未受到實際影響的帳戶鏈（即，與前一版本中收到的消息相同的帳戶鏈）。通過這種方式，修正不正確的區塊產生“漣漪”，最終傳播到所有受影響的Shardchain的最新區塊；這些更改也反映在新的“垂直”Masterchain區塊中。

一旦“歷史重寫”的漣漪到達最新區塊，新的Shardchain區塊僅以一個版本生成，僅作為最新區塊版本的後繼者。這意味著它們將從一開始就包含對正確（最新）的垂直區塊的引用。

Masterchain狀態隱含地定義了一個映射，將每個“垂直”區塊鏈的第一個區塊的哈希轉換為其最新版本的哈希。這使客戶端可以通過其第一個（通常是唯一的）區塊的哈希識別和定位任何垂直區塊鏈。

\nxsubpoint \embt(TON coins and multi-currency workchains.)  TON區塊鏈支持多達$2^{32}$種不同的“加密貨幣”、“硬幣”或“代幣”，通過32位的$\currencyid$加以區分。新的加密貨幣可以通過主鏈中的特殊交易來添加。每個工作鏈都有一種基本加密貨幣，並且可以有幾種其他加密貨幣。

有一種特殊的加密貨幣，$\currencyid=0$，即{\em TON幣}，也稱為{\em Gram}（參見附錄~\ref{app:coins}）。這是工作鏈零的基本加密貨幣。它也用於交易費和驗證者的權益股份。

原則上，其他工作鏈可能會以其他代幣收取交易費。在這種情況下，應該提供一些智能合約，用於將這些交易費自動轉換為Grams。

\nxsubpoint \embt(Messaging and value transfer.) 屬於相同或不同工作鏈的分片鏈可以互相傳送{\em messages\/}。儘管允許的訊息的確切形式取決於接收工作鏈和接收帳戶（智慧合約），但有一些共同的欄位使跨工作鏈的訊息成為可能。特別是，每條訊息可能會有一些{\em value}，以一定數量的Grams（TON coins）和/或其他註冊的加密貨幣的形式附加，前提是它們被接收工作鏈宣布為可接受的加密貨幣。

這種訊息的最簡單形式是從一個（通常不是智慧合約）帳戶到另一個帳戶的價值轉移。

\nxsubpoint\label{sp:tonvm} \embt(TON Virtual Machine.)  {\em TON Virtual Machine}，也縮寫為{\em TON VM\/}或{\em TVM\/}，是用於在主鏈和基本工作鏈中執行智慧合約代碼的虛擬機器。其他工作鏈可能使用其他虛擬機器，與TVM一起或替代TVM。

以下我們列出了其一些特性。它們在~\ptref{sp:pec.tvm}、\ptref{sp:tvm.cells}和其他地方進一步討論。

\begin{itemize}
\item TVM 將所有資料表示為一系列的{\em (TVM) cells/} (參考~\ptref{sp:tvm.cells})。每一個 cell 包含最多 128 個資料位元組，以及最多 4 個指向其他 cells 的參考。基於“一切皆為 cell 包”的理念 (參考~\ptref{sp:everything.is.BoC})，這使得 TVM 能夠處理與 TON 區塊鏈相關的所有資料，包括必要時的區塊和區塊鏈全局狀態。
\item TVM 可以處理任意代數資料型態的值 (參考~\ptref{sp:pec.tvm})，表示為 TVM cells 的樹或有向非循環圖。但它對代數資料型態的存在是不知情的；它只是處理 cells。
\item TVM 內建支援 hashmaps (參考~\ptref{sp:patricia})。
\item TVM 是一個堆疊機器。它的堆疊保存 64 位元整數或 cell 參考。
\item 支援 64-bit, 128-bit 和 256-bit 的算術運算。所有 $n$-bit 的算術操作都有三種形式：用於無符號整數，用於有符號整數，以及對於模 $2^n$ 的整數（後者不自動檢查溢出）。
\item TVM 有從 $n$-bit 轉換到 $m$-bit 的無符號和有符號整數，對所有 $0\leq m,n\leq 256$，並具有溢出檢查。
\item 所有算術操作預設執行溢出檢查，這大大簡化了智能合約的開發。
\item TVM 有“乘然後移位”和“移位然後除”的算術操作，中間值在更大的整數型態中計算；這簡化了固定點算術的實現。
\item TVM 提供對位串和字節串的支援。
\item 提供對某些預定義曲線，包括 Curve25519 的 256-bit 橢圓曲線加密 (ECC) 的支援。
\item 對於在某些橢圓曲線上的 Weil 配對的支援也存在，這對於快速實現 zk-SNARKs 很有用。
\item 支援包括 $\Sha$ 在內的流行雜湊函數。
\item TVM 可以處理 Merkle 證明 (參考~\ptref{sp:ton.smart.pc.supp})。
\item TVM 提供對“大型”或“全局”智能合約的支援。這類智能合約必須知道分片 (參考~\ptref{sp:loc.glob.smct} 和 \ptref{sp:tvm.data.shard})。常規（本地）智能合約可以是不知道分片的。
\item TVM 支援閉包。
\item 一個“無脊標籤 $G$-機器” \cite{STGM} 可以容易地在 TVM 內部實現。
\end{itemize}
除了“TVM 組件”，還可以為 TVM 設計幾種高級語言。所有這些語言都將具有靜態類型，並支援代數資料型態。我們預見以下可能性：
\begin{itemize}
\item 類似 Java 的命令式語言，每個智能合約都像一個獨立的類。
\item 惰性的功能語言 (如 Haskell)。
\item 積極的功能語言 (如 ML)。
\end{itemize}
 
\nxsubpoint\label{sp:config.param} \embt(Configurable parameters.) 
TON Block\-chain 的一個重要特性是它有許多{\em 可配置的}參數。這意味著它們是 masterchain 狀態的一部分，且可以通過 masterchain 中的某些特殊的提議/投票/結果交易來更改，而不需要硬分叉。更改這些參數需要收集三分之二的驗證者投票，以及超過一半想要參與投票過程的所有其他參與者的投票以支持該提議。

\mysubsection{關於區塊鏈的概論}

\nxsubpoint\label{sp:gen.blkch.def} \embt(General blockchain definition.) 
一般來說，任何{\em (真實的) 區塊鏈\/}都是一系列的{\em 區塊}，每個區塊 \(B\) 都包含一個參考至前一個區塊的 $\blkprev(B)$ （通常是將前一個區塊的雜湊包含在當前區塊的標頭中），以及一個{\em 交易}的列表。每筆交易都描述了{\em 全球區塊鏈狀態}的某種轉換; 一個區塊中列出的交易是按順序應用的，從舊狀態開始計算新狀態，這是在評估前一個區塊後的結果狀態。

\nxsubpoint \embt(Relevance for the TON Blockchain.) 
請注意，{\em TON Block\-chain\/} 並不是真正的區塊鏈，而是 2-區塊鏈的集合（即，區塊鏈的區塊鏈集合; 參考~\ptref{sp:list.blkch.typ}），所以上述內容並不直接適用於它。然而，我們從真正的區塊鏈的這些一般性開始，用它們作為我們更複雜建構的基礎。

\nxsubpoint \embt(Blockchain instance and blockchain type.)  人們經常使用「{\em blockchain\/}」一詞來表示一般的{\em blockchain type\/} 和其特定的 {\em blockchain instances}，定義為滿足某些條件的區塊序列。例如，\ptref{sp:gen.blkch.def} 是指區塊鏈的實例。

由此，一個區塊鏈類型通常是類型 $\Block^*$ 的「子類型」，由那些滿足某些相容性和有效性條件的區塊序列組成：
\begin{equation}
  \Blockchain \subset \Block^*
\end{equation}

更好的定義方式是說 $\Blockchain$ 是一個{\em dependent couple type}，由 couple $(\bbB,v)$組成，第一部分 $\bbB:\Block^*$ 是類型 $\Block^*$（即區塊列表），第二部分 $v:\isValidBc(\bbB)$ 是 $\bbB$ 的有效性的證明或證人。由此，
\begin{equation}
  \Blockchain\equiv\Sigma_{(\bbB:\Block^*)}\isValidBc(\bbB)
\end{equation}
我們在這裡使用了從~\cite{HoTT} 借用的依賴型態和的表示法。

\nxsubpoint \embt(Dependent type theory, Coq and TL.)  注意，我們在此使用的是（Martin-L\"of）依賴型態理論，類似於 Coq\footnote{\url{https://coq.inria.fr}} 證明助手中使用的。依賴型態理論的簡化版本也用於{\em TL (Type
  Language)}\footnote{\url{https://core.telegram.org/mtproto/TL}}，將在 TON Blockchain 的正式規範中使用，描述所有資料結構的序列化以及區塊、交易等的佈局。

事實上，依賴型態理論提供了對證明是什麼的有用形式化。當需要提供某個區塊的無效性證明時，這種形式的證明（或它們的序列化）可能會變得很有用。

\nxsubpoint\label{sp:TL} \embt(TL, or the Type Language.)  由於 TL（Type Language）將被用於 TON 區塊、交易和網路數據包的正式規範，因此值得簡短地討論。

TL 是一種適用於描述依賴代數的{\em types}的語言，允許具有數字（自然數）和型態參數。每個型態都通過幾個{\em constructors}來描述。每個構造器都有一個（人類可讀的）識別碼和一個{\em name}，這是一個位元組列（預設為32位整數）。除此之外，構造器的定義包含一個與其型態一起的字段列表。

構造器和型態定義的集合被稱為{\em TL-scheme}。它通常保存在一個或多個帶有 \texttt{.tl} 後綴的文件中。

TL-schemes 的一個重要特性是，它們確定了序列化和反序列化定義的代數型態的值（或對象）的明確方式。具體來說，當一個值需要被序列化為一串位元組時，首先序列化用於此值的構造器的名稱。然後是每個字段的遞迴計算的序列化。

一個適合序列化任意對象為 32 位整數序列的 TL 的先前版本的描述，可以在 \url{https://core.telegram.org/mtproto/TL} 上找到。一個新版本的 TL，名為 {\em TL-B}，正在開發中，用於描述 TON Project 使用的對象的序列化。這個新版本可以將對象序列化為位元組流，甚至是位元流（而不僅僅是32位整數），並提供將其序列化為 TVM cell 樹的支持（cf.~\ptref{sp:tvm.cells}）。TL-B 的描述將是 TON Blockchain 的正式規範的一部分。



\nxsubpoint\label{sp:blk.transf} \embt(Blocks and transactions as
state transformation operators.) 通常，任何區塊鏈(型態)
$\Blockchain$ 都有一個關聯的全域狀態(型態) $\State$，以及一個
交易(型態) $\Transaction$。區塊鏈的語意在很大程度上是由交易應用函數所決定的：
\begin{equation}
  \evtrans':\Transaction\times\State\to\State^?
\end{equation}
這裡的 $X^?$ 表示 $\Maybe X$，是將 $\Maybe$ 單子應用於型態 $X$ 的結果。這與我們使用 $X^*$ 表示 $\List
X$ 類似。本質上，型態 $X^?$ 的值要麼是型態 $X$ 的值，要麼是一個特殊值 $\bot$ 表示實際值的缺失
(想想空指標)。在我們的情境中，我們使用 $\State^?$ 而不是 $\State$ 作為結果型態，因為某個交易從某些原始狀態
呼叫可能是無效的 (想想從賬戶中提款的金額超過實際存在的金額的情況)。

我們可能更偏好 $\evtrans'$ 的柯里化版本：
\begin{equation}
  \evtrans:\Transaction\to\State\to\State^?
\end{equation}

因為一個區塊本質上是交易的列表，所以區塊的評估函數
\begin{equation}
  \evblock:\Block\to\State\to\State^?
\end{equation}
可以從 $\evtrans$ 中衍生出來。它接受一個區塊 $B:\Block$ 和前一個區塊鏈狀態 $s:\State$ (可能包括前一個區塊的雜湊) 並計算下一個區塊鏈狀態
$s'=\evblock(B)(s):\State$，它要么是一個真正的狀態，要么是一個特殊值 $\bot$ 表示下一狀態無法被計算 (也就是說，從給定的起始狀態評估時該區塊是無效的——例如，該區塊包含試圖從一個空帳戶扣款的交易)。

\nxsubpoint \embt(Block sequence numbers.) 每個在區塊鏈中的區塊 $B$
可以由其{\em 序列號} $\blkseqno(B)$ 來參照，從第一個區塊開始為零，並在過渡到下一個區塊時加一。更正式地說，
\begin{equation}
  \blkseqno(B)=\blkseqno\bigl(\blkprev(B)\bigr)+1
\end{equation}
請注意，序列號在有{\em 分叉}的情況下不能唯一識別一個區塊。

\nxsubpoint \embt(Block hashes.) 參考區塊 $B$ 的另一種方式是通過其雜湊 $\blkhash(B)$，其實際上是區塊 $B$ 的
            {\em 頭部\/}的雜湊（但是，區塊的頭部通常包含依賴於區塊 $B$ 的所有內容的雜湊）。假設所使用的雜湊函數沒有碰撞（或至少它們是非常不可能的），一個區塊可以由其雜湊唯一識別。

\nxsubpoint \embt(Hash assumption.) 在對區塊鏈算法進行正式分析時，我們假設使用的 $k$-bit 雜湊函數 $\Hash:\Bytes^*\to\st2^{k}$ 沒有碰撞：
\begin{equation}\label{eq:hash.coll}
  \Hash(s)=\Hash(s')\Rightarrow s=s'\quad\text{對任何 $s$,
    $s'\in\Bytes^*$}
\end{equation}
這裡的 $\Bytes=\{0\ldots255\}=\st2^8$ 是位元組的類型，或所有位元組值的集合，而 $\Bytes^*$ 是任意（有限）位元組列表的類型或集合；而 $\st2=\{0,1\}$ 是位元類型，和 $\st2^k$ 是所有 $k$-bit 序列的集合（即，$k$-bit 數字）。

當然，\eqref{eq:hash.coll} 在數學上是不可能的，因為從一個無窮集合到一個有限集合的映射不能是單射。一個更嚴格的假設是
\begin{equation}\label{eq:hash.coll.prec}
  \forall s, s': s\neq s', P\bigl(\Hash(s)=\Hash(s')\bigr)=2^{-k}
\end{equation}
然而，這對於證明不太方便。如果在某個小的 $\epsilon$（例如，$\epsilon=10^{-18}$）的證明中\eqref{eq:hash.coll.prec} 至多使用了 $N$ 次，其中 $2^{-k}N<\epsilon$，我們可以像 \eqref{eq:hash.coll} 是真的那樣推理，只要我們接受失敗概率 $\epsilon$（即，最終的結論至少以概率 $1-\epsilon$ 為真）。

最後的備註：為了使~\eqref{eq:hash.coll.prec} 的概率說明真正嚴格，必須在所有位元組序列的集合 $\Bytes^*$ 上引入一個概率分佈。做到這一點的一種方法是假設相同長度 $l$ 的所有位元組序列都是等概率的，並設置觀察到長度為 $l$ 的序列的概率等於 $p^l-p^{l+1}$，對於某些 $p\to1-$。然後應該將\eqref{eq:hash.coll.prec} 理解為當 $p$ 從下面趨近於一時的條件概率 $P\bigl(\Hash(s)=\Hash(s')|s\neq s'\bigr)$ 的極限。

\nxsubpoint\label{sp:hash.change} \embt(Hash used for the TON
Blockchain.) 我們目前為TON Blockchain使用256-bit的$\Sha$雜湊。如果它被證明比預期弱，未來可以被另一個雜湊函數所取代。雜湊函數的選擇是協議的可配置參數，所以可以在~\ptref{sp:config.param}中解釋的，無需硬分叉即可更改。

\mysubsection{區塊鏈狀態、帳戶和雜湊映射}

如上所述，任何區塊鏈都定義了某種全局狀態，且每個區塊和每個交易都定義了這個全局狀態的轉換。在此我們描述由TON區塊鏈使用的全局狀態。

\nxsubpoint \embt(Account IDs.) TON區塊鏈使用的基本帳戶ID──或者至少由其主鏈和工作鏈零所使用──是256-bit整數，假設是針對特定橢圓曲線的256-bit橢圓曲線密碼學(ECC)的公鑰。這樣，
\begin{equation}
  \accountid:\Account=\uint_{256}=\st2^{256}
\end{equation}
這裡的$\Account$是帳戶的{\em 類型}，而$\accountid:\Account$是類型$\Account$的特定變量。

其他工作鏈可以使用其他帳戶ID格式，無論是256-bit還是其他格式。例如，可以使用等於ECC公鑰的$\Sha$的比特幣風格的帳戶ID。

但是，帳戶ID的位長度$l$必須在工作鏈的創建期間（在主鏈中）固定，且必須至少為64，因為$\accountid$的前64位用於分片和訊息路由。

\nxsubpoint \embt(Main component: {\em Hashmaps}.) TON區塊鏈狀態的主要組件是一個{\em 雜湊映射}。在某些情況下，我們考慮（部分定義的）``映射'' $h:\st2^n\dashrightarrow\st2^m$。更一般地說，我們可能對於複合類型$X$的雜湊映射$h:\st2^n\dashrightarrow X$感興趣。但是，源（或索引）類型幾乎總是$\st2^n$。

有時，我們有一個``預設值'' $\vr{empty}:X$，且雜湊映射$h:\st2^n\to X$由其``預設值'' $i\mapsto\vr{empty}$「初始化」。

\nxsubpoint \embt(Example: TON account balances.) 一個重要的例子是TON帳戶餘額。它是一個雜湊映射
\begin{equation}
  \vr{balance}:\Account\to\uint_{128}
\end{equation}
將 $\Account=\st2^{256}$ 映射為類型為 $\uint_{128}=\st2^{128}$ 的Gram (TON幣) 餘額。此雜湊映射的預設值為零，這意味著最初（在處理第一個區塊之前）所有帳戶的餘額都是零。

\nxsubpoint \embt(Example: smart-contract persistent storage.) 另一個例子是智能合約的持久存儲，可以（非常大致地）表示為一個雜湊映射
\begin{equation}
  \vr{storage}:\st2^{256}\dashrightarrow\st2^{256}
\end{equation}
此雜湊映射的預設值也為零，這意味著未初始化的持久存儲單元被認為是零。

\nxsubpoint \embt(Example: persistent storage of all smart contracts.) 因為我們有多於一個的智能合約，由 $\accountid$ 區分，每個合約都有其獨立的持久存儲，所以我們實際上必須有一個雜湊映射
\begin{equation}
  \vr{Storage}:\Account\dashrightarrow(\st2^{256}\dashrightarrow\st2^{256})
\end{equation}
將智能合約的 $\accountid$ 映射到其持久存儲。

\nxsubpoint \embt(Hashmap type.) 雜湊映射不僅僅是一個抽象的（部分定義的）函數 $\st2^n\dashrightarrow X$；它具有特定的表示方式。因此，我們假設我們有一個特殊的雜湊映射類型
\begin{equation}
  \Hashmap (n,X):\Type
\end{equation}
對應於編碼（部分）映射 $\st2^n\dashrightarrow X$ 的資料結構。我們也可以寫作
\begin{equation}
  \Hashmap (n:\nat) (X:\Type) : \Type
\end{equation}
或
\begin{equation}
  \Hashmap:\nat\to\Type\to\Type
\end{equation}
我們總是可以將 $h:\Hashmap(n,X)$ 轉換為一個映射 $\hget(h):\st2^n\to X^?$。從此，我們通常寫作 $h[i]$ 而非 $\hget(h)(i)$:
\begin{equation}
  h[i]:\equiv\hget(h)(i):X^?\quad\text{對於任何 $i:\st2^n$, $h:\Hashmap(n,X)$}
\end{equation}

\nxsubpoint\label{sp:patricia} \embt(Definition of hashmap type as a Patricia tree.) 從邏輯上講，我們可能會定義 $\Hashmap(n,X)$ 為一個深度為 $n$ 的（不完整的）二進制樹，其邊的標籤為 $0$ 和 $1$，而葉子中的值類型為 $X$。描述相同結構的另一種方式是作為長度等於 $n$ 的二進制字符串的{\em (按位) trie\/}。

在實際應用中，我們更傾向於使用這種 trie 的緊湊表示，通過壓縮每個只有一個子節點的頂點及其父節點。得到的表示稱為 {\em Patricia tree\/} 或 {\em binary radix tree\/}。每個中間頂點現在都有確切的兩個子節點，由兩個非空的二進制字符串標記，左子節點開始為零，右子節點開始為一。

換句話說，在 Patricia 樹中有兩種類型的（非根）節點：
\begin{itemize}
\item $\leaf(x)$，包含類型為 $X$ 的值 $x$。
\item $\node(l,s_l,r,s_r)$，其中 $l$ 是左子節點或子樹的（引用），$s_l$ 是連接此頂點到其左子節點的邊的位字符串標籤（始終以 0 開頭），$r$ 是右子樹，$s_r$ 是到右子節點的邊的位字符串標籤（始終以 1 開頭）。
\end{itemize}
還需要第三種節點類型，只在 Patricia 樹的根上使用一次：
\begin{itemize}
\item $\root(n,s_0,t)$，其中 $n$ 是 $\Hashmap(n,X)$ 的索引位字符串的公共長度，$s_0$ 是所有索引位字符串的公共前綴，$t$ 是指向 $\leaf$ 或 $\node$ 的引用。
\end{itemize}
如果我們想允許 Patricia 樹為空，則會使用第四種類型的（根）節點：
\begin{itemize}
\item $\emptyroot(n)$，其中 $n$ 是所有索引位字符串的公共長度。
\end{itemize}

我們通過以下方式定義 Patricia 樹的高度：
\begin{align}
  \height(\leaf(x))&=0\\ \height\bigl(\node(l,s_l,r,s_r)\bigr)&=\height(l)+\len(s_l)=\height(r)+\len(s_r)\\ \height\bigl(\root(n,s_0,t)\bigr)&=\len(s_0)+\height(t)=n
\end{align}
最後兩個公式中的最後兩個表達式必須相等。我們使用高度為 $n$ 的 Patricia 樹來表示類型為 $\Hashmap(n,X)$ 的值。

如果樹中有 $N$ 個葉子（即，我們的雜湊映射包含 $N$ 個值），則確切有 $N-1$ 個中間頂點。插入一個新值總是涉及通過在中間插入一個新頂點來分割一個現有的邊，並添加一個新葉子作為這個新頂點的另一個子節點。從雜湊映射中刪除一個值做的恰恰相反：葉子和它的父節點被刪除，並且父節點的父節點和其另一個子節點直接連接。

\nxsubpoint\label{sp:merkle.patr.hash} \embt(Merkle-Patricia trees.) 當使用區塊鏈時，我們希望能夠比較 Patricia 樹（即，雜湊映射）及其子樹，並將它們縮減為單一的雜湊值。實現此目的的經典方法是由 Merkle 樹給出的。本質上，我們希望描述一種利用雜湊函數 $\Hash$（為二進制字符串定義）對類型為 $\Hashmap(n,X)$ 的對象 $h$ 進行雜湊的方法，只要我們知道如何計算對象 $x:X$ 的雜湊 $\Hash(x)$ （例如，通過將雜湊函數 $\Hash$ 應用於對象 $x$ 的二進制序列化）。

我們可能會如下遞迴地定義 $\Hash(h)$：
\begin{align}\label{eq:hash.leaf}
  \Hash\bigl(\leaf(x)\bigr):=&\Hash(x)\\
  \label{eq:hash.node}
  \Hash\bigl(\node(l,s_l,r,s_r)\bigr):=&\Hash\bigl(\Hash(l).\Hash(r).\code(s_l).\code(s_r)\bigr)\\ \Hash\bigl(\root(n,s_0,t)\bigr):=&\Hash\bigl(\code(n).\code(s_0).\Hash(t)\bigr)
\end{align}
在此，$s.t$ 表示 (位) 字符串 $s$ 和 $t$ 的連接，而 $\code(s)$ 是所有位字符串 $s$ 的前綴碼。例如，可以通過 10 來編碼 0，通過 11 來編碼 1，並通過 0 來編碼字符串的結尾。%
\footnote{可以證明對於大約一半的 Patricia 樹的邊標籤（具有隨機或連續索引）來說，這種編碼是最優的。其餘的邊標籤可能會很長（即，幾乎有 256 位）。因此，邊標籤的幾乎最優編碼是使用上述碼，對於「短」位字符串使用前綴 0，然後編碼 1，然後是包含位字符串 $s$ 的長度 $l=|s|$ 的九位，然後是 $s$ 的 $l$ 位，用於「長」位字符串（其中 $l\geq10$）。}

我們稍後會看到（參見 \ptref{sp:pec.tvm} 和 \ptref{sp:tvm.cells}），這是針對任意（依賴型）代數類型的值的遞迴定義的雜湊的（稍微調整的）版本。

\nxsubpoint \embt(Recomputing Merkle tree hashes.) 這種遞迴定義 $\Hash(h)$ 的方法，稱為 {\em Merkle tree hash}，具有以下優點：如果與每個節點 $h'$ 一起明確存儲 $\Hash(h')$（結果在結構上被稱為 {\em Merkle tree}，或在我們的情況下，稱為 {\em Merkle--Patricia tree}），則當元素被添加到雜湊映射、從雜湊映射中刪除或在雜湊映射中更改時，最多只需要重新計算 $n$ 個雜湊。

因此，如果將全局區塊鏈狀態表示為適當的 Merkle 樹雜湊，則在每次交易後，重新計算此狀態雜湊就變得很容易。

\nxsubpoint\label{sp:merkle.proof} \embt(Merkle proofs.) 根據所選雜湊函數 $\Hash$ 的「單射性」假設 \eqref{eq:hash.coll}，可以構造一個證明，對於 geven 值 $z$ 的 $\Hash(h)$, $h:\Hashmap(n,X)$, 存在某些 $i:\st2^n$ 和 $x:X$ 使得 $\hget(h)(i)=x$。這樣的證明將包括從對應於 $i$ 的葉子到根的 Merkle--Patricia 樹中的路徑，由此路徑上出現的所有節點的所有兄弟的雜湊增強。

這樣，一個輕量節點%
\footnote{「輕量節點」不跟踪 shardchain 的完整狀態；相反，它保留最小的資訊，例如幾個最近的區塊的雜湊，並在需要檢查完整狀態的某些部分時依賴於從完整節點獲得的資訊。} %
只知道某些 hashmap $h$ 的 $\Hash(h)$ 值（例如，智能合約的持久存儲或全局區塊鏈狀態）可能會從完整節點%
\footnote{「完整節點」是跟踪有關 shardchain 的完整最新狀態的節點。} %
請求不僅僅是值 $x=h[i]=\hget(h)(i)$，而是伴隨著從已知值 $\Hash(h)$ 開始的 Merkle 證明的這樣一個值。然後，在假設 \eqref{eq:hash.coll} 下，輕量節點可以自己檢查 $x$ 確實是 $h[i]$ 的正確值。

在某些情況下，客戶端可能希望獲得值 $y=\Hash(x)=\Hash(h[i])$，例如，如果 $x$ 本身非常大（例如，是一個 hashmap）。然後，可以提供 $(i,y)$ 的 Merkle 證明。如果 $x$ 也是一個 hashmap，那麼可以從完整節點獲得從 $y=\Hash(x)$ 開始的第二個 Merkle 證明，以提供值 $x[j]=h[i][j]$ 或僅其雜湊。

\nxsubpoint \embt(Importance of Merkle proofs for a multi-chain system such as TON.) 請注意，節點通常不能為 TON 環境中存在的所有 shardchains 成為完整節點。它通常只是某些 shardchains 的完整節點——例如，包含其自己的帳戶，它感興趣的智能合約，或者該節點已被指派為其驗證者的那些。對於其他 shardchains，它必須是一個輕量節點——否則存儲、計算和網絡帶寬的要求將是禁止的。這意味著這樣的節點不能直接檢查關於其他 shardchains 狀態的斷言；它必須依賴於從那些 shardchains 的完整節點獲得的 Merkle 證明，除非 \eqref{eq:hash.coll} 失敗（即，找到一個雜湊碰撞），這同樣安全。


\nxsubpoint\label{sp:pec.tvm} \embt(Peculiarities of TON VM.) TON VM 或 TVM (Telegram Virtual Machine)，用於在 masterchain 和 Workchain Zero 中運行智能合約，與受到 EVM (Ethereum Virtual Machine) 啟發的常見設計有很大的不同：它不僅僅與 256 位整數工作，實際上它與（幾乎）任意的「紀錄」、「結構」或「總乘積類型」一起工作，使其更適合執行用高級（尤其是功能性）語言編寫的代碼。實際上，TVM 使用的是帶有標籤的數據類型，這與 Prolog 或 Erlang 的實現中使用的不太相同。

人們首先可以想像，TVM 智能合約的狀態不僅僅是一個 hashmap $\st2^{256}\to\st2^{256}$ 或 $\Hashmap(256,\st2^{256})$，但（作為第一步）是 $\Hashmap(256,X)$，其中 $X$ 是具有幾個構造器的類型，使其除了 256 位整數之外，還能存儲其他數據結構，尤其是其他的 hashmap $\Hashmap(256,X)$。這意味著 TVM（持久或臨時）存儲的一個單元——或者一個在 TVM 智能合約代碼中的變量或數組元素——可能不僅包含一個整數，還包含一個全新的 hashmap。當然，這意味著一個單元不僅僅包含 256 位，還包含，例如，一個 8 位的標籤，描述如何解釋這 256 位。

事實上，值不需要確切地是 256 位的。TVM 使用的值格式由原始字節和對其他結構的引用組成，這些引用以任意順序混合，並在合適的位置插入一些描述字節，以便能夠區分指針和原始數據（例如，字符串或整數）；請參見~\ptref{sp:tvm.cells}。

這種原始值格式可以用來實現任意的總乘積代數類型。在這種情況下，該值首先包含一個原始字節，描述正在使用的「構造器」（從高級語言的角度看），然後是其他「字段」或「構造器參數」，由原始字節和對其他結構的引用組成，具體取決於選擇的構造器（參考~\ptref{sp:TL}）。然而，TVM 並不知道構造器及其參數之間的對應關係；字節和引用的混合由某些描述字節明確描述。\footnote{這兩個描述字節，在任何 TVM 單元中都存在，僅描述參考總數和原始字節總數；參考總是放在所有原始字節之前或之後。}

Merkle 樹雜湊被擴展到任意這樣的結構：要計算這樣一個結構的雜湊，所有的參考都被遞歸地替換為被參考對象的雜湊，然後計算結果字節串（包括描述字節）的雜湊。

通過這種方式，對 hashmaps 的 Merkle 樹雜湊，如~\ptref{sp:merkle.patr.hash}所述，只是用於類型 $\Hashmap(n,X)$ 的兩個構造器的任意（依賴的）代數數據類型的雜湊的特殊情況。\footnote{實際上，$\leaf$ 和 $\node$ 是輔助類型 $\tp{HashmapAux}(n,X)$ 的構造器。類型 $\Hashmap(n,X)$ 有構造器 $\root$ 和 $\emptyroot$，其中 $\root$ 包含類型 $\tp{HashmapAux}(n,X)$ 的值。}

\nxsubpoint \embt(Persistent storage of TON smart contracts.)
TON 智能合約的持久性儲存主要由其「全域變數」組成，這些變數在調用智能合約之間保持不變。因此，它只是一個「產品」、「元組」或「記錄」類型，由相應於每一個全域變數的正確類型的字段組成。如果全域變數太多，由於 TON 單元大小的全局限制，它們不能放入一個 TON 單元。在這種情況下，它們被分割成幾個記錄並組織成一棵樹，基本上變成了「產品的產品」或「產品的產品的產品」類型，而不僅僅是一個產品類型。

\nxsubpoint\label{sp:tvm.cells} \embt(TVM Cells.)  最終，TON VM 在一系列的{\em (TVM) 單元}中保留所有數據。每個單元首先包含兩個描述符字節，表示此單元中有多少原始數據字節（最多 128）以及有多少對其他單元的引用（最多四個）。然後是這些原始數據字節和引用。每個單元只被引用一次，所以我們可能已經在每個單元中包括了對其「父級」的引用（唯一引用此單元的單元）。但是，這個引用不必是明確的。

通過這種方式，TON 智能合約的持久數據儲存單元被組織成一棵樹，\footnote{邏輯上；在~\ptref{sp:bag.of.cells}中描述的「單元包」表示法識別所有重複的單元，當序列化時，將此樹轉換為一個有向無環圖（dag）。} 智能合約描述中保留了對這棵樹的根的引用。如果需要，可以遞歸計算這整個持久存儲的 Merkle 樹哈希，從葉子開始，然後簡單地將一個單元中的所有引用替換為所引用的單元的遞歸計算的哈希，然後計算所得字節串的哈希。

\nxsubpoint\label{sp:gen.merkle.proof} \embt(Generalized Merkle proofs
for values of arbitrary algebraic types.)  由於 TON VM 通過由 (TVM) 單元組成的樹來表示任意代數類型的值，且每個單元都有一個明確定義的（遞歸計算的）Merkle 哈希，實際上依賴於此單元為根的整個子樹，我們可以為任意代數類型的值（的部分）提供「一般化的 Merkle 證明」，旨在證明具有已知 Merkle 哈希的樹的某個子樹具有特定值或具有特定哈希的值。這概括了 \ptref{sp:merkle.proof} 的方法，其中只考慮了 $x[i]=y$ 的 Merkle 證明。

\nxsubpoint\label{sp:tvm.data.shard} \embt(Support for sharding in TON VM data structures.)
我們剛剛概述了如何在不過於複雜的情況下，TON VM 支持高級智能合約語言中的任意（依賴）代數數據類型。然而，對於大型（或全局）智能合約的分片需要在 TON VM 級別上的特殊支援。為此，系統中增加了 hashmap 類型的特殊版本，相當於一個「映射」 $\Account\dashrightarrow X$。這個「映射」可能看起來等同於 $\Hashmap(m,X)$，其中 $\Account=\st2^m$。但是，當一個分片被分成兩個，或兩個分片被合併時，這樣的 hashmaps 會自動被分成兩個，或合併回來，以保留只屬於相應分片的鍵。

\nxsubpoint \embt(Payment for persistent storage.)
TON 區塊鏈的一個值得注意的特點是從智能合約中扣除用於存儲其持久數據的支付（即，增加區塊鏈的總狀態）。它的工作原理如下：

每個區塊都宣布兩種費率，以區塊鏈的主要貨幣（通常是 Gram）來提名：保持一個單元在持久儲存中的價格，以及在持久儲存的某個單元中保持一個原始字節的價格。每個賬戶使用的單元和字節的總數據作為其狀態的一部分存儲，所以通過將這些數字乘以在區塊頭中宣布的兩個費率，我們可以計算從賬戶餘額中扣除的支付，以保持其數據在前一個區塊和當前區塊之間。

然而，對於每個賬戶和每個智能合約在每個區塊中的持久儲存使用的支付並不是每次都收取的；而是在賬戶數據中存儲上次收取此支付的區塊的序列號，並且當對賬戶進行任何操作時（例如，轉移價值或接收並由智能合約處理一條消息），在執行任何進一步的操作之前，從賬戶餘額中扣除自上次這樣的支付以來的所有區塊的儲存使用支付。如果賬戶的餘額在此之後變為負數，則該賬戶將被銷毀。

一個工作鏈可能宣稱每個賬戶的一些原始數據字節是「免費的」（即，不參與持久儲存支付），以使「簡單」的賬戶，只在一兩種加密貨幣中保持它們的餘額，免於這些常數支付。

請注意，如果沒有人給一個賬戶發送任何消息，它的持久儲存支付不會被收集，並且它可以無限期地存在。然而，任何人都可以發送，例如，一條空消息來銷毀這樣的賬戶。可以給發送這樣一條消息的人提供一個小的激勵，從要被銷毀的賬戶的原始餘額中收取部分資金。然而，我們預期，驗證者會免費銷毀這樣的無資金賬戶，僅僅是為了減少全球區塊鏈的狀態大小，並避免保持大量的數據而不得到賠償。

為持久數據的保持收集的支付在 shardchain 或 masterchain 的驗證者之間分配（在後一種情況下按比例分配他們的股份）。

\nxsubpoint\label{sp:loc.glob.smct} \embt(Local and global smart contracts; smart-contract instances.)
一個智能合約通常只存在於一個分片中，根據智能合約的 $\accountid$ 選擇，與「普通」賬戶類似。這通常對大多數應用程序來說都是足夠的。然而，一些「高負載」的智能合約可能希望在某個工作鏈的每個分片鏈中都有一個「實例」。為了實現這一點，它們必須將它們的創建交易傳播到所有的分片鏈中，例如，通過將此交易提交到工作鏈 $w$ 的「根」分片鏈 $(w,\emptyset)$ 中，並支付一大筆佣金。\footnote{一個更昂貴的選擇是在主鏈中發布這樣一個「全球」智能合約。}

這個動作實際上在每個分片中創建了智能合約的實例，具有單獨的餘額。原始地，創建交易中傳輸的餘額只是通過給分片 $(w,s)$ 的實例 $2^{-|s|}$ 的總餘額的部分來分配。當一個分片分裂成兩個子分片時，所有全球智能合約的實例的餘額都分裂為一半；當兩個分片合併時，餘額加在一起。

在某些情況下，分裂/合併全球智能合約的實例可能涉及這些智能合約的特殊方法的（延遲）執行。默認情況下，餘額按照上述方式分裂和合併，一些特殊的「賬戶索引」的 hashmaps 也是自動分裂和合併的（參見~\ptref{sp:tvm.data.shard}）。

\nxsubpoint \embt(Limiting splitting of smart contracts.)
一個全球智能合約可以在其創建時限制其分裂深度 $d$，以使持久存儲費用更具可預測性。這意味著，如果分片鏈 $(w,s)$ 滿足 $|s|\geq d$ 被分裂成兩個，只有兩個新分片鏈中的一個繼承智能合約的實例。這個分片鏈是確定性選擇的：每個全球智能合約都有一個「$\accountid$」，本質上是其創建交易的哈希，並且其實例具有與前 $\leq d$ 位替換為適當值的相同的 $\accountid$，以落入正確的分片。這個 $\accountid$ 選擇了分裂後哪個分片將繼承智能合約實例。

\nxsubpoint\label{sp:account.state} \embt(Account/Smart-contract state.)
我們可以總結以上所有內容，得出賬戶或智能合約的狀態包括以下內容：
\begin{itemize}
\item 區塊鏈的主要貨幣的餘額
\item 區塊鏈其他貨幣的餘額
\item 智能合約的代碼（或其哈希）
\item 智能合約的持久性數據（或其 Merkle 哈希）
\item 持久性存儲單元和原始字節使用數量的統計
\item 上次收取智能合約持久性存儲付款的時間（實際上，是主鏈區塊號）
\item 轉移貨幣和從此賬戶發送消息所需的公鑰（可選；默認等於 $\accountid$ 本身）。在某些情況下，更為複雜的簽名檢查代碼可能位於此處，與比特幣交易輸出類似；然後，$\accountid$ 將等於此代碼的哈希。
\end{itemize}
我們還需要在某處保存以下數據，無論是在賬戶狀態中還是在某個其他的賬戶索引的哈希圖中：
\begin{itemize}
\item 賬戶的輸出消息隊列（參見~\ptref{sp:out.queue}）
\item 最近傳送消息的（哈希的）集合（參見~\ptref{sp:deliver.q}）
\end{itemize}

並不是每個賬戶都真正需要所有這些；例如，只有智能合約需要智能合約代碼，而「簡單」的賬戶則不需要。此外，儘管任何賬戶必須在主要貨幣中有一個非零餘額（例如，基礎工作鏈的主鏈和分片鏈的Grams），但在其他貨幣中可能有零餘額。為了避免保留未使用的數據，定義了一個乘積型別（取決於工作鏈）（在工作鏈的創建期間），它使用不同的標籤字節（例如，TL 構造器；參見~\ptref{sp:TL}）來區分使用的不同「構造器」。最終，賬戶狀態本身作為TVM持久性存儲的單元集合保存。

\mysubsection{分片鏈間的消息}

TON 區塊鏈的一個重要組件是{\em 區塊鏈間的消息系統\/}。這些區塊鏈可以是同一工作鏈的分片鏈，或者是不同工作鏈的分片鏈。

\nxsubpoint \embt(Messages, accounts and transactions: a bird's eye view of the system.)  
{\em 消息\/}從一個賬戶發送到另一個賬戶。每一個{\em 交易\/}包括一個賬戶接收一個消息，根據某些規則改變其狀態，並生成到其他賬戶的多個（可能是一個或零個）新消息。每條消息生成並接收（傳遞）確切一次。

這意味著消息在系統中扮演了基本的角色，與賬戶（智能合約）的角色相當。從無窮分片範式的角度看（參見~\ptref{sp:ISP}），每個賬戶都位於其獨立的「賬戶鏈」中，並且它唯一可以影響某其他賬戶的狀態的方式是通過發送消息。


\nxsubpoint\label{sp:actors} \embt(Accounts as processes or actors; Actor model.)  
可以將賬戶（和智能合約）視為「進程」或「角色」，它們能夠處理進入的消息、改變其內部狀態，並因此生成一些出站消息。這與所謂的{\em Actor model}密切相關，該模型在Erlang之類的語言中使用（但是，Erlang中的角色通常稱為「進程」）。由於新的角色（即，智能合約）也允許由現有角色作為處理入站消息的結果來創建，因此與Actor model的對應基本上是完整的。

\nxsubpoint \embt(Message recipient.)  
任何消息都有其{\em 接收者}，由{\em 目標工作鏈識別符 $w$}（默認情況下與原始分片鏈相同）和{\em 接收賬戶 $\accountid$}進行描述。$\accountid$的確切格式（即，位數）取決於$w$；但是，碎片始終由其第一個（最重要的）64位確定。

\nxsubpoint\label{sp:msg.sender} \embt(Message sender.)  
在大多數情況下，消息都有一個{\em 發送者}，再次由$(w',\accountid')$對進行描述。如果存在，它位於消息接收者和消息值之後。有時，發送者不重要，或者他是區塊鏈之外的某人（即，不是智能合約），在這種情況下，此字段不存在。

值得注意的是，Actor model並不要求消息有一個隱式發送者。相反，消息可能包含對應該發送請求回覆的Actor的引用；它通常與發送者相符。但是，在加密貨幣（Byzantine）環境中，在消息中有一個明確的不可偽造的發送者字段是很有用的。

\nxsubpoint \embt(Message value.)  
消息的另一個重要特性是其附加的{\em 值}，它是源工作鏈和目標工作鏈均支持的一種或多種加密貨幣。消息的值在消息接收者之後的開頭處指示；它實際上是一系列的$(\currencyid,\vr{value})$對。

請注意，「簡單」賬戶之間的「簡單」值轉移只是帶有某些值的空（無操作）消息。另一方面，略為複雜的消息主體可能包含一個簡單的文本或二進制評論（例如，關於付款的目的）。

\nxsubpoint\label{sp:ext.msg} \embt(External messages, or ``messages from nowhere''.)  
有些消息是從「無處」來的，也就是它們並非由位於區塊鏈中的賬戶（無論是否是智能合約）生成的。最典型的例子是當用戶希望從她控制的賬戶轉移一些資金到另一個賬戶時。在這種情況下，用戶發送一個「來自無處的消息」到她自己的賬戶，要求它生成一個發送給接收賬戶的消息，帶有指定的值。如果此消息被正確簽名，她的賬戶就會接收到它並生成所需的出站消息。

實際上，人們可能會認為「簡單」賬戶是帶有預定義代碼的智能合約的特例。這種智能合約只接收一種類型的消息。這種入站消息必須包含作為傳遞（處理）入站消息結果要生成的出站消息列表，以及一個簽名。智能合約檢查簽名，如果它是正確的，則生成所需的消息。

當然，「來自無處的消息」和普通消息之間有所不同，因為「來自無處的消息」不能承載值，所以它們不能為自己的「gas」（即它們的處理）付款。相反，它們在甚至被建議包含在新的shardchain塊中之前，會先嘗試執行一個小的gas限制；如果執行失敗（簽名不正確），則「來自無處的消息」被視為不正確並被丟棄。如果執行在小的gas限制內不失敗，則消息可能被包含在新的shardchain塊中並完全處理，從接收者的賬戶中扣除所消耗的gas（處理能力）的付款。 「來自無處的消息」也可以定義一些交易費，這些費用在gas付款之外從接收者的賬戶中扣除，以重新分配給驗證者。

在這個意義上，「來自無處的消息」或「外部消息」起到了在其他區塊鏈系統中使用的交易候選人的作用（例如，比特幣和以太坊）。

\nxsubpoint \embt(Log messages, or ``messages to nowhere''.)  
同樣，有時可以生成並路由到特定的shardchain的特殊消息，不是為了交付給其收件人，而是為了記錄，以便任何人接收到有關該碎片的更新時都可以輕鬆觀察。這些記錄的消息可以在用戶的控制台中輸出，或觸發某個離鏈伺服器上的某個腳本的執行。在這種意義上，它們代表了「區塊鏈超級電腦」的外部「輸出」，正如「來自無處的消息」代表了「區塊鏈超級電腦」的外部「輸入」。

\nxsubpoint \embt(Interaction with off-chain services and external blockchains.)  
這些外部輸入和輸出消息可以用於與離鏈服務和其他（外部）區塊鏈互動，如比特幣或以太坊。人們可以在TON區塊鏈中創建與比特幣、以太或在以太坊區塊鏈中定義的任何ERC-20代幣相關聯的代幣或加密貨幣，並使用「來自無處的消息」和「去無處的消息」，由位於某些第三方離鏈伺服器上的腳本生成和處理，以實現TON區塊鏈與這些外部區塊鏈之間的必要互動。

\nxsubpoint \embt(Message body.)  {\em message body\/} 基本上就是一系列的位元組，其含義只由接收的工作鏈和/或智能合約決定。對於使用TON VM的區塊鏈，這可以是通過 \texttt{Send()} 操作自動生成的任何 TVM cell 的序列化。這種序列化是通過遞迴地替換 TON VM cell 中的所有參照來獲得的。最終，會出現一串原始位元組，通常在前面加上一個 4 位元組的「消息類型」或「消息建構器」，用於選擇接收智能合約的正確方法。

另一種選擇是使用 TL-序列化對象（參見 \ptref{sp:TL}）作為消息主體。這對於不同工作鏈之間的通信可能尤其有用，其中一個或兩個不一定使用TON VM。

\nxsubpoint \embt(Gas limit and other workchain/VM-specific parameters.)  有時消息需要攜帶有關 gas 限制、gas 價格、交易費用和相似值的資訊，這些值取決於接收的工作鏈，並且只與接收的工作鏈有關，但不一定與原始工作鏈有關。這些參數包含在消息主體中或之前，有時（取決於工作鏈）有特殊的 4 位元組前綴表示它們的存在（可以由 TL-方案定義；參見 \ptref{sp:TL}）。

\nxsubpoint \embt(Creating messages: smart contracts and transactions.)  新消息的來源有兩個。大多數消息是在智能合約執行期間創建的（通過 TON VM中的 \texttt{Send()} 操作），當某個智能合約被調用以處理一個入站消息時。或者，消息可能來自外部，作為「外部消息」或「來自無處的消息」（參見 \ptref{sp:ext.msg}）。%
\footnote{上述只需要在基本工作鏈及其分片鏈上文字上是真實的；其他工作鏈可能提供其他創建消息的方法。}

\nxsubpoint \embt(Delivering messages.)  當一條消息到達包含其目的賬戶的 shardchain 時，\footnote{作為一個退化情況，這個 shardchain 可能與原始的 shardchain 重合——例如，如果我們正在內部工作的工作鏈尚未被分裂。} 它被「傳遞」到其目的地賬戶。接下來會發生什麼取決於工作鏈；從外部觀點看，重要的是這樣的消息從這個 shardchain 永遠不會被進一步轉發。

對於基礎工作鏈的 shardchains，傳送包括將消息值（扣除任何 gas 付款）添加到接收賬戶的餘額，並可能之後調用接收智能合約的一個依賴於消息的方法，如果接收賬戶是一個智能合約。事實上，一個智能合約只有一個進入點用於處理所有傳入消息，並且它必須通過查看它們的前幾個位元組來區分不同類型的消息（例如，包含 TL 建構器的前四個位元組；參見 \ptref{sp:TL}）。

\nxsubpoint \embt(Delivery of a message is a transaction.)  因為消息的交付更改了賬戶或智能合約的狀態，所以它在接收的 shardchain 中是一個特殊的 {\em 交易\/}，並明確地註冊為這樣。本質上，{\em 所有\/} TON 區塊鏈交易都包括將一個入站消息傳遞給其接收賬戶（智能合約），忽略一些次要技術細節。

\nxsubpoint \embt(Messages between instances of the same smart contract.)  回憶一下，一個智能合約可能是 {\em 本地\/} 的（即，像任何普通賬戶一樣駐留在一個 shardchain 中）或 {\em 全局\/} 的（即，在所有的 shards 中都有實例，或至少在所有深度為 $d$ 的 shards 中；參見 \ptref{sp:loc.glob.smct}）。全球智能合約的實例可能需要交換特殊消息以在彼此之間傳遞信息和價值。在這種情況下，（不可偽造的）發件人 $\accountid$ 變得很重要（參見 \ptref{sp:msg.sender}）。

\nxsubpoint \embt(Messages to any instance of a smart contract; wildcard addresses.)  有時候一條消息（例如，客戶端請求）需要被交付給全球智能合約的任何實例，通常是最近的一個（如果有一個駐留在與發件人相同的 shardchain 中，它是明顯的候選人）。做到這一點的一種方法是使用「通配符收件人地址」，其中目標 $\accountid$ 的前 $d$ 位可以取任意值。實際上，人們通常會將這 $d$ 位設置為與發件人的 $\accountid$ 中的相同值。

\nxsubpoint \embt(Input queue is absent.)  由區塊鏈接收的所有消息（通常是 shardchain；有時是 masterchain）——或基本上是駐留在某個 shardchain 內的「賬戶鏈」——都立即被交付（即，由接收賬戶處理）。因此，沒有像這樣的「輸入隊列」。相反，如果由於對區塊總大小和 gas 使用的限制，不是所有目的為特定 shardchain 的消息都可以被處理，一些消息簡單地留在原始 shardchains 的輸出隊列中積累。

\nxsubpoint\label{sp:out.queue} \embt(Output queues.)  從無限分割範例（Infinite Sharding Paradigm）的角度看 (cf.~\ptref{sp:ISP})，每個賬戶鏈（即，每個賬戶）都有其自己的輸出隊列，由它生成但尚未傳遞給其接收者的所有消息組成。當然，賬戶鏈只有一個虛擬的存在；它們被分組到shardchains中，而一個shardchain有一個輸出「隊列」，由屬於該shardchain的所有賬戶的輸出隊列的聯合組成。

這個shardchain輸出「隊列」只對其成員消息施加部分順序。即，在先前的區塊中生成的消息必須在隨後的區塊中生成的任何消息之前被傳遞，並且由相同賬戶生成且具有相同目的地的任何消息必須按照它們的生成順序傳遞。

\nxsubpoint\label{sp:intershard.msgs} \embt(Reliable and fast inter-chain messaging.)  對於像TON這樣的可擴展多區塊鏈項目，能夠在不同的shardchains之間轉發和傳遞消息是至關重要的 (cf.~\ptref{sp:msg.IHR})，即使系統中有數百萬個。消息應該被{\em 可靠地\/}（即，消息不應該丟失或傳遞多次）和{\em 快速地}傳遞。TON區塊鏈通過使用兩種「消息路由」機制的組合來實現這一目標。

\nxsubpoint\label{sp:hypercube} \embt(Hypercube routing: ``slow path''
for messages with assured delivery.)  TON Blockchain 使用「超立方體路由」作為一種緩慢，但安全可靠的方法，從一個 shardchain 傳遞消息到另一個 shardchain，如有必要，使用幾個中間的 shardchain 進行轉發。否則，任何給定的 shardchain 的驗證者都需要追踪所有其他 shardchain 的狀態（輸出隊列），隨著 shardchain 總數的增加，這將需要過多的計算能力和網絡帶寬，從而限制了系統的可擴展性。因此，無法直接從任何 shard 傳遞消息到其他每一個 shard。相反，每個 shard 只與其 $(w,s)$ shard 標識符中確切一個十六進制數位不同的 shard「連接」(cf.~\ptref{sp:shard.ident})。這樣，所有的 shardchain 構成一個「超立方體」圖，消息沿著這個超立方體的邊緣移動。

如果消息被發送到與當前的 shard 不同的 shard，當前的 shard 標識符的十六進制數字（確定地選擇）被替換為目標 shard 的相應數字，並使用所得的標識符作為轉發消息的近端目標。\footnote{這不一定是用於計算超立方體路由的下一跳的算法的最終版本。特別是，十六進制數字可能會被 $r$-位群組替換，其中 $r$ 是一個可配置的參數，不一定等於四。}

超立方體路由的主要優點是區塊有效性條件意味著創建 shardchain 的區塊的驗證者必須收集和處理「鄰近」shardchain 的輸出隊列中的消息，否則將失去他們的賭注。這樣，任何消息都可以預期最終會達到其最終目的地；消息不能在過程中丟失或傳遞兩次。

請注意，超立方體路由帶來了一些額外的延遲和開銷，因為必須通過幾個中間的 shardchain 轉發消息。然而，這些中間的 shardchain 的數量增長非常緩慢，作為 shardchain 總數 $N$ 的對數 $\log N$（更確切地說，$\lceil\log_{16}N\rceil-1$）。例如，如果 $N\approx250$，最多只有一個中間的 hop；對於 $N\approx4000$ 的 shardchain，最多有兩個。四個中間的 hop，我們可以支持多達一百萬的 shardchain。我們認為為系統的基本無限的可擴展性支付的這個代價是非常小的。事實上，甚至不必支付這個價格：

\nxsubpoint\label{sp:instant.hypercube} \embt(Instant Hypercube
Routing: ``fast path'' for messages.) TON Blockchain 的一個新功能是它引入了一個「快速路徑」，從一個 shardchain 轉發消息到任何其他 shardchain，在大多數情況下都可以完全繞過 \ptref{sp:hypercube} 中的「慢速」超立方體路由，並在最終目的地 shardchain 的下一個區塊中傳遞消息。

該思路如下。在「慢速」的超立方體路由中，消息在超立方體的邊緣上（在網絡中）旅行，但在每個中間頂點都會被延遲（大約五秒鐘），以將其提交到相應的 shardchain，然後再繼續其旅程。

為了避免不必要的延遲，可以沿著超立方體的邊緣轉發消息和一個適當的 Merkle 證明，而不用等待將其提交到中間的 shardchains。實際上，網絡消息應該從原始 shard 的「任務組」的驗證者（cf.~\ptref{sp:val.task.grp}）轉發到目的地 shard 的「任務組」的指定區塊生產者（cf.~\ptref{sp:rot.gen.prio}）；這可能可以直接完成，而不沿著超立方體的邊緣。當這條帶有 Merkle 證明的消息到達目的地 shardchain 的驗證者（更確切地說，是 collators；cf.~\ptref{sp:collators}）時，他們可以立即將其提交到一個新的區塊，而不用等待消息完成沿著「慢路徑」的旅程。然後將交付確認以及一個適當的 Merkle 證明沿著超立方體的邊緣發回，並且可以通過提交一個特殊的交易來停止消息沿著「慢路徑」的旅程。

請注意，這種「即時交付」機制並未取代在~\ptref{sp:hypercube} 中描述的「慢速」但是不會失敗的機制。仍然需要「慢路徑」，因為驗證者不能因失去或簡單地決定不將「快速路徑」消息提交到他們區塊鏈的新區塊而受到懲罰。\footnote{然而，驗證者有一定的動機盡快這樣做，因為他們將能夠收集與消息相關的所有轉發費用，這些費用尚未在慢路徑中被消耗。}

因此，兩種消息轉發方法是平行運行的，只有在「快速」機制的成功證明被提交到一個中間的 shardchain 時，「慢速」機制才會被中止。%\footnote{實際上，可以暫時或永久禁用「即時交付」機制，系統將繼續運行，但速度會慢一些。}

\nxsubpoint\label{sp:collect.input.msg} \embt(Collecting input
messages from output queues of neighboring shardchains.) 當為 shardchain 提議一個新的區塊時，鄰近（在\ptref{sp:hypercube}的路由超立方體意義上）的 shardchains 的一些輸出消息被包含在新的區塊中作為「輸入」消息，並立即被傳遞（即，處理）。關於這些鄰居的輸出消息必須以哪種順序進行處理，有一定的規則。基本上，一個「較舊」的消息（來自參照較舊的主鏈區塊的 shardchain 區塊）必須在任何「較新」的消息之前傳遞；對於來自同一鄰近 shardchain 的消息，必須遵守\ptref{sp:out.queue}中描述的輸出隊列的部分順序。

\nxsubpoint\label{sp:out.q.del} \embt(Deleting messages from output queues.)  一旦觀察到輸出隊列中的訊息已被相鄰的分片鏈交付，則通過特殊交易明確地從輸出隊列中刪除它。

\nxsubpoint\label{sp:deliver.q} \embt(Preventing double delivery of messages.) 為了防止從相鄰的分片鏈的輸出隊列中雙重交付訊息，每個分片鏈（更確切地說，其中的每個賬戶鏈）作為其狀態的一部分保持最近交付的訊息的集合（或僅其哈希值）。當觀察到已交付的訊息從其源相鄰分片鏈（參見\ptref{sp:out.q.del}）的輸出隊列中被刪除時，它也從最近交付的訊息的集合中被刪除。

\nxsubpoint \embt(Forwarding messages intended for other shardchains.) 通過 Hypercube 路由（參見\ptref{sp:hypercube}）有時出站訊息不是交付給包含預期收件人的分片鏈，而是交付給位於到目的地的超立方體路徑上的相鄰分片鏈。在這種情況下，"交付"包括將入站訊息移動到出站隊列。這在塊中明確地反映為一個特殊的{\em 轉發交易}，其中包含該訊息。本質上，這看起來就像該訊息已被分片鏈內的某人接收，並且生成了一個相同的訊息作為結果。

\nxsubpoint \embt(Payment for forwarding and keeping a message.) 轉發交易實際上消耗了一些瓦斯（取決於被轉發的訊息的大小），因此從被轉發的訊息的值中扣除了一筆瓦斯支付，代表此分片鏈的驗證器。此轉發支付通常遠小於當訊息最終交付給其收件人時所確定的瓦斯支付，即使該訊息由於超立方體路由而被轉發了多次。此外，只要某個分片鏈的輸出隊列中保持有訊息，它就是分片鏈的全局狀態的一部分，因此特殊交易也可能收取長時間保持全局數據的支付。

\nxsubpoint \embt(Messages to and from the masterchain.) 訊息可以直接從任何分片鏈發送到主鏈，反之亦然。但是，發送訊息到主鏈以及在主鏈中處理訊息的瓦斯價格相當高，因此只有在真正需要時才會使用此功能——例如，由驗證器來存入他們的賭注。在某些情況下，可能會定義發送到主鏈的訊息的最小存款（附加值），只有當接收方認為該訊息是“有效”的時候才會退還。

訊息不能自動通過主鏈路由。帶有 $\workchainid\neq-1$ 的訊息（其中 $-1$ 是表示主鏈的特殊 $\workchainid$）不能交付給主鏈。

原則上，人們可以在主鏈內部創建一個訊息轉發智能合約，但使用它的價格將是禁止性的。

\nxsubpoint \embt(Messages between accounts in the same shardchain.)
在某些情況下，某個分片鏈中的賬戶生成的訊息，目標是同一分片鏈中的另一賬戶。例如，這發生在新的工作鏈中，因為負載是可管理的，所以尚未分裂成多個分片鏈。

這樣的訊息可能會在分片鏈的輸出隊列中累積，然後在後續的區塊中作為入站訊息進行處理（為此目的，任何分片都被視為其本身的鄰居）。然而，在大多數情況下，有可能在起源區塊本身內交付這些訊息。

為了實現這一點，對包含在分片鏈區塊中的所有交易施加了部分排序，並尊重此部分順序處理交易（每個交易都包含將訊息交付給某個賬戶）。特別是，允許一個交易處理與此部分順序相對的前一個交易的某個輸出訊息。

在這種情況下，訊息主體不會被複製兩次。相反，起源交易和處理交易都參照訊息的共享副本。

\mysubsection{Global Shardchain State. ``Bag of Cells'' Philosophy.}

現在我們準備描述TON區塊鏈的全局狀態，或者至少是基本工作鏈的分片鏈。

我們從“高級”或“邏輯”描述開始，即全局狀態是代數類型 $\tp{ShardchainState}$ 的值。

\nxsubpoint\label{sp:shard.state} \embt(Shardchain state as a
collection of account-chain states.)  根據無限分片模型（參見\ptref{sp:ISP}），任何分片鏈只是虛擬“賬戶鏈”的（臨時）集合，每個賬戶鏈只包含一個賬戶。這意味著，本質上，全局分片鏈狀態必須是一個哈希映射
\begin{equation}\label{eq:simple.shard.st}
  \tp{ShardchainState}:=(\Account\dashrightarrow\tp{AccountState})
\end{equation}
其中所有作為此哈希映射的指數出現的 $\accountid$ 必須以前綴 $s$ 開始，如果我們正在討論分片 $(w,s)$ 的狀態（參見\ptref{sp:shard.ident}）。

實際上，我們可能希望將 $\tp{AccountState}$ 分成幾個部分（例如，保持賬戶輸出訊息隊列的獨立，以簡化相鄰分片鏈的檢查），並在 $\tp{ShardchainState}$ 內部擁有幾個哈希映射 $(\Account\dashrightarrow\tp{AccountStatePart}_i)$。我們還可能向 $\tp{ShardchainState}$ 添加少量“全局”或“整體”參數，（例如，屬於此分片的所有賬戶的總餘額，或所有輸出隊列中的訊息總數）。

然而，\eqref{eq:simple.shard.st} 是分片鏈全局狀態的一個很好的初步近似值，至少從“邏輯”（“高級”）的角度來看。可以使用TL方案（參見\ptref{sp:TL}）的幫助來進行代數類型 $\tp{AccountState}$ 和 $\tp{ShardchainState}$ 的正式描述，該描述將在其他地方提供。

\nxsubpoint\label{sp:split.merge.state} \embt(Splitting and merging shardchain states.)
請注意，無限分片模型描述的分片鏈狀態 \eqref{eq:simple.shard.st} 顯示了當分片被分裂或合併時，該狀態應如何被處理。實際上，這些狀態變換變得是非常簡單的哈希映射操作。

\nxsubpoint \embt(Account-chain state.)
(虛擬的)賬戶鏈狀態只是一個賬戶的狀態，由類型 $\tp{AccountState}$ 描述。通常它具有在~\ptref{sp:account.state} 中列出的所有或某些字段，具體取決於使用的構造器。

\nxsubpoint \embt(Global workchain state.)
與 \eqref{eq:simple.shard.st} 類似，我們可以使用相同的公式定義全局的 {\em workchain\/} 狀態，但 $\accountid$'s 可以取任何值，不僅僅是屬於一個分片的值。在這種情況下，也適用於~\ptref{sp:shard.state} 中所做的類似備註：我們可能想要將此哈希映射分裂成幾個哈希映射，我們可能想要添加一些“整體”的參數，如總餘額。

本質上，全局的工作鏈狀態 {\em must\/} 被給予與分片鏈狀態相同的類型 $\tp{ShardchainState}$，因為如果這個工作鏈的所有現有分片鏈突然合併成一個，我們會得到的就是這個分片鏈狀態。

\nxsubpoint\label{sp:bag.of.cells} \embt(Low-level perspective: ``bag of cells''.)  
存在一個「低階」描述關於賬戶鏈或shardchain狀態，這與上述的「高階」描述是互補的。此描述相當重要，因為它事實上是非常普遍的，為代表、儲存、序列化和通過網路轉移TON Blockchain（包括blocks、shardchain states、smart-contract storage、Merkle proofs等）所用的幾乎所有資料提供了一個共同的基礎。同時，一旦這樣的普遍「低階」描述被理解和實施，我們就可以集中注意力僅考慮「高階」。

回想一下，TVM用一棵「TVM cells」樹，或簡稱為「cells」（參見~\ptref{sp:tvm.cells}和~\ptref{sp:TL}）來表示任意代數類型的值（例如，~\eqref{eq:simple.shard.st}中的$\tp{ShardchainState}$）。

每個這樣的cell都由兩個「descriptor bytes」組成，定義某些標誌和值$0\leq b\leq 128$，表示原始bytes的數量，以及$0\leq c\leq 4$，這是指向其他cells的引用數量。然後是$b$個原始bytes和$c$個cell引用。\footnote{可以顯示，如果經常需要儲存在cell樹中的所有資料的Merkle proofs，則應該使用$b+ch\approx 2(h+r)$的cells來最小化平均Merkle proof大小，其中$h=32$是hash在bytes中的大小，而$r\approx4$是cell引用的「byte大小」。換句話說，一個cell應該包含兩個引用和一些原始bytes，或一個引用和大約36原始bytes，或完全沒有引用但是有72原始bytes。}

cell引用的確切格式取決於它的實現，以及cell是否位於RAM、磁碟、網絡封包、block等。一個有用的抽象模型是想像所有cells都存放在內容可寄存的記憶體中，cell的地址等於其($\Sha$) hash。回想一下，cell的(Merkle) hash正是通過將其子cell的引用替換為它們（遞迴計算的）hashes並hash生成的byte string來計算的。

這樣，如果我們使用cell hashes來引用cells（例如，在其他cells的描述中），系統稍微簡化，且cell的hash開始與代表它的byte string的hash相符。

現在我們看到，{\em 任何TVM可以表示的對象，包括全局shardchain狀態，都可以表示為一個「bag of cells」} ——即，{\em 一個cells的集合以及指向其中之一的「root」引用}（例如，通過hash）。請注意，重複的cells從此描述中被刪除了（「bag of cells」是cells的集合，而不是多重集），所以抽象的樹表示實際上可能變成了一個有向無環圖(dag)表示。


人甚至可以在硬碟上使用$B$-tree或$B+$-tree來保存這個狀態，包含所有相關的cells（也許還有一些附加數據，如子樹高度或引用計數器），並由cell hash進行索引。但是，這個想法的簡單實現會導致一個智能合約的狀態被散佈在磁盤文件的遠處，這是我們想要避免的。\footnote{更好的實現方法是，如果smart contract的狀態很小，就將其保存為序列化的字符串，如果很大，則保存在另一個$B$-tree中；然後代表blockchain狀態的頂層結構將是一個$B$-tree，其葉子節點被允許包含對其他$B$-tree的引用。}

現在我們將詳細解釋TON Blockchain使用的幾乎所有對象如何可以表示為「bag of cells」，從而展示這種方法的普遍性。

\nxsubpoint \embt(Shardchain block as a ``bag of cells''.)  
Shardchain block本身也可以用代數類型來描述，並存儲為「bag of cells」。然後可以通過簡單地連接表示「bag of cells」中每個cell的byte strings（以任意順序）來獲得block的簡單二進制表示。這種表示可以進一步改進和優化，例如，在block的開頭提供所有cells的偏移量列表，並在可能的情況下用32位索引替換對其他cells的hash引用。然而，人們應該認識到block本質上是一個「bag of cells」，所有其他技術細節只是次要的優化和實現問題。

\nxsubpoint\label{sp:obj.update} \embt(Update to an object as a ``bag of cells''.)  
想像我們有一個以「bag of cells」表示的對象的舊版本，我們想要表示同一對象的新版本，這個新版本應該與前一個不太不同。一個方法是簡單地將新狀態表示為具有自己root的另一個「bag of cells」，{\em 並從中刪除所有在舊版本中出現的cells}。剩下的「bag of cells」基本上是對象的{\em update\/}。每個擁有此對象的舊版本和update的人都可以計算新版本，只需合併兩個bag of cells，並刪除舊的root（減少其引用計數，並在引用計數變為零時釋放cell）。

\nxsubpoint \embt(Updates to the state of an account.)
特別是，對賬戶的狀態、shardchain的全局狀態或任何hashmap的更新都可以使用在~\ptref{sp:obj.update}中描述的想法進行表示。這意味著當我們接收到一個新的shardchain block（即是「bag of cells」）時，我們不只是單獨解釋這個「bag of cells」，而是首先將其與代表shardchain先前狀態的「bag of cells」結合。從這個意義上說，每個block可能都「包含」blockchain的整體狀態。

\nxsubpoint \embt(Updates to a block.)
回憶一下，block本身就是一個「bag of cells」，所以，如果需要編輯block，則可以類似地將「block update」定義為「bag of cells」，並在存在該block的先前版本的「bag of cells」的情境下進行解釋。這大致上是在~\ptref{sp:inv.sh.blk.corr}中討論的「垂直blocks」背後的想法。

\nxsubpoint\label{sp:merkle.as.BoC} \embt(Merkle proof as a ``bag of cells''.)
注意，一個（廣義的）Merkle證明——例如，從已知的$\Hash(x)=h$開始聲稱$x[i]=y$（參見~\ptref{sp:merkle.proof}和~\ptref{sp:gen.merkle.proof}）——也可以表示為「bag of cells」。具體來說，只需要提供一組cells子集，對應從$x:\Hashmap(n,X)$的根到其所需的具有索引$i:\st2^n$和值$y:X$的葉子的路徑。在此證明中，不位於此路徑上的這些cells的子項的引用將保持「未解決」，由cell hashes表示。還可以同時提供，例如，$x[i]=y$和$x[i']=y'$的Merkle證明，通過在「bag of cells」中包括位於從$x$的根到對應於索引$i$和~$i'$的葉子的兩條路徑的聯合上的cells。

\nxsubpoint\label{sp:merkle.query.resp} \embt(Merkle proofs as query responses from full nodes.)
實質上，擁有shardchain（或account-chain）狀態完整副本的完整節點可以在被輕節點（例如，運行TON Blockchain客戶端輕版本的網絡節點）請求時提供Merkle證明，使接收者能夠僅使用此Merkle證明中提供的cells執行一些簡單的查詢，而不需要外部幫助。輕節點可以將其查詢以序列化格式發送給完整節點，並接收正確的答案和Merkle證明——或僅僅是Merkle證明，因為請求者應該能夠僅使用Merkle證明中包含的cells來計算答案。這個Merkle證明將僅由一個「bag of cells」組成，只包含屬於shardchain狀態的那些cells，在執行輕節點的查詢時由完整節點訪問。此方法尤其可用於執行智能合約的「get queries」（參見~\ptref{sp:tent.exec.get}）。

\nxsubpoint\label{sp:aug.upd} \embt(Augmented update, or state update with Merkle proof of validity.)
回想一下（參見~\ptref{sp:obj.update}），我們可以透過「update」來描述從舊值$x:X$到新值$x':X$的物件狀態變化，這只是一個「bag of cells」，其中包含那些位於表示新值$x'$的子樹中的cells，但不包含位於表示舊值$x$的子樹中的cells，因為假設接收者擁有舊值$x$及其所有的cells複本。

然而，如果接收者並沒有$x$的完整複本，而只知道其（Merkle）hash $h=\Hash(x)$，它將無法檢查update的有效性（即update中的所有「懸空」cell引用確實指向存在於$x$的樹中的cells）。我們希望能夠具有可驗證性的update，並加上對舊狀態中所有引用cells存在的Merkle證明。這樣，只知道$h=\Hash(x)$的任何人都能夠檢查update的有效性，並自行計算新的$h'=\Hash(x')$。

因為我們的Merkle證明本身就是「bags of cells」（參見~\ptref{sp:merkle.as.BoC}），可以將這樣的「增強update」構造為一個「bag of cells」，其中包含$x$的舊根、其某些子孫以及從$x$的根到它們的路徑，以及$x'$的新根和其所有不屬於$x$的子孫。

\nxsubpoint \embt(Account state updates in a shardchain block.)
特別是，在shardchain block中的賬戶狀態更新應按照~\ptref{sp:aug.upd}中討論的方式進行增強。否則，某人可能提交一個包含在舊狀態中不存在的cell引用的無效狀態更新的block；證明此block的無效性將是困難的（挑戰者如何證明cell {\em 不是\/}先前狀態的一部分？）。

現在，如果包含在block中的所有狀態更新都是增強的，它們的有效性可以輕鬆檢查，並且其無效性也可以輕鬆顯示為違反（廣義）Merkle hashes的遞迴定義特性。

\nxsubpoint\label{sp:everything.is.BoC} \embt(``Everything is a bag of cells'' philosophy.)
前面的討論表明，我們在TON Blockchain或網絡中需要存儲或傳輸的所有內容都可以表示為「bag of cells」。這是TON Blockchain設計哲學的重要部分。一旦解釋了「bag of cells」方法並定義了一些「bags of cells」的「低階」序列化，就可以在抽象（依賴性）代數數據類型的高層次上定義所有內容（如block格式、shardchain和賬戶狀態等）。

「一切都是bag of cells」哲學的統一效果大大簡化了看似不相關的服務的實現；有關涉及付款通道的示例，請參見~\ptref{sp:ton.smart.pc.supp}。

\nxsubpoint \embt(Block ``headers'' for TON blockchains.)  通常，blockchain中的block會從一個小型的header開始，其中包含前一個block的hash、創建時間、block中所有交易的樹的Merkle hash等。然後，block的hash被定義為這個小型block header的hash。因為block header最終取決於block中包含的所有數據，所以無法在不改變其hash的情況下修改block。

在TON blockchains的block使用的``bag of cells''方法中，沒有指定的block header。相反，block hash被定義為block的根cell的(Merkle) hash。因此，block的頂部（根）cell可能被視為此block的小型``header''。

但是，根cell可能不包含通常期望從這樣的header中獲得的所有數據。本質上，人們希望header包含$\Block$數據類型中定義的某些字段。通常，這些字段將包含在幾個cell中，包括根cell。這些cell一起構成了有關字段值的``Merkle proof''。人們可能會堅持在block中的任何其他cell之前，在一開始就包含這些``header cells''。然後，只需要下載block序列化的前幾個字節，就可以獲得所有的``header cells''，並了解所有期望的字段。

\mysubsection{創建和驗證新的Blocks}\label{sect:validators}

TON Blockchain最終由shardchain和masterchain blocks組成。為了系統順利且正確地運作，必須創建、驗證這些blocks，並通過網絡將其傳播到所有相關方。


\nxsubpoint\label{sp:validators} \embt(Validators.)  新的blocks由特定的節點創建和驗證，這些節點被稱為{\em validators}。實質上，任何希望成為validator的節點都可以成為validator，前提是它可以在masterchain中存入足夠多的抵押金（以TON幣，即Grams；參考\ Appendix~\ptref{app:coins}）。Validators為良好的工作獲得一些「獎勵」，即所有交易、存儲和燃氣費用，以及一些新鑄造的幣，這反映了整個社群對validators的「感激」，因為它們使TON Blockchain持續運作。這筆收入按照所有參與validators的抵押金比例分配。

然而，成為validator是一項重大的責任。如果validator簽署了一個無效的block，它可能會失去部分或全部的抵押金，並且可能會暫時或永久地被排除在validators之外。如果validator不參與創建block，它不會收到與該block相關的獎勵部分。如果validator長時間不創建新的blocks，它可能會失去部分的抵押金，並被暫停或永久排除在validators之外。

這一切都意味著validator不是輕而易舉地獲得金錢。事實上，它必須追踪所有或某些shardchains的狀態（每個validator負責驗證和創建某一子集shardchains中的新blocks），執行這些shardchains中的智能合約所請求的所有計算，接收其他shardchains的更新等等。這項活動需要大量的磁碟空間、計算能力和網絡帶寬。

\nxsubpoint \embt(Validators instead of miners.)  請記住，TON Blockchain使用的是Proof-of-Stake方法，而不是Bitcoin、當前版本的Ethereum和大多數其他加密貨幣採用的Proof-of-Work方法。這意味著人們不能通過提供某些工作證明（計算大量其他無用的hashes）來「挖掘」新的block，並因此獲得一些新的幣。相反，人們必須成為validator，並花費自己的計算資源來存儲和處理TON Blockchain的請求和數據。簡而言之，{\em 要挖新幣，必須成為validator。}就這一點而言，{\em validators就是新的miners。}

但是，除了成為validator之外，還有一些其他方式可以賺取幣。

\nxsubpoint\label{sp:nominators} \embt(Nominators and ``mining pools''.)  要成為validator，通常需要購買和安裝幾臺高性能的伺服器，並為它們提供良好的互聯網連接。這不像當前挖掘比特幣所需的ASIC設備那麼昂貴。但你絕對不能在家用電腦上挖新的TON幣，更不用說智能手機了。

在比特幣、以太坊和其他Proof-of-Work加密貨幣挖掘社區中，有一個名為{\em mining pools}的概念，其中許多節點因計算能力不足而無法自行挖掘新的blocks，所以他們合併力量並在之後分享獎勵。

Proof-of-Stake世界中的相應概念是{\em nominator}。實質上，這是一個將其資金借給validator以增加其抵押金的節點；然後validator將其獎勵的相應部分（或之前同意的一部分，例如50\%）分配給nominator。

通過這種方式，nominator也可以參與「挖掘」並獲得與其存款金額成正比的一些獎勵。它只獲得validator獎勵的一部分，因為它只提供了「資本」，但不需要購買計算能力、存儲和網絡帶寬。

但是，如果validator因無效行為而失去其抵押金，nominator也會失去其抵押金的部分。在這種意義上，nominator {\em 分擔風險}。它必須明智地選擇其nominated validator，否則可能會損失資金。在這種意義上，nominator進行加權決策並使用其資金「投票」支持某些validator。

另一方面，這種提名或借貸系統使人們能夠成為validator，而無需首先投入大量金錢購買Grams（TON幣）。換句話說，它防止持有大量Grams的人壟斷validator的供應。

\nxsubpoint\label{sp:fish} \embt(Fishermen: obtaining money by pointing out others' mistakes.)  另一種不成為validator而獲得一些獎勵的方式是成為一名{\em fisherman}。實質上，任何節點都可以通過在masterchain中存入少量資金成為fisherman。然後，它可以使用特殊的masterchain交易來發布某些由validators之前簽名和發布的（通常是shardchain）blocks的（Merkle）無效性證明。如果其他validators同意這個無效性證明，則違規的validators將被懲罰（失去其抵押金的一部分），fisherman則獲得一些獎勵（從違規的validators中沒收的幣的一部分）。之後，如~\ptref{sp:inv.sh.blk.corr}中所述，必須更正無效的（shardchain）block。更正無效的masterchain blocks可能需要在先前提交的masterchain blocks之上創建「垂直」blocks（參見~\ptref{sp:inv.sh.blk.corr}）；無需創建masterchain的分叉。

通常，一個fisherman需要成為至少某些shardchains的完整節點，並花費一些計算資源來運行至少一些智能合約的代碼。雖然fisherman不需要像validator那麼多的計算能力，但我們認為，一個天生的fisherman是一個準備處理新blocks，但尚未被選為validator的候選者（例如，由於未能存入足夠大的抵押金）。

\nxsubpoint\label{sp:collators} \embt(Collators: obtaining money by
suggesting new blocks to validators.)  另一種不成為validator但可以獲得一些獎勵的方法是成為一個{\em collator}。這是一個節點，它為validator準備並建議新的shardchain block候選者，並使用從此shardchain的狀態和其他(通常是相鄰的) shardchains中取得的資料進行補充（collated），伴隨適當的Merkle證明。當需要從鄰近的shardchains轉發一些消息時，這是必要的。然後，validator可以輕鬆檢查所提議的block候選者的有效性，無需下載此或其他shardchains的完整狀態。

由於validator需要提交新的(collated) block候選者以獲得一些（``mining''）獎勵，因此有理由支付一部分獎勵給願意提供適當block候選者的collator。這樣，validator可以避免觀察鄰近shardchains的狀態，將其外包給collator。

然而，我們預期在系統的初始部署階段不會有單獨指定的collators，因為所有validators都將能夠為自己充當collators。

\nxsubpoint \embt(Collators or validators: obtaining money for
including user transactions.)  使用者可以向一些collators或validators打開micropayment通道，並支付少量的幣以換取在shardchain中包括他們的交易。

\nxsubpoint\label{sp:global.valid} \embt(Global validator set
election.)  每月一次（實際上是每$2^{19}$個masterchain blocks）選舉``global''的validators集合。此集合在一個月前確定並被全球知悉。

要成為validator，節點必須將一些TON幣（Grams）轉入masterchain，然後將它們發送到特定的智能合約作為其建議的抵押金$s$。與抵押金一起發送的另一個參數是$l\geq 1$，這是此節點願意接受的相對於最小可能值的最大驗證負載。還有一個$l$的全球上限（另一個可配置參數）$L$，例如說是10。

然後，這個智能合約選舉global的validator集合，只需選擇最大的建議抵押金的前$T$個候選者並公布其身份。最初，validators的總數是$T=100$；隨著負載的增加，我們預期它將增長到1000。它是一個可配置參數（參見~\ptref{sp:config.param}）。

每個validator的實際抵押金如下計算：如果前$T$個提議的抵押金是$s_1\geq s_2\geq\cdots\geq s_T$，那麼第$i$個validator的實際抵押金設定為$s'_i:=\min(s_i,l_i\cdot s_T)$。這樣，$s'_i/s'_T\leq l_i$，所以第$i$個validator不會獲得超過$l_i\leq L$倍最弱validator的負載（因為負載最終與抵押金成正比）。

然後，當選的validators可以撤回他們未使用的抵押金部分，$s_i-s'_i$。不成功的validator候選人可以撤回他們所有的建議抵押金。

每個validator發布其{\em public signing key}，並不一定等於抵押金來源的帳戶的公鑰。\footnote{對於每次validator選舉，生成和使用新的密鑰對是有意義的。}

validators的抵押金被凍結，直到他們被選舉的時期結束，再加上一個月，以防新的爭議出現（例如，發現一個由這些validators簽名的無效block）。之後，將返回抵押金，以及在此期間鑄造的validator的幣份額和處理的交易的費用。


\nxsubpoint\label{sp:val.task.grp} \embt(Election of validator ``task
groups''.)  整體的全域驗證者集合（其中每個驗證者都被視為具有與其股份相等的多重性 - 否則驗證者可能會被誘使承擔多個身份並在它們之間劃分其股份）只用於驗證新的 masterchain 區塊。 shardchain 的區塊只由特定選擇的驗證者子集驗證，這些驗證者是從在\ptref{sp:global.valid}中描述的選擇的全域驗證者集合中選擇的。

這些驗證者「子集」或「任務組」，為每個 shard 定義，每小時（實際上，每 $2^{10}$ 個 masterchain 區塊）旋轉一次，它們在一小時前就已知，因此每個驗證者都知道它將需要驗證哪些 shards，並可以為此做準備（例如，通過下載丟失的 shardchain 數據）。

用於為每個 shard $(w,s)$ 選擇驗證者任務組的算法是確定性偽隨機的。它使用驗證者嵌入到每個 masterchain 區塊中的偽隨機數（通過使用閾值簽名生成的共識生成）來創建一個隨機種子，然後例如為每個驗證者計算 $\Hash(\code(w).\code(s).\vr{validator\_id}.\vr{rand\_seed})$。然後按此 hash 的值對驗證者進行排序，並選擇第一個驗證者，以便至少具有總驗證者股份的 $20/T$ 並且由至少5個驗證者組成。

這種選擇可以由特殊的智能合約完成。在這種情況下，選擇算法將可以輕鬆升級，無需通過\ptref{sp:config.param}中提到的投票機制進行硬分叉。迄今為止提到的所有其他「常數」（例如 $2^{19}$、$2^{10}$、$T$、20 和 5）也都是可配置的參數。

\nxsubpoint\label{sp:rot.gen.prio} \embt(Rotating priority order on
each task group.)  在 shard 任務組的成員上有一個特定的「優先順序」，取決於先前 masterchain 區塊的 hash 和 (shardchain) 區塊序列號。此順序是通過生成並排序上述的某些 hash 來確定的。

當需要生成新的 shardchain 區塊時，通常選擇用於創建此區塊的 shard 任務組驗證者是根據此旋轉「優先順序」的第一名。如果它未能創建該區塊，第二或第三個驗證者也可能這樣做。基本上，他們都可以建議他們的區塊候選者，但是由具有最高優先權的驗證者建議的候選者應該作為 Byzantine Fault Tolerant (BFT) 共識協議的結果獲勝。


\nxsubpoint\label{sp:sh.blk.cand.prop} \embt(Propagation of shardchain
block candidates.)  因為shardchain任務組的成員資格提前一小時就已知，它們的成員可以利用這段時間建立一個專用的「shard 驗證者多播覆蓋網絡」，使用TON Network的一般機制 (cf.~\ptref{sect:overlay})。當需要生成一個新的shardchain區塊時—通常在最近的masterchain區塊被傳播後的一兩秒鐘—每個人都知道誰有最高的優先權生成下一個區塊 (cf.~\ptref{sp:rot.gen.prio})。這個驗證者將創建一個新的整合的區塊候選者，無論是自己還是在整合者的幫助下 (cf.~\ptref{sp:collators})。驗證者必須檢查（驗證）此區塊候選者（尤其是如果它是由某個整合者準備的）並用其（驗證者）私鑰簽名。然後，使用預先安排的多播覆蓋網絡將區塊候選者傳播到任務組的其餘部分 (該任務組根據\ptref{sect:overlay}中的解釋創建自己的私有覆蓋網絡，然後使用\ptref{sp:streaming.multicast}中描述的串流多播協議的版本來傳播區塊候選者)。

真正的BFT方式是使用拜占庭多播協議，例如Honey Badger BFT中使用的協議~\cite{HoneyBadger}：通過一個$(N,2N/3)$-消除代碼對區塊候選者進行編碼，將結果數據的$1/N$直接發送到組的每個成員，並期望他們將其數據的部分直接多播到組的所有其他成員。

然而，一個更快且更簡單的方法（參見\ptref{sp:streaming.multicast}）是將區塊候選者分成一系列簽名的一千字節區塊（「chunks」），通過Reed--Solomon或泉代碼（如RaptorQ code~\cite{RaptorQ} \cite{Raptor}）擴充它們的序列，並開始傳輸chunks到「多播網格」（即覆蓋網絡）中的鄰居，期望他們將這些chunks進一步傳播。一旦驗證者獲得足夠的chunks來從中重建區塊候選者，它就會簽署一個確認收據並通過其鄰居將其傳播到整個組。然後，它的鄰居停止向它發送新的chunks，但可能會繼續發送這些chunks的（原始）簽名，認為該節點可以通過應用Reed--Solomon或泉代碼自行生成後續的chunks（擁有所有必要的數據），將它們與簽名組合起來，並傳播給還沒有準備好的鄰居。

如果在移除所有「壞」節點後「多播網格」（覆蓋網絡）仍保持連接（回想一下，允許最多三分之一的節點以拜占庭方式壞掉，即以任意惡意方式行為），則此算法將以最快的方式傳播區塊候選者。

不僅指定的高優先級區塊創建者可以將其區塊候選者多播到整個組。第二和第三優先順序的驗證者可能會開始多播他們的區塊候選者，無論是立即還是在未能從最高優先級的驗證者那裡接收到區塊候選者之後。但是，通常只有最大優先權的區塊候選者將被所有（實際上，至少由三分之二的任務組）驗證者簽名並作為新的shardchain區塊提交。


\nxsubpoint \embt(Validation of block candidates.)  一旦 block candidate 被 validator 接收並檢查其起始 validator 的簽名，接收 validator 會檢查此 block candidate 的有效性，執行其中的所有交易並確保其結果與所聲稱的一致。從其他區塊鏈導入的所有消息都必須在 collated data 中有適當的 Merkle 證明，否則 block candidate 將被視為無效（並且，如果此證明被提交到 masterchain，則可能會懲罰已經簽署此 block candidate 的 validator）。另一方面，如果 block candidate 被認定為有效，接收 validator 會簽署它並將其簽名傳播給組中的其他 validator，可以通過「mesh multicast network」或直接的網絡消息。

我們想強調，{\em validator 在檢查（collated）block candidate 的有效性時，不需要訪問此 shardchain 或相鄰 shardchain 的狀態}。\footnote{一個可能的例外是相鄰 shardchain 的輸出隊列的狀態，因為在這種情況下，Merkle 證明的大小可能會變得過大。} 這使得驗證可以非常快速地進行（不需要磁盤訪問），並減輕了 validator 的計算和存儲負擔（尤其是如果他們願意接受外部 collators 的幫助來創建 block candidate）。

\nxsubpoint\label{sp:new.shardc.blk} \embt(Election of the next block candidate.)  一旦 block candidate 收集到 task group 中至少三分之二（按 stake）的 validator 的有效簽名，它就有資格被提交為下一個 shardchain block。運行一個 BFT 協議來達成對所選 block candidate 的共識（可能有多個提議），所有「好的」validator 都會優先選擇該輪中優先級最高的 block candidate。運行此協議的結果是，該 block 會被至少三分之二的 validator（按 stake）的簽名所增強。這些簽名不僅證明了所問 block 的有效性，還證明了它是由 BFT 協議選出的。之後，將 block（無 collated data）與這些簽名組合，以確定的方式序列化，然後通過網絡傳播給所有相關方。

\nxsubpoint \embt(Validators must keep the blocks they have signed.)  在他們成為 task group 的成員期間，以及之後至少一小時（或者 $2^{10}$ blocks），validator 預期會保留他們已簽署和提交的 block。如果未能向其他 validator 提供簽署的 block，可能會受到懲罰。

\nxsubpoint \embt(Propagating the headers and signatures of new shardchain blocks to all validators.)  Validator 將新生成的 shardchain block 的 headers 和簽名傳播到全局 set of validators，使用類似於為每個 task group 創建的 multicast mesh network。

\nxsubpoint\label{sp:new.master.blk} \embt(Generation of new masterchain blocks.)  在所有（或幾乎所有）新的 shardchain block 生成之後，可以生成一個新的 masterchain block。這個程序基本上與 shardchain block 相同（參見~\ptref{sp:new.shardc.blk}），不同之處在於所有 validator（或至少三分之二的 validator）都必須參與此過程。因為新的 shardchain block 的 headers 和簽名被傳播給所有的 validator，所以每個 shardchain 中最新的 block 的 hash 可以並且必須被包含在新的 masterchain block 中。一旦這些 hash 被提交到 masterchain block，外部觀察者和其他 shardchain 可以認為新的 shardchain block 已經提交並且是不可變的（參見~\ptref{sp:sc.hash.mc}）。


\nxsubpoint \embt(Validators must keep the state of masterchain.)  
所有的驗證者都預期要追踪 masterchain 的狀態，而不依賴於彙整的數據。這很重要，因為驗證者工作組的知識是從 masterchain 的狀態中衍生出來的。

\nxsubpoint \embt(Shardchain blocks are generated and propagated in parallel.)  
通常，每個驗證者都是幾個 shardchain 任務組的成員;他們的數量（因此驗證者的負載）大約與驗證者的股份成正比。這意味著驗證者同時運行多個新的 shardchain 區塊生成協議。

\nxsubpoint \embt(Mitigation of block retention attacks.)  
因為所有驗證者在只看到其標頭和簽名後就將一個新的 shardchain 區塊的 hash 插入到 masterchain 中，因此存在一個小概率，即生成此區塊的驗證者會密謀並試圖避免發佈整個新區塊。這將導致鄰近 shardchains 的驗證者無法創建新的區塊，因為一旦它的 hash 被提交到 masterchain 中，他們必須至少知道新區塊的輸出消息隊列。

為了緩解這種情況，新區塊必須從其他一些驗證者（例如，鄰近 shardchains 的任務組聯合的三分之二）收集簽名，證明這些驗證者確實擁有此區塊的副本並且願意在需要時將它們發送給其他驗證者。只有在提供這些簽名之後，新區塊的 hash 才可能包含在 masterchain 中。

\nxsubpoint \embt(Masterchain blocks are generated later than shardchain blocks.)  
Masterchain 區塊大約每五秒生成一次，就像 shardchain 區塊一樣。但是，雖然所有 shardchains 中的新區塊的生成基本上是同時進行的（通常由釋放新的 masterchain 區塊觸發），但新的 masterchain 區塊的生成被故意延遲，以允許在 masterchain 中包含新生成的 shardchain 區塊的 hashes。

\nxsubpoint\label{sp:slow.valid} \embt(Slow validators may receive lower rewards.)  
如果一個驗證者“慢”，它可能無法驗證新的區塊候選者，並且收集提交新區塊所需的三分之二的簽名可能不需要它的參與。在這種情況下，它將收到與此區塊相關的較低份額的獎勵。

這為驗證者提供了一個激勵，以優化他們的硬體、軟體和網路連接，以便盡可能快地處理用戶交易。

但是，如果驗證者在區塊提交之前未簽名，則其簽名可能包含在接下來的一個或多個區塊中，然後這部分獎勵（根據已生成多少區塊而呈指數下降---例如，如果驗證者延遲$k$區塊則為$0.9^k$）仍將給予此驗證者。


\nxsubpoint\label{sp:val.sign.depth} \embt(``Depth'' of validator signatures.)  
通常，當驗證者簽署一個區塊時，該簽名只證明了區塊的{\em 相對有效性\/}：只要這個和其他 shardchains 的所有先前區塊都是有效的，這個區塊就是有效的。驗證者不能因為將先前區塊中提交的無效數據視為理所當然而受到懲罰。

然而，區塊的驗證者簽名有一個稱為“深度”的整數參數。如果它是非零的，那就意味著驗證者也宣稱先前指定數量的區塊的(相對)有效性。這是“慢”或“暫時離線”的驗證者趕上並簽署一些已經提交但未經他們簽名的區塊的方式。然後區塊獎勵的一部分仍將給予他們（參見~\ptref{sp:slow.valid}）。

\nxsubpoint\label{sp:abs.val.from.rel} \embt(Validators are responsible for {\em relative\/} validity of signed shardchain blocks; absolute validity follows.)  
我們想再次強調，驗證者在 shardchain 區塊 \(B\) 上的簽名只證明了該區塊的{\em 相對\/}有效性（或者如果簽名有“深度” \(d\)，也可能是 \(d\) 個先前的區塊的相對有效性，參見~\ptref{sp:val.sign.depth}；但這不太影響下面的討論）。換句話說，驗證者聲稱 shardchain 的下一個狀態 \(s'\) 是通過應用在~\ptref{sp:blk.transf}中描述的區塊評估函數 \(\evblock\) 從先前的狀態 \(s\) 獲得的：
\begin{equation}\label{eq:ev.block.2}
  s'=\evblock(B)(s)
\end{equation}
這樣，如果原始狀態 \(s\) 被證明為“不正確”（例如，由於先前區塊的無效性），那麼簽署了區塊 \(B\) 的驗證者不能被懲罰。漁夫（參見~\ptref{sp:fish}）只有在發現一個區塊是{\em 相對地\/}無效時才會抱怨。PoS 系統作為一個整體努力使每個區塊都是{\em 相對地\/}有效的，而不是{\em 遞迴地（或絕對地）}有效的。然而，注意到，{\em 如果 blockchain 中的所有區塊都是相對有效的，那麼它們所有的和 blockchain 作為一個整體都是絕對有效的}；使用對 blockchain 的長度的數學歸納法可以輕易地證明這一語句。通過這種方式，輕鬆可驗證的區塊的{\em 相對\/}有效性的聲明一起證明了整個 blockchain 的更強大的{\em 絕對有效性\/}。

注意，通過簽署一個區塊~\(B\)，驗證者聲稱該區塊給定原始狀態 \(s\) 是有效的（即，~\eqref{eq:ev.block.2}的結果不是值 \(\bot\)，表示下一個狀態不能被計算）。因此，驗證者必須執行在評估~\eqref{eq:ev.block.2}期間訪問的原始狀態的 cell 的最小形式檢查。

例如，想像一個情境，期望從提交到區塊的交易中訪問的賬戶的原始餘額的 cell 被發現有零個原始字節，而不是期望的 8 或 16。然後，原始餘額簡單地不能從 cell 中檢索，並且在嘗試處理該區塊時會發生“未處理的異常”。在這種情況下，驗證者不應該簽署這樣的區塊，否則將受到懲罰。

\nxsubpoint \embt(Signing masterchain blocks.)  
與masterchain區塊的情況略有不同：簽署一個masterchain區塊，驗證者不僅聲明其相對有效性，而且還聲明所有先前區塊的相對有效性，直到這個驗證者承擔其責任的第一個區塊（但不再往回）。

\nxsubpoint \embt(The total number of validators.)  
驗證者被選舉的總數的上限 \(T\) （參見~\ptref{sp:global.valid}）在迄今為止描述的系統中，不能超過，例如，幾百或一千，因為所有驗證者都預計參與BFT共識協議來創建每個新的masterchain區塊，並且尚不清楚這樣的協議是否可以擴展到數千參與者。更重要的是，masterchain區塊必須收集至少三分之二的所有驗證者（按權益）的簽名，並且這些簽名必須包含在新區塊中（否則系統中的所有其他節點都沒有理由信任新區塊而不自己驗證它）。如果必須在每個masterchain區塊中包括超過，例如，一千個驗證者簽名，這將意味著每個masterchain區塊中有更多的數據，所有完整節點都要存儲並通過網絡傳播，以及花費更多的處理能力來檢查這些簽名（在PoS系統中，完整節點不需要自己驗證區塊，但他們需要相反地檢查驗證者的簽名）。

雖然將 \(T\) 限制為一千個驗證者對於TON Blockchain的部署的第一階段似乎足夠了，但必須為未來的增長提供條款，當shardchains的總數變得如此之大，以至於幾百個驗證者不足以處理所有的shardchains。為此，我們引入了一個額外的可配置參數 \(T'\leq T\)（原本等於~\(T\)），並且只有前 \(T'\) 名被選舉的驗證者（按權益）預計創建和簽署新的masterchain區塊。


\nxsubpoint \embt(Decentralization of the system.)  
有人可能會懷疑，像TON Blockchain這樣的Proof-of-Stake系統，依賴\(T\approx1000\)的驗證者來創建所有shardchain和masterchain區塊，是否會變得“太集中”，與像Bitcoin或Ethereum這樣的傳統Proof-of-Work區塊鏈相反，其中每個人（原則上）都可能開採一個新區塊，沒有礦工總數的明確上限。

但是，像Bitcoin和Ethereum這樣的受歡迎的Proof-of-Work區塊鏈，目前需要大量的計算能力（高“hash rates”）以成功的概率開採新區塊。因此，新區塊的開採趨於集中在幾個大玩家手中，他們投資大量資金建立充滿為開採優化的定制硬體的數據中心；以及幾個大型的開採池手中，它們集中並協調了無法自己提供足夠“hash rate”的大量人的努力。

因此，到2017年，超過75％的新Ethereum或Bitcoin區塊由少於十個礦工產生。實際上，兩個最大的Ethereum開採池共同生產了超過一半的所有新區塊！顯然，這樣的系統比依賴\(T\approx1000\)節點生產新區塊的系統更為集中。

人們還可能注意到，成為TON Blockchain驗證者所需的投資——即購買硬體（例如，幾個高性能服務器）和權益（如有必要，可以通過提名者池輕鬆收集；參見~\ptref{sp:nominators}）——比成為成功的獨立Bitcoin或Ethereum礦工所需的要少。實際上，~\ptref{sp:global.valid}的參數\(L\)將迫使提名者不加入最大的“開採池”（即，積累了最大權益的驗證者），而是尋找目前正在接受提名者資金的較小的驗證者，甚至創建新的驗證者，因為這將允許更高比例的驗證者的——並且也是提名者的——權益被使用，從而獲得更大的開採獎勵。這種方式，TON Proof-of-Stake系統實際上{\em 鼓勵\/}去中心化（創建和使用更多的驗證者）並{\em 懲罰\/}集中化。

\nxsubpoint\label{sp:rel.rel} \embt(Relative reliability of a block.)
區塊的{\em (相對) 可靠性\/}簡單地說是已簽署此區塊的所有驗證者的總權益。換句話說，如果這個區塊被證明是無效的，某些行為者會失去的金額。如果有人關心的交易傳輸值低於區塊的可靠性，可以認為它們足夠安全。從這個意義上說，相對可靠性是外部觀察者可以對特定區塊的信任度的衡量。

注意，我們談論的是區塊的{\em 相對\/}可靠性，因為它保證該區塊是有效的{\em 前提是前一個區塊和所有其他被參考的shardchains'區塊都是有效的\/}（參見~\ptref{sp:abs.val.from.rel}）。

一個區塊的相對可靠性在提交後可能會增加——例如，當遲來的驗證者的簽名被添加時（參見~\ptref{sp:val.sign.depth}）。另一方面，如果其中一個驗證者因與其他區塊相關的不當行為而失去部分或全部權益，區塊的相對可靠性可能{\em 減少}。

\nxsubpoint \embt("Strengthening" the blockchain.) 提供驅使驗證器提高區塊相對可靠性的激勵是很重要的。這樣做的一種方法是為驗證器分配小量的獎勵，以在其他shardchains的區塊上添加簽名。即使是“即將成為”的驗證器，他們已存入的股份不足以進入按股份排名前$T$的驗證器，並被包括在全局驗證器集合中（參見~\ptref{sp:global.valid}），也可能參與這項活動（如果他們同意在失去選舉後保持其股份凍結，而不是撤回）。這樣的驗證器可能同時充當漁民（參見~\ptref{sp:fish}）：如果他們必須檢查某些區塊的有效性，他們也可以選擇報告無效的區塊並收集相關獎勵。

\nxsubpoint\label{sp:rec.rel} \embt(Recursive reliability of a block.) 人們也可以定義一個區塊的{\em recursive reliability\/}，這是其相對可靠性與其引用的所有區塊的遞歸可靠性之間的最小值（即，masterchain區塊、先前的shardchain區塊和一些相鄰shardchains的區塊）。換句話說，如果該區塊被證明是無效的，無論是因為它本身無效還是因為它所依賴的某個區塊無效，至少有人會失去這筆錢。如果人們真的不確定是否信任區塊中的特定交易，人們應該計算這個區塊的{\em recursive\/}可靠性，而不僅僅是{\em relative\/}的可靠性。

當計算遞歸可靠性時，沒有必要回溯太遠，因為如果我們回溯太遠，我們會看到已經解凍並提取的驗證器簽名的區塊。無論如何，我們不允許驗證器自動重新考慮那些舊的區塊（即，創建超過兩個月的區塊，如果使用當前的可配置參數的值），並從中創建分叉或使用“垂直blockchains”（參見~\ptref{sp:inv.sh.blk.corr}）修正它們，即使它們被證明是無效的。我們假設兩個月的時期提供了充足的機會來檢測和報告任何無效的區塊，因此如果在這段時期內沒有挑戰某個區塊，那麼它不太可能受到挑戰。

\nxsubpoint \embt(Consequence of Proof-of-Stake for light nodes.)  TON Blockchain 採用的 Proof-of-Stake 方法的一個重要結果是，TON Blockchain 的輕型節點（運行輕型客戶端軟體）不需要下載所有 shardchain 或甚至 masterchain 區塊的「標頭」，以便能夠自行檢查完整節點提供給其的 Merkle 證明，作為對其查詢的回答。

實際上，由於最近的 shardchain 區塊 hash 已包含在 masterchain 區塊中，完整節點可以輕鬆提供一個 Merkle 證明，從已知的 masterchain 區塊的 hash 開始，說明給定的 shardchain 區塊是有效的。接下來，輕型節點只需要知道 masterchain 的第一個區塊（其中宣布了第一組驗證器），這個區塊（或至少其 hash）可能被內置到客戶端軟體中，並且每個月後只需一個 masterchain 區塊，其中宣布了新當選的驗證器集合，因為這個區塊將由上一組驗證器簽署。從那時起，它可以獲得最近的幾個 masterchain 區塊，或至少他們的標頭和驗證器簽名，並使用它們作為檢查完整節點提供的 Merkle 證明的基礎。

\mysubsection{分割和合併 Shardchains}\label{sect:split.merge}

TON Blockchain 最具特色和獨特的功能之一是，當負載過高時，它能夠自動將 shardchain 分割為兩部分，並在負載下降時將它們合併回來（參見~\ptref{sp:dyn.split.merge}）。由於其獨特性和對整個項目可擴展性的重要性，我們必須詳細討論它。

\nxsubpoint \embt(Shard configuration.)  請回憶，在任何給定的時間點，每個工作鏈 $w$ 都被分割成一個或多個 shardchains $(w,s)$ （參見~\ptref{sp:shard.ident}）。這些 shardchains 可以由一棵二進制樹的葉子表示，其根為 $(w,\emptyset)$，且每個非葉子節點 $(w,s)$ 都有子節點 $(w,s.0)$ 和 $(w,s.1)$。這樣，屬於工作鏈 $w$ 的每個賬戶都被分配到確切的一個 shard，而知道當前的 shardchain 配置的每個人都可以確定包含賬戶 $\accountid$ 的 shard $(w,s)$：它是二進制字符串 $s$ 是 $\accountid$ 前綴的唯一 shard。

shard 配置—即，這個 {\em shard binary tree}，或給定 $w$ 的所有活躍 $(w,s)$ 的集合（對應於 shard binary tree 的葉子）—是 masterchain 狀態的一部分，且對於跟踪 masterchain 的每個人都可用。\footnote{實際上，shard 配置完全由最後的 masterchain 區塊確定；這簡化了獲取 shard 配置的訪問。}

\nxsubpoint \embt(Most recent shard configuration and state.)  回想一下，最近的 shardchain 區塊的 hashes 被包含在每個 masterchain 區塊中。這些 hashes 被組織成一個 shard binary tree（實際上，是每個 workchain 的一系列樹）。這樣，每個 masterchain 區塊都包含最近的 shard 配置。

\nxsubpoint \embt(Announcing and performing changes in the shard configuration.)  shard 配置可以通過兩種方式更改：要麼將 shard $(w,s)$ {\em split\/} 為兩個 shards $(w,s.0)$ 和 $(w,s.1)$，要麼將兩個「sibling」shards $(w,s.0)$ 和 $(w,s.1)$ {\em merged\/} 為一個 shard $(w,s)$。

這些 split/merge 操作在事先（例如，$2^6$；這是一個可配置的參數）的區塊中被宣布，首先在相應的 shardchain 區塊的「標頭」中，然後在引用這些 shardchain 區塊的 masterchain 區塊中。這個提前公告是為了讓所有相關方為計劃的變更做好準備（例如，建立一個 overlay multicast network 來分發新創建的 shardchains 的新區塊，如~\ptref{sect:overlay}所述）。然後，更改首先提交到 shardchain 區塊的（標頭），然後傳播到 masterchain 區塊。這樣，masterchain 區塊不僅定義了在其創建之前的最新 shard 配置，而且還定義了下一個立即的 shard 配置。

\nxsubpoint \embt(Validator task groups for new shardchains.)  回憶一下，每個 shard，即每個 shardchain，通常都被分配一個驗證器的子集（一個 validator task group）專用於在相應的 shardchain 中創建和驗證新區塊（參見~\ptref{sp:val.task.grp}）。這些 task groups 被選為某段時間（大約一小時），並且在提前知道的時間（也大約是一小時），在此期間是不變的。\footnote{除非某些驗證器因簽署無效的區塊而被臨時或永久禁止，那麼他們將自動從所有 task groups 中被排除。}

但是，實際的 shard 配置可能會在此期間因為 split/merge 操作而發生變化。必須為新創建的 shards 分配 task groups。這是如此完成的：

注意，任何活躍的 shard $(w,s)$ 要麼是某個唯一確定的原始 shard $(w,s')$ 的後代，意味著 $s'$ 是 $s$ 的前綴，要麼它將是原始 shards $(w,s')$ 的子樹的根，其中 $s$ 將是每個 $s'$ 的前綴。在第一種情況下，我們簡單地將原始 shard $(w,s')$ 的 task group 作為新 shard $(w,s)$ 的 task group。在後一種情況下，新 shard $(w,s)$ 的 task group 將是所有原始 shards $(w,s')$ 的 task groups 的聯集，這些 shards 是 shard tree 中的 $(w,s)$ 的後代。

這樣，每個活躍的 shard $(w,s)$ 都被分配了一個明確定義的驗證器子集（task group）。當一個 shard 被分割時，兩個子節點都繼承了原始 shard 的整個 task group。當兩個 shards 被合併時，它們的 task groups 也被合併。

任何追踪 masterchain 狀態的人都可以計算每個活躍 shard 的驗證器 task groups。


\nxsubpoint \embt(Limit on split/merge operations during the period of
responsibility of original task groups.) 最終，新的 shard 配置將被考慮到，並且新的專用驗證器子集（task groups）將自動分配給每個 shard。在此之前，必須對 split/merge 操作施加某種限制；否則，如果原始 shard 迅速分裂成 $2^k$ 個新的 shards，則原始 task group 可能最終同時驗證 $2^k$ shardchains，對於大的 $k$。

這是通過對 active shard 配置與原始 shard 配置（目前用於選擇 validator task groups 的配置）之間的距離施加限制來實現的。例如，可能要求從 active shard $(w,s)$ 到原始 shard $(w,s')$ 在 shard tree 中的距離，如果 $s'$ 是 $s$ 的前驅（即 $s'$ 是 binary string $s$ 的前綴），則不得超過3，如果 $s'$ 是 $s$ 的後繼（即 $s$ 是 $s'$ 的前綴），則不得超過2。否則，不允許進行 split 或 merge 操作。

大致上，對於給定的 validator task groups 集合的責任期間，一個 shard 可以被分裂（例如，三次）或合併（例如，兩次）的次數施加了限制。除此之外，合併或分裂創建 shard 之後，某段時間（某些區塊數）內不能重新配置它。

\nxsubpoint\label{sp:split.necess} \embt(Determining the necessity of
split operations.) shardchain 的 split 操作是由某些正式條件觸發的（例如，如果連續64個區塊的 shardchain 區塊至少有 $90\%$ 是滿的）。這些條件由 shardchain task group 監控。如果它們得到滿足，首先在新的 shardchain 區塊的標頭中包含一個「split 準備」標誌（並傳播到引用這個 shardchain 區塊的 masterchain 區塊）。然後，在幾個區塊之後，shardchain 區塊的標頭中包含「split 提交」標誌（並傳播到下一個 masterchain 區塊）。

\nxsubpoint \embt(Performing split operations.) 在 shardchain $(w,s)$ 的區塊 $B$ 中包含「split commit」標誌後，該 shardchain 中不能有後續的區塊 $B'$。相反，將創建 shardchains $(w,s.0)$ 和 $(w,s.1)$ 的兩個區塊 $B'_0$ 和 $B'_1$，分別參考區塊 $B$ 作為它們的前一個區塊（並且它們都將通過標頭中的標誌指示 shard 剛剛被分裂）。下一個 masterchain 區塊將包含新 shardchains 的區塊 $B'_0$ 和 $B'_1$ 的 hashes；它不允許包含 shardchain $(w,s)$ 的新區塊 $B'$ 的 hash，因為「split commit」事件已經被提交到前一個 masterchain 區塊。

請注意，兩個新的 shardchains 將由與舊的 shardchain 相同的 validator task group 驗證，所以它們將自動擁有其狀態的副本。從 Infinite Sharding Paradigm 的角度來看，狀態分裂操作本身相對簡單（參見~\ptref{sp:split.merge.state}）。


\nxsubpoint\label{sp:merge.necess} \embt(Determining the necessity of
merge operations.) 合併 shard 操作的必要性也由某些正式條件檢測 (例如，如果連續64個區塊的兩個兄弟 shardchains 的區塊大小總和不超過最大區塊大小的 $60\%$)。這些正式條件還應考慮這些區塊所消耗的總 gas，並將其與當前的區塊 gas 限制進行比較，否則由於有一些計算密集型的交易阻止了更多交易的納入，區塊可能會偶然變小。

這些條件由兩個兄弟 shards $(w,s.0)$ 和 $(w,s.1)$ 的 validator task groups 監控。請注意，兄弟節點在 hypercube 路由方面必然是鄰居 (參考~\ptref{sp:hypercube})，因此任何 shard 的 task group 的 validators 都將在某種程度上監控兄弟 shard。

當滿足這些條件時，validator 子組之一可以通過發送特殊消息建議另一個合併。然後，它們組合成一個臨時的「合併任務組」，具有組合的成員資格，能夠運行 BFT 共識算法，並在必要時傳播區塊更新和區塊候選者。

如果他們就合併的必要性和準備情況達成共識，「merge prepare」標誌將提交到每個 shardchain 的一些區塊的頭部，並附帶至少三分之二的兄弟 task group 的 validators 的簽名（並被傳播到下一個 masterchain 區塊，以便每個人都可以為即將到來的重新配置做好準備）。但是，他們繼續為一些預定義數量的區塊創建單獨的 shardchain 區塊。

\nxsubpoint \embt(Performing merge operations.) 之後，當來自兩個原始 task groups 的聯合的 validators 準備成為已合併 shardchain 的 validators 時 (這可能涉及從兄弟 shardchain 的狀態轉移和一個狀態合併操作)，他們在其 shardchain 的區塊的頭部提交一個「merge commit」標誌 (這一事件傳播到下一個 masterchain 區塊)，並停止在單獨的 shardchains 中創建新的區塊 (一旦出現 merge commit 標誌，在單獨的 shardchains 中創建區塊是被禁止的)。相反，創建了一個已合併的 shardchain 區塊 (由兩個原始 task groups 的聯合創建)，在其「header」中參考它的兩個「preceding blocks」。這反映在下一個 masterchain 區塊中，該區塊將包含已合併 shardchain 的新創建區塊的 hash。之後，已合併的 task group 繼續在已合併的 shardchain 中創建區塊。

\mysubsection{區塊鏈專案的分類}\label{sect:class.blkch}

我們將通過將 TON 區塊鏈與現有和擬議的區塊鏈專案進行比較，來結束我們對 TON 區塊鏈的簡短討論。但在此之前，我們必須引入一個足夠通用的區塊鏈專案分類。基於此分類的特定區塊鏈專案的比較，將被推遲到~\ptref{sect:compare.blkch}。

\nxsubpoint \embt(Classification of blockchain projects.) 作為第一步，我們建議一些用於區塊鏈（即，對於區塊鏈專案）的分類標準。任何這種分類都是有點不完整和表面的，因為它必須忽略正在考慮的專案的一些最具體和獨特的特點。然而，我們認為這是在提供至少一個非常粗略和大約的區塊鏈專案地圖的必要第一步。

我們考慮的標準列表如下：
\begin{itemize}
\item 單一區塊鏈與多區塊鏈架構 (參見~\ptref{sp:single.multi})
\item 共識算法：Proof-of-Stake 與 Proof-of-Work (參見~\ptref{sp:pow.pos})
\item 對於 Proof-of-Stake 系統，使用的確切的區塊生成、驗證和共識算法（兩個主要選項是 DPOS 與 BFT; 參見~\ptref{sp:dpos.bft}）
\item 對「任意的」(Turing-complete) 智能合約的支持 (參見~\ptref{sp:smartc.supp})
\end{itemize}
多區塊鏈系統有額外的分類標準 (參見~\ptref{sp:class.multichain}):
\begin{itemize}
\item 成員區塊鏈的類型和規則：同質的、異質的 (參見~\ptref{sp:blkch.hom.het})，混合的 (參見~\ptref{sp:mixed.het.hom})。聯邦 (參見~\ptref{sp:het.confed})
\item 有無{\em 主鏈}，內部或外部 (參見~\ptref{sp:pres.masterch})
\item 對 sharding 的原生支持 (參見~\ptref{sp:shard.supp})。靜態或動態 sharding (參見~\ptref{sp:dyn.stat.shard})
\item 成員區塊鏈之間的互動：鬆散聯接和緊密聯接的系統 (參見~\ptref{sp:blkch.interact})
\end{itemize}

\nxsubpoint\label{sp:single.multi} \embt(Single-blockchain vs.\ multi-blockchain projects.) 第一個分類標準是系統中的區塊鏈數量。最古老和最簡單的專案由一個{\em 單一區塊鏈}組成（簡稱「單鏈專案」）；更複雜的專案使用（或更確切地說，計劃使用）{\em 多個區塊鏈}（「多鏈專案」）。

單鏈專案通常更簡單且經過更好的測試；它們經受住了時間的考驗。它們的主要缺點是低性能，或者至少是交易吞吐量，對於通用系統來說，這一數量在十 (Bitcoin) 到不到一百 (Ethereum) 的交易每秒。一些專用系統（如 Bitshares）能夠在區塊鏈狀態適合於記憶體的情況下，處理每秒數萬的專用交易，並將處理限制於一個預定義的特殊交易集，然後由像 C++ 這樣的語言編寫的高度優化的代碼執行（這裡沒有 VMs）。

多鏈專案提供了每個人都渴望的可擴展性。他們可能支持更大的總狀態和更多的每秒交易，但代價是使專案變得更為複雜，其實施更具挑戰性。因此，已經運行的多鏈專案很少，但大多數擬議的專案都是多鏈的。我們相信未來屬於多鏈專案。


\nxsubpoint\label{sp:pow.pos} \embt(創建和驗證區塊: 工作量證明 vs. 權益證明.) 另一個重要的區別是用於創建和傳播新區塊、檢查其有效性，以及在出現多個分支時選擇其中之一的算法和協議。

兩種最常見的範疇是 {\em Proof-of-Work (PoW)} 和 {\em Proof-of-Stake (PoS)}。工作量證明方法通常允許任何節點創建（“挖掘”）一個新區塊（並獲得與挖掘區塊相關的一些獎勵），前提是它有幸在其他競爭者成功之前解決一個否則無用的計算問題（通常涉及計算大量的hashes）。在出現分支的情況下（例如，如果兩個節點發布兩個否則有效但不同的區塊來跟隨前一個），最長的分支勝出。這樣，區塊鏈的不變性保證是基於生成區塊鏈所花費的{\em 工作量}（計算資源）：任何希望創建此區塊鏈的分支的人都需要重新做這些工作，以創建已提交區塊的替代版本。為此，一個人需要控制超過$50\%$的創建新區塊所花費的總計算能力，否則替代分支變得最長的機會會指數性地降低。

權益證明方法基於一些特殊節點（{\em 驗證者}）所做的大量{\em 賭注}（以加密貨幣提名），以斷言它們已經檢查了一些區塊並發現它們是正確的。驗證者簽署區塊，並因此收到一些小獎勵；但是，如果一個驗證者被發現簽署了一個不正確的區塊，並且提供了這方面的證據，則其全部或部分賭注將被沒收。這樣，區塊鏈的有效性和不變性保證是由驗證者對區塊鏈有效性的總賭注給出的。

從這個角度看，權益證明更為自然，因為它激勵驗證者（它們取代了PoW礦工）執行有用的計算（需要檢查或創建新區塊，尤其是執行區塊中列出的所有交易），而不是計算其他無用的hashes。這樣，驗證者會購買更適合處理用戶交易的硬件，以獲得與這些交易相關的獎勵，從整個系統的角度看，這似乎是一項相當有用的投資。

然而，權益證明系統在實施上有些挑戰，因為必須為許多罕見但可能的情況提供支援。例如，一些惡意的驗證者可能密謀破壞系統以獲取利益（例如，通過改變自己的加密貨幣餘額）。這導致了一些非常重要的博弈論問題。

簡而言之，權益證明更為自然且更有前景，尤其是對於多區塊鏈專案（因為如果有許多區塊鏈，工作量證明將需要過多的計算資源），但必須更加小心地考慮和實施。大多數目前運行的區塊鏈專案，尤其是最古老的專案（如Bitcoin和至少是原始的Ethereum），使用工作量證明。

\nxsubpoint\label{sp:dpos.bft} \embt(Variants of Proof-of-Stake. DPOS
vs.\ BFT.) 雖然Proof-of-Work算法彼此非常相似，主要差異在於必須計算以挖掘新區塊的hash函數，但Proof-of-Stake算法有更多的可能性。它們自己值得一個子分類。

基本上，人們必須回答關於Proof-of-Stake算法的以下問題：
\begin{itemize}
\item 誰可以產生（“挖掘”）一個新區塊 - 任何完整節點，或只是驗證者的（相對地）小子集的成員？ (大多數PoS系統要求新區塊由數個指定的驗證者生成並簽名。)
\item 驗證者是否通過他們的簽名保證區塊的有效性，還是所有完整節點都期望自己驗證所有區塊？ (可擴展的PoS系統必須依賴驗證者的簽名，而不是要求所有節點驗證所有區塊鏈的所有區塊。)
\item 是否有一個預先知道的指定生產者來生成下一個區塊鏈區塊，這樣其他人就不能代替它產生那個區塊？
\item 新建的區塊最初只由一個驗證者（其生產者）簽署，還是它必須從一開始就收集大多數驗證者的簽名？
\end{itemize}

雖然似乎根據這些問題的答案有$2^4$可能的PoS算法類別，但在實踐中，區別主要歸結為兩種主要的PoS方法。事實上，大多數現代的PoS算法，旨在用於可擴展的多鏈系統，在前兩個問題上的答案是相同的：只有驗證者可以產生新區塊，並且他們保證區塊的有效性，而不要求所有完整節點自己檢查所有區塊的有效性。

至於最後兩個問題，它們的答案被證明是高度相關的，基本上只留下了兩個基本選項：
\begin{itemize}
\item {\em Delegated Proof-of-Stake (DPOS)}：每個區塊都有一個眾所周知的指定生產者；其他人不能生產該區塊；新區塊最初只由其生成的驗證者簽署。
\item {\em Byzantine Fault Tolerant (BFT)} PoS算法：有一個已知的驗證者子集，其中任何一個都可以建議一個新區塊；在多個建議的候選區塊中選擇實際的下一個區塊的選擇，必須在被發布到其他節點之前由大多數驗證者驗證並簽名，這是通過Byzantine Fault Tolerant共識協議的版本來實現的。
\end{itemize}

\nxsubpoint\label{sp:dpos.bft.compare} \embt(Comparison of DPOS and
BFT PoS.) BFT方法的優勢是新產生的區塊從一開始就有大多數驗證者的簽名證明其有效性。另一個優點是，如果大多數驗證者正確執行BFT共識協議，則根本不會出現分叉。但另一方面，BFT算法往往相當複雜，並且需要更多的時間讓驗證者子集達成共識。因此，區塊不能太頻繁地生成。這就是為什麼我們預期TON Blockchain（從這個分類的角度看是一個BFT項目）每五秒只生成一個區塊。在實踐中，這個間隔可能會減少到2-3秒（儘管我們不承諾這一點），但如果驗證者分散在全球各地，則不會再減少。

DPOS算法的優勢是相當簡單和直接。由於它依賴於預先知道的指定區塊生成者，所以可以非常頻繁地生成新區塊，例如，每兩秒一次，或者甚至每秒一次。\footnote{有些人甚至聲稱DPOS區塊生成時間為半秒，如果驗證者分散在幾個大陸上，這似乎不太現實。}

然而，DPOS要求所有節點 - 或至少所有驗證者 - 驗證收到的所有區塊，因為生成並簽署新區塊的驗證者不僅確認了此區塊的相對有效性，還確認了它引用的前一個區塊的有效性，以及在鏈中更遠的所有區塊（也許直到當前驗證者子集的責任期開始）。當前驗證者子集上有一個預定的順序，因此每個區塊都有一個指定的生產者（即，預期生成該區塊的驗證者）；這些指定的生產者按循環方式旋轉。這樣，一個區塊首先只由其生成的驗證者簽名；然後，當挖掘下一個區塊時，並且其生產者選擇引用此區塊而不是它的前一個區塊（否則它的區塊將位於較短的鏈中，這可能會在未來失去“最長分叉”競賽），下一個區塊的簽名本質上也是對前一個區塊的附加簽名。這樣，一個新區塊逐漸收集更多驗證者的簽名 - 例如，生成下一個區塊所需的時間內的二十個簽名。一個完整的節點將需要等待這二十個簽名，或者自己驗證區塊，從一個已充分確認的區塊開始（例如，回退二十個區塊），這可能並不容易。

DPOS算法的明顯缺點是，只有在挖掘二十個更多的區塊後，一個新區塊（以及其內部的交易）才能達到相同的信任水平（“遞歸可靠性”如\ptref{sp:rec.rel}中所討論的），而BFT算法則立即提供這種信任水平（例如，二十個簽名）。另一個缺點是，DPOS使用“最長分叉勝出”的方法來切換到其他分叉；如果至少有一些生產者在我們感興趣的那個之後無法生成後續的區塊（或者由於網絡分割或複雜的攻擊而未能觀察到這些區塊），這使得分叉相當可能。


我們認為，BFT 方法，雖然在實作上更複雜且產生區塊的間隔時間比DPOS長，但它更適合用於「緊密結合」(參考~\ptref{sp:blkch.interact})的多鏈系統。因為其他的區塊鏈可以在看到新區塊中的已提交交易（例如，生成給它們的消息）後幾乎立即開始行動，而不必等待20次確認有效性（即，接下來的20個區塊），或者等待接下來的六個區塊以確保沒有分叉出現並自己驗證新區塊（在可擴展的多鏈系統中，驗證其他區塊鏈的區塊可能變得過於繁重）。因此，他們可以在保持高度的可靠性和可用性（參考~\ptref{sp:shard.supp}）的同時達到可擴展性。

另一方面，對於一個「鬆散結合」的多鏈系統，DPOS可能是一個好選擇，即使區塊鏈之間不需要快速交互，例如，如果每個區塊鏈（「工作鏈」）代表一個單獨的分散式交換，且區塊鏈之間的互動限於從一個工作鏈到另一個的罕見代幣轉移（或者，更准確地說，以接近$1:1$的比率交易住在一個工作鏈中的一個altcoin和另一個）。這就是BitShares計畫實際上所做的事情，它非常成功地使用了DPOS。

總的來說，雖然DPOS可以\emph{生成}新的區塊並且\emph{將交易}快速\emph{包含}進它們（區塊間隔時間較短），但這些交易達到其他區塊鏈和off-chain應用程序所需的信任級別，作為「已提交」和「不可變」的，比在BFT系統中\emph{慢得多}，例如，三十秒%
\footnote{例如，EOS，迄今為止提出的最好的DPOS項目之一，承諾45秒的確認和區塊鏈間的交互延遲（參考~\cite{EOSWP}，「交易確認」和「區塊鏈間通信的延遲」部分）。}
而不是五秒。更快的交易\emph{包含}並不意味著更快的交易\emph{承諾}。如果需要快速的區塊鏈間交互，這可能會成為一個巨大的問題。在這種情況下，人們必須放棄DPOS，而選擇BFT PoS。


\nxsubpoint\label{sp:smartc.supp} \embt(Support for Turing-complete
code in transactions, i.e., essentially arbitrary smart contracts.)
區塊鏈項目通常在他們的區塊中收集一些{\em transactions\/}，這些會以認為有用的方式更改區塊鏈的狀態（例如，從一個賬戶轉移某個加密貨幣金額到另一個賬戶）。有些區塊鏈項目可能只允許一些特定的預定義交易類型（如從一個賬戶到另一個賬戶的值轉移，提供正確的簽名）。其他人可能支持在交易中的一些有限的腳本形式。最後，一些區塊鏈支持在交易中執行任意複雜的代碼，使系統（至少原則上）能夠支持任意應用程序，只要系統的性能允許。這通常與「圖靈完整虛擬機和腳本語言」（意味著可以在任何其他計算語言中編寫的任何程序都可以重寫以在區塊鏈內部執行），以及「智能合約」（這些是住在區塊鏈中的程序）相關聯。

當然，支持任意智能合約使系統真正靈活。另一方面，這種靈活性是有代價的：這些智能合約的代碼必須在某個虛擬機上執行，每次有人想創建或驗證一個區塊時，都必須對區塊中的每個交易執行這個操作。與可以通過在像C++這樣的語言中實現它們的處理來優化的預定義和不可變的簡單交易類型的情況相比，這降低了系統的性能。

最終，對於任何通用區塊鏈項目，似乎都希望支持圖靈完整的智能合約;否則，區塊鏈項目的設計者必須預先決定他們的區塊鏈將用於哪些應用程序。實際上，比特幣區塊鏈中對智能合約的支持不足是必須創建新的區塊鏈項目Ethereum的主要原因。

在一個（異質的; cf.~\ptref{sp:blkch.hom.het}）多鏈系統中，人們可以通過在一些區塊鏈（即，工作鏈）中支持圖靈完整的智能合約，以及在其他區塊鏈中支持一小組高度優化的交易，來「兩全其美」。

\nxsubpoint\label{sp:class.multichain} \embt(Classification of
multichain systems.) 到目前為止，這個分類對單鏈和多鏈系統都是有效的。然而，多鏈系統承認幾個更多的分類標準，反映系統中不同的區塊鏈之間的關係。我們現在討論這些標準。

\nxsubpoint\label{sp:blkch.hom.het} \embt(Blockchain types:
homogeneous and heterogeneous systems.) 在多鏈系統中，所有區塊鏈可能本質上都是相同的類型，並且有相同的規則（即，使用相同的交易格式、相同的虛擬機器執行智能合約代碼、共享相同的加密貨幣等），這種相似性被明確地利用，但每個區塊鏈中的數據都是不同的。在這種情況下，我們說該系統是{\em homogeneous}。否則，不同的區塊鏈（在這種情況下通常被稱為{\em workchains\/}）可以有不同的「規則」。然後我們說系統是{\em heterogeneous}。

\nxsubpoint\label{sp:mixed.het.hom} \embt(Mixed
heterogeneous-homogeneous systems.) 有時我們有一個混合系統，其中存在多個區塊鏈的類型或規則集，但許多具有相同規則的區塊鏈都存在，且這一事實被明確地利用。那麼它是一個混合的{\em heterogeneous-homogeneous system}。據我們所知，TON Blockchain 是這種系統的唯一例子。

\nxsubpoint\label{sp:het.confed} \embt(Heterogeneous systems with
several workchains having the same rules, or {\em confederations}.) 在某些情況下，具有相同規則的多個區塊鏈（work\-chains）可以存在於異質系統中，但它們之間的互動與具有不同規則的區塊鏈之間的互動相同（即，並未明確地利用其相似性）。即使他們似乎使用「相同的」加密貨幣，事實上他們使用不同的「altcoins」（加密貨幣的獨立化身）。有時，人們甚至可以使用接近$1:1$的匯率轉換這些altcoins。然而，我們認為這並不使系統變得均質；它仍然是異質的。我們說具有相同規則的這樣的異質workchains集合是一個{\em confederation}。

雖然製作一個異質系統，允許創建具有相同規則的多個work\-chains（即一個聯邦）可能看起來是建立可擴展系統的便宜方法，但這種方法也有很多缺點。從本質上講，如果有人在許多具有相同規則的workchains中托管一個大型項目，她得到的不是一個大型項目，而是該項目的許多小實例。這就像有一個聊天應用程序（或遊戲）只允許每個聊天（或遊戲）房間有最多50名成員，但「擴展」通過創建新房間在必要時容納更多用戶。結果，許多用戶可以參加聊天或遊戲，但我們能說這樣的系統真的可擴展嗎？

\nxsubpoint\label{sp:pres.masterch} \embt(Presence of a masterchain,
external or internal.) 有時，一個多鏈計畫有一個特殊的「masterchain」（有時被稱為「控制區塊鏈」），用於存儲系統的整體配置（所有活躍的區塊鏈集合，或更準確地說是workchains）、當前的驗證者集合（對於一個Proof-of-Stake系統）等。有時其他的區塊鏈被「綁定」到masterchain，例如通過將它們最新的區塊的hash值提交到它（TON Blockchain也是這麼做的）。

在某些情況下，masterchain是{\em external}，這意味著它不是該計畫的一部分，而是一個原先完全與其無關的區塊鏈，對於新計畫的使用並不知情。例如，人們可以嘗試使用Ethereum區塊鏈作為一個外部計畫的masterchain，並為此目的在Ethereum區塊鏈上發布特殊的智能合約（例如，用於選舉和懲罰驗證者）。

\nxsubpoint\label{sp:shard.supp} \embt(Sharding support.) 有些區塊鏈計畫（或系統）有原生的支持{\em sharding}，這意味著幾個（必然是homogeneous；參見~\ptref{sp:blkch.hom.het}）區塊鏈被視為單一（從高級角度看）虛擬區塊鏈的{\em shards\/}。例如，人們可以創建256個具有相同規則的shard區塊鏈（「shardchains」），並根據其$\accountid$的第一個字節來確定帳戶的狀態。

Sharding是擴展區塊鏈系統的自然方法，因為，如果正確實施，系統中的用戶和智能合約根本不需要知道sharding的存在。事實上，當負載過高時，人們經常希望在現有的單鏈計畫（如Ethereum）中添加sharding。

另一種擴展方法是使用在~\ptref{sp:het.confed}中描述的異質workchains的「聯邦」，允許每個用戶在一個或多個她選擇的workchains中保留她的帳戶，並在必要時將資金從一個workchain轉移到另一個workchain，基本上進行$1:1$的altcoin交換操作。此方法的缺點已在~\ptref{sp:het.confed}中討論過。

但是，sharding不容易在快速和可靠的方式中實施，因為它意味著不同的shardchains之間有很多消息。例如，如果帳戶在$N$個shards之間均勻分佈，且唯一的交易是從一個帳戶到另一個帳戶的簡單資金轉移，那麼所有交易的只有一小部分（$1/N$）將在單一的區塊鏈中執行；幾乎所有的（$1-1/N$）交易將涉及兩個區塊鏈，需要跨區塊鏈的通信。如果我們希望這些交易快速，我們需要一個用於在shardchains之間傳輸消息的快速系統。換句話說，區塊鏈計畫需要在~\ptref{sp:blkch.interact}中描述的意義上是「緊密結合的」。

\nxsubpoint\label{sp:dyn.stat.shard} \embt(Dynamic and static sharding.)  分片可能是{\em dynamic\/}（當需要時自動創建額外的分片）或是{\em static\/}（有預先定義的分片數量，最好只能通過硬分叉來改變）。大多數分片提議都是靜態的；而TON Blockchain使用的是動態分片（參見~\ptref{sect:split.merge}）。

\nxsubpoint\label{sp:blkch.interact} \embt(Interaction between blockchains: loosely-coupled and tightly-coupled systems.) 多區塊鏈專案可以根據組件區塊鏈之間支持的互動水平進行分類。

最低的支持水平是不同區塊鏈之間完全沒有任何互動。我們在這裡不考慮這種情況，因為我們寧願說這些區塊鏈不是一個區塊鏈系統的部分，而只是相同區塊鏈協議的單獨實例。

下一個支持水平是缺乏對區塊鏈之間的消息傳送的任何具體支持，使得原則上可能進行互動，但很尷尬。我們稱這樣的系統為「鬆散耦合」；在這些系統中，人們必須像發送消息和轉移價值一樣，好像它們是屬於完全獨立的區塊鏈專案的區塊鏈（例如，比特幣和以太坊；想像兩方希望將存儲在比特幣區塊鏈中的比特幣兌換成存儲在以太坊區塊鏈中的以太）。換句話說，必須在源區塊鏈的區塊中包括出站消息（或其生成交易）。然後她（或其他某方）必須等待足夠的確認（例如，後續區塊的給定數量），以認為原始交易已被「提交」並「不可變」，從而能夠根據其存在執行外部操作。只有在此之後，才可以提交將消息中繼到目標區塊鏈的交易（也許還帶有源交易的參考和Merkle存在證明）。

如果在傳輸消息之前沒有等待足夠的時間，或者由於某些其他原因發生了分叉，那麼兩個區塊鏈的聯合狀態將被證明是不一致的：一條消息被遞送到第二個區塊鏈，而該消息從未在第一個區塊鏈中生成（最終選擇的分叉）。

有時會添加對消息傳送的部分支持，通過標准化所有工作鏈區塊中的消息格式和輸入和輸出消息隊列的位置（這在異構系統中尤其有用）。雖然這在某種程度上促進了消息傳遞，但在概念上與之前的情況沒有太大區別，所以這樣的系統仍然是「鬆散耦合」的。

相反，「緊密耦合」的系統包括特殊的機制，以提供所有區塊鏈之間的快速消息傳遞。期望的行為是能夠在生成源區塊鏈的區塊之後立即將消息遞送到另一個工作鏈。另一方面，「緊密耦合」的系統還應該在出現分叉的情況下維護整體的一致性。儘管這兩個要求乍看之下似乎是矛盾的，但我們相信TON Blockchain使用的機制（將shardchain區塊hash包含到masterchain區塊中；使用「垂直」區塊鏈來修復無效的區塊，參見~\ptref{sp:inv.sh.blk.corr}；超立方體路由，參見~\ptref{sp:hypercube}；即時超立方體路由，參見~\ptref{sp:instant.hypercube}）使其成為一個「緊密耦合」的系統，也許是迄今為止唯一的系統。

當然，建立一個「鬆散耦合」的系統要簡單得多；但是，快速和高效的分片（參見~\ptref{sp:shard.supp}）要求系統是「緊密耦合」的。

\nxsubpoint\label{sp:blkch.gen} \embt(Simplified
classification. Generations of blockchain projects.)  The
classification we have suggested so far splits all blockchain projects
into a large number of classes. However, the classification criteria
we use happen to be quite correlated in practice. This enables us to
suggest a simplified ``generational'' approach to the classification
of blockchain projects, as a very rough approximation of reality,
with some examples. Projects that have not been implemented and
deployed yet are shown in {\em italics}; the most important
characteristics of a generation are shown in {\bf bold}.
\begin{itemize}
\item First generation: Single-chain, {\bf PoW}, no support for smart
  contracts. Examples: Bitcoin (2009) and a lot of otherwise
  uninteresting imitators (Litecoin, Monero, \dots).
\item Second generation: Single-chain, PoW, {\bf smart-contract
  support}. Example: Ethereum (2013; deployed in 2015), at least in
  its original form.
\item Third generation: Single-chain, {\bf PoS}, smart-contract
  support. Example: {\em future Ethereum} (2018 or later).
\item Alternative third ($3'$) generation: {\bf Multi-chain}, PoS, no
  support for smart contracts, loosely-coupled. Example: Bitshares
  (2013--2014; uses DPOS).
\item Fourth generation: {\bf Multi-chain, PoS, smart-contract
  support}, loosely-coupled. Examples: {\em EOS\/} (2017; uses DPOS),
  {\em PolkaDot\/} (2016; uses BFT).
\item Fifth generation: Multi-chain, PoS with BFT, smart-contract
  support, {\bf tightly-coupled, with sharding}. Examples: {\em TON\/}
  (2017).
\end{itemize}
While not all blockchain projects fall precisely into one of these
categories, most of them do.

\nxsubpoint\label{sp:genome.change.never} \embt(Complications of
changing the ``genome'' of a blockchain project.)  The above
classification defines the ``genome'' of a blockchain project. This
genome is quite ``rigid'': it is almost impossible to change it once
the project is deployed and is used by a lot of people. One would need
a series of hard forks (which would require the approval of the
majority of the community), and even then the changes would need to be
very conservative in order to preserve backward compatibility (e.g.,
changing the semantics of the virtual machine might break existing
smart contracts). An alternative would be to create new ``sidechains''
with their different rules, and bind them somehow to the blockchain
(or the blockchains) of the original project. One might use the
blockchain of the existing single-blockchain project as an external
masterchain for an essentially new and separate project.\footnote{For
  example, the Plasma project plans to use the Ethereum blockchain as
  its (external) masterchain; it does not interact much with Ethereum
  otherwise, and it could have been suggested and implemented by a
  team unrelated to the Ethereum project.}

Our conclusion is that the genome of a project is very hard to change
once it has been deployed. Even starting with PoW and planning to
replace it with PoS in the future is quite complicated.\footnote{As of
  2017, Ethereum is still struggling to transition from PoW to a
  combined PoW+PoS system; we hope it will become a truly PoS system
  someday.} Adding shards to a project originally designed without
support for them seems almost impossible.\footnote{There are sharding
  proposals for Ethereum dating back to 2015; it is unclear how they
  might be implemented and deployed without disrupting Ethereum or
  creating an essentially independent parallel project.} In fact,
adding support for smart contracts into a project (namely, Bitcoin)
originally designed without support for such features has been deemed
impossible (or at least undesirable by the majority of the Bitcoin
community) and eventually led to the creation of a new blockchain
project, Ethereum.

\nxsubpoint \embt(Genome of the TON Blockchain.)  Therefore, if one
wants to build a scalable blockchain system, one must choose its
genome carefully from the very beginning. If the system is meant to
support some additional specific functionality in the future not known
at the time of its deployment, it should support ``heterogeneous''
workchains (having potentially different rules) from the start. For
the system to be truly scalable, it must support sharding from the
very beginning; sharding makes sense only if the system is
``tightly-coupled'' (cf.~\ptref{sp:blkch.interact}), so this in turn
implies the existence of a masterchain, a fast system of
inter-blockchain messaging, usage of BFT PoS, and so on.

When one takes into account all these implications, most of the design
choices made for the TON Blockchain project appear natural, and almost
the only ones possible.

\mysubsection{Comparison to Other Blockchain
  Projects}\label{sect:compare.blkch}

We conclude our brief discussion of the TON Blockchain and its most
important and unique features by trying to find a place for it on a
map containing existing and proposed blockchain projects. We use the
classification criteria described in~\ptref{sect:class.blkch} to
discuss different blockchain projects in a uniform way and construct
such a ``map of blockchain projects''. We represent this map as
Table~\ref{tab:blkch.proj}, and then briefly discuss a few projects
separately to point out their peculiarities that may not fit into the
general scheme.

\begin{table}
  \captionsetup{font=scriptsize}
  \begin{tabular}{|c|cc|ccc|ccc|}
    \hline Project & Year & G. & Cons. & Sm. & Ch. & R. & Sh. &
    Int. \\ \hline Bitcoin & 2009 & 1 & PoW & no & 1 \\ Ethereum &
    2013, 2015 & 2 & PoW & yes & 1 \\ NXT & 2014 & 2+ & PoS & no & 1
    \\ Tezos & 2017, ? & 2+ & PoS & yes & 1 \\ Casper & 2015, (2017) &
    3 & PoW/PoS & yes & 1 \\ \hline BitShares & 2013, 2014 & $3'$ &
    DPoS & no & m & ht. & no & L \\ EOS & 2016, (2018) & 4 & DPoS &
    yes & m & ht. & no & L \\ PolkaDot & 2016, (2019) & 4 & PoS BFT & yes &
    m & ht. & no & L \\ Cosmos & 2017, ?  & 4 & PoS BFT & yes & m &
    ht. & no & L \\ TON & 2017, (2018) & 5 & PoS BFT & yes & m & mix &
    dyn. & T \\ \hline
  \end{tabular}
  \caption{A summary of some notable blockchain projects. The columns
    are: {\em Project} -- project name; {\em Year} -- year announced
    and year deployed; {\em G.} -- generation
    (cf.~\ptref{sp:blkch.gen}); {\em Cons.} -- consensus algorithm
    (cf.~\ptref{sp:pow.pos} and~\ptref{sp:dpos.bft}); {\em Sm.} --
    support for arbitrary code (smart contracts;
    cf.~\ptref{sp:smartc.supp}); {\em Ch.} -- single/multiple
    blockchain system (cf.~\ptref{sp:single.multi}); {\em R.} --
    heterogeneous/homogeneous multichain systems
    (cf.~\ptref{sp:blkch.hom.het}); {\em Sh.} -- sharding support
    (cf.~\ptref{sp:shard.supp}); {\em Int.} -- interaction between
    blockchains, (L)oose or (T)ight (cf.~\ptref{sp:blkch.interact}).
  }\label{tab:blkch.proj}
\end{table}

\nxsubpoint \embt(Bitcoin \cite{BitcWP}; \url{https://bitcoin.org/}.)
            {\em Bitcoin\/} (2009) is the first and the most famous
            block\-chain project. It is a typical {\em
              first-generation} blockchain project: it is
            single-chain, it uses Proof-of-Work with a
            ``longest-fork-wins'' fork selection algorithm, and it
            does not have a Turing-complete scripting language
            (however, simple scripts without loops are supported). The
            Bitcoin blockchain has no notion of an account; it uses
            the UTXO (Unspent Transaction Output) model instead.

\nxsubpoint \embt(Ethereum \cite{EthWP}; \url{https://ethereum.org/}.)
            {\em Ethereum\/} (2015) is the first blockchain with
            support for Turing-complete smart contracts. As such, it
            is a typical {\em second-generation\/} project, and the
            most popular among them. It uses Proof-of-Work on a single
            blockchain, but has smart contracts and accounts.

\nxsubpoint \embt(NXT; \url{https://nxtplatform.org/}.)  {\em NXT\/}
(2014) is the first PoS-based blockchain and currency. It is still
single-chain, and has no smart contract support.

\nxsubpoint \embt(Tezos; \url{https://www.tezos.com/}.)  {\em Tezos\/}
(2018 or later) is a proposed PoS-based single-blockchain project. We
mention it here because of its unique feature: its block
interpretation function $\evblock$ (cf.~\ptref{sp:blk.transf}) is not
fixed, but is determined by an OCaml module, which can be upgraded by
committing a new version into the blockchain (and collecting some
votes for the proposed change). In this way, one will be able to
create custom single-chain projects by first deploying a ``vanilla''
Tezos blockchain, and then gradually changing the block interpretation
function in the desired direction, without any need for hard forks.

This idea, while intriguing, has the obvious drawback that it forbids
any optimized implementations in other languages like C++, so a
Tezos-based blockchain is destined to have lower performance. We think
that a similar result might have been obtained by publishing a formal
{\em specification\/} of the proposed block interpretation function
$\evtrans$, without fixing a particular {\em implementation}.

\nxsubpoint
\embt(Casper.)%
\footnote{\url{https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/}}
{\em Casper\/} is an upcoming PoS algorithm for Ethereum; its gradual
deployment in 2017 (or 2018), if successful, will change Ethereum into
a single-chain PoS or mixed PoW+PoS system with smart contract
support, transforming Ethereum into a {\em third-generation\/}
project.

\nxsubpoint \embt(BitShares \cite{BitShWP};
\url{https://bitshares.org}.)  {\em BitShares\/} (2014) is a platform
for distributed blockchain-based exchanges. It is a heterogeneous
multi-blockchain DPoS system without smart contracts; it achieves its
high performance by allowing only a small set of predefined
specialized transaction types, which can be efficiently implemented in
C++, assuming the blockchain state fits into memory. It is also the
first blockchain project to use Delegated Proof-of-Stake (DPoS),
demonstrating its viability at least for some specialized purposes.

\nxsubpoint\label{sp:discuss.EOS} \embt(EOS \cite{EOSWP};
\url{https://eos.io}.)  {\em EOS\/} (2018 or later) is a proposed
heterogeneous multi-blockchain DPoS system {\em with\/} smart contract
support and with some minimal support for messaging (still
loosely-coupled in the sense described
in~\ptref{sp:blkch.interact}). It is an attempt by the same team that
has previously successfully created the BitShares and SteemIt
projects, demonstrating the strong points of the DPoS consensus
algorithm. Scalability will be achieved by creating specialized
workchains for projects that need it (e.g., a distributed exchange
might use a workchain supporting a special set of optimized
transactions, similarly to what BitShares did) and by creating
multiple workchains with the same rules ({\em confederations\/} in the
sense described in~\ptref{sp:het.confed}). The drawbacks and
limitations of this approach to scalability have been discussed in
{\em loc.~cit.} Cf.\ also \ptref{sp:dpos.bft.compare},
\ptref{sp:shard.supp}, and \ptref{sp:blkch.interact} for a more
detailed discussion of DPoS, sharding, interaction between workchains
and their implications for the scalability of a blockchain system.

    At the same time, even if one will not be able to ``create a
    Facebook inside a blockchain''
    (cf.~\ptref{sp:blockchain.facebook}), EOS or otherwise, we think
    that EOS might become a convenient platform for some
    highly-specialized weakly interacting distributed applications,
    similar to BitShares (decentralized exchange) and SteemIt
    (decentralized blog platform).

\nxsubpoint\label{sp:discuss.PolkaDot} \embt(PolkaDot \cite{PolkaWP};
\url{https://polkadot.io/}.)  {\em PolkaDot\/} (2019 or later) is one
of the best thought-out and most detailed proposed multichain
Proof-of-Stake projects; its development is led by one of the
Ethereum co-founders. This project is one of the closest projects to
the TON Blockchain on our map. (In fact, we are indebted for our
terminology for ``fishermen'' and ``nominators'' to the PolkaDot
project.)

PolkaDot is a heterogeneous loosely-coupled multichain Proof-of-Stake
project, with Byzantine Fault Tolerant (BFT) consensus for generation
of new blocks and a masterchain (which might be external---e.g., the
Ethereum blockchain). It also uses hypercube routing, somewhat like
(the slow version of) TON's as described in~\ptref{sp:hypercube}.

Its unique feature is its ability to create not only {\em public}, but
also {\em private\/} blockchains. These private blockchains would also
be able to interact with other public blockchains, PolkaDot or
otherwise.

As such, PolkaDot might become a platform for large-scale {\em
  private\/} block\-chains, which might be used, for example, by bank
consortiums to quickly transfer funds to each other, or for any other
uses a large corporation might have for private blockchain technology.

However, PolkaDot has no sharding support and is not
tightly-coupled. This somewhat hampers its scalability, which is
similar to that of EOS. (Perhaps a bit better, because PolkaDot uses
BFT PoS instead of DPoS.)

\nxsubpoint \embt(Universa; \url{https://universa.io}.)  The only
reason we mention this unusual blockchain project here is because it
is the only project so far to make in passing an explicit reference to
something similar to our Infinite Sharding Paradigm
(cf.~\ptref{sp:ISP}). Its other peculiarity is that it bypasses all
complications related to Byzantine Fault Tolerance by promising that
only trusted and licensed partners of the project will be admitted as
validators, hence they will never commit invalid blocks. This is an
interesting decision; however, it essentially makes a blockchain
project deliberately {\em centralized}, something blockchain projects
usually want to avoid (why does one need a blockchain at all to work
in a trusted centralized environment?).

\nxsubpoint \embt(Plasma; \url{https://plasma.io}).)  {\em Plasma\/}
(2019?) is an unconventional blockchain project from another
co-founder of Ethereum. It is supposed to mitigate some limitations of
Ethereum without introducing sharding. In essence, it is a separate
project from Ethereum, introducing a hierarchy of (heterogeneous)
workchains, bound to the Ethereum blockchain (to be used as an
external masterchain) at the top level. Funds can be transferred from
any blockchain up in the hierarchy (starting from the Ethereum
blockchain as the root), along with a description of a job to be
done. Then the necessary computations are done in the child workchain
(possibly requiring forwarding of parts of the original job further
down the tree), their results are passed up, and a reward is
collected. The problem of achieving consistency and validating these
workchains is circumvented by a (payment channel-inspired) mechanism
allowing users to unilaterally withdraw their funds from a misbehaving
workchain to its parent workchain (albeit slowly), and re-allocate
their funds and their jobs to another workchain.

In this way, Plasma might become a platform for distributed
computations bound to the Ethereum blockchain, something like a
``mathematical co-processor''. However, this does not seem like a way
to achieve true general-purpose scalability.

\nxsubpoint \embt(Specialized blockchain projects.)  There are also
some specialized blockchain projects, such as FileCoin (a system that
incentivizes users to offer their disk space for storing the files of
other users who are willing to pay for it), Golem (a blockchain-based
platform for renting and lending computing power for specialized
applications such as 3D-rendering) or SONM (another similar computing
power-lending project). Such projects do not introduce anything
conceptually new on the level of blockchain organization; rather, they
are particular blockchain applications, which could be implemented by
smart contracts running in a general-purpose blockchain, provided it
can deliver the required performance. As such, projects of this kind
are likely to use one of the existing or planned blockchain projects
as their base, such as EOS, PolkaDot or TON. If a project needs
``true'' scalability (based on sharding), it would better use TON; if
it is content to work in a ``confederated'' context by defining a
family of workchains of its own, explicitly optimized for its purpose,
it might opt for EOS or PolkaDot.

\nxsubpoint \embt(The TON Blockchain.)  The TON (Telegram Open
Network) Block\-chain (planned 2018) is the project we are describing
in this document. It is designed to be the first fifth-generation
blockchain project---that is, a BFT PoS-multichain project, mixed
homogeneous/heterogeneous, with support for (shardable) custom
workchains, with native sharding support, and tightly-coupled (in
particular, capable of forwarding messages between shards almost
instantly while preserving a consistent state of all shardchains). As
such, it will be a truly scalable general-purpose blockchain project,
capable of accommodating essentially any applications that can be
implemented in a blockchain at all. When augmented by the other
components of the TON Project (cf.~\ptref{sect:ton.components}), its
possibilities expand even further.

\nxsubpoint\label{sp:blockchain.facebook} \embtx(Is it possible to
``upload Facebook into a blockchain''?)  Sometimes people claim that
it will be possible to implement a social network on the scale of
Facebook as a distributed application residing in a
blockchain. Usually a favorite blockchain project is cited as a
possible ``host'' for such an application.

We cannot say that this is a technical impossibility. Of course, one
needs a tightly-coupled blockchain project with true sharding (i.e.,
TON) in order for such a large application not to work too slowly
(e.g., deliver messages and updates from users residing in one
shardchain to their friends residing in another shardchain with
reasonable delays). However, we think that this is not needed and will
never be done, because the price would be prohibitive.

Let us consider ``uploading Facebook into a blockchain'' as a thought
experiment; any other project of similar scale might serve as an
example as well. Once Facebook is uploaded into a blockchain, all
operations currently done by Facebook's servers will be serialized as
transactions in certain blockchains (e.g., TON's shardchains), and
will be performed by all validators of these blockchains. Each
operation will have to be performed, say, at least twenty times, if we
expect every block to collect at least twenty validator signatures
(immediately or eventually, as in DPOS systems). Similarly, all data
kept by Facebook's servers on their disks will be kept on the disks of
all validators for the corresponding shardchain (i.e., in at least
twenty copies).

Because the validators are essentially the same servers (or perhaps
clusters of servers, but this does not affect the validity of this
argument) as those currently used by Facebook, we see that the total
hardware expenses associated with running Facebook in a blockchain are
at least twenty times higher than if it were implemented in the
conventional way.

In fact, the expenses would be much higher still, because the
blockchain's virtual machine is slower than the ``bare CPU'' running
optimized compiled code, and its storage is not optimized for
Facebook-specific problems. One might partially mitigate this problem
by crafting a specific workchain with some special transactions
adapted for Facebook; this is the approach of BitShares and EOS to
achieving high performance, available in the TON Blockchain as
well. However, the general blockchain design would still impose some
additional restrictions by itself, such as the necessity to register
all operations as transactions in a block, to organize these
transactions in a Merkle tree, to compute and check their Merkle
hashes, to propagate this block further, and so on.

Therefore, a conservative estimate is that one would need 100 times
more servers of the same performance as those used by Facebook now in
order to validate a blockchain project hosting a social network of
that scale. Somebody will have to pay for these servers, either the
company owning the distributed application (imagine seeing 700 ads on
each Facebook page instead of 7) or its users. Either way, this does
not seem economically viable.

We believe that {\em it is not true that everything should be uploaded
  into the blockchain}. For example, it is not necessary to keep user
photographs in the blockchain; registering the hashes of these
photographs in the blockchain and keeping the photographs in a
distributed off-chain storage (such as FileCoin or TON Storage) would
be a better idea. This is the reason why TON is not just a blockchain
project, but a collection of several components (TON P2P Network, TON
Storage, TON Services) centered around the TON Blockchain as outlined
in Chapters~\ptref{sect:ton.components} and~\ptref{sect:services}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%                  NETWORK
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\mysection{TON Networking}\label{sect:network}

Any blockchain project requires not only a specification of block
format and blockchain validation rules, but also a network protocol
used to propagate new blocks, send and collect transaction candidates
and so on. In other words, a specialized peer-to-peer network must be
set up by every blockchain project. This network must be peer-to-peer,
because blockchain projects are normally expected to be decentralized,
so one cannot rely on a centralized group of servers and use
conventional client-server architecture, as, for instance, classical
online banking applications do. Even light clients (e.g., light
cryptocurrency wallet smartphone applications), which must connect to
full nodes in a client-server--like fashion, are actually free to
connect to another full node if their previous peer goes down,
provided the protocol used to connect to full nodes is standardized
enough.

While the networking demands of single-blockchain projects, such as
Bitcoin or Ethereum, can be met quite easily (one essentially needs to
construct a ``random'' peer-to-peer overlay network, and propagate all
new blocks and transaction candidates by a gossip protocol),
multi-blockchain projects, such as the TON Blockchain, are much more
demanding (e.g., one must be able to subscribe to updates of only some
shardchains, not necessarily all of them). Therefore, the networking
part of the TON Blockchain and the TON Project as a whole merits at
least a brief discussion.

On the other hand, once the more sophisticated network protocols
needed to support the TON Blockchain are in place, it turns out that
they can easily be used for purposes not necessarily related to the
immediate demands of the TON Blockchain, thus providing more
possibilities and flexibility for creating new services in the TON
ecosystem.

\mysubsection{Abstract Datagram Network Layer}\label{sect:ANL}

The cornerstone in building the TON networking protocols is the {\em
  (TON) Abstract (Datagram) Network Layer}. It enables all nodes to
assume certain ``network identities'', represented by 256-bit
``abstract network addresses'', and communicate (send datagrams to
each other, as a first step) using only these 256-bit network
addresses to identify the sender and the receiver. In particular, one
does not need to worry about IPv4 or IPv6 addresses, UDP port numbers,
and the like; they are hidden by the Abstract Network Layer.

\nxsubpoint\label{sp:abs.addr} \embt(Abstract network addresses.)
An {\em abstract network address}, or an {\em abstract address}, or
just {\em address\/} for short, is a 256-bit integer, essentially
equal to a 256-bit ECC public key. This public key can be generated
arbitrarily, thus creating as many different network identities as the
node likes. However, one must know the corresponding {\em private\/}
key in order to receive (and decrypt) messages intended for such an
address.

In fact, the address is {\em not\/} the public key itself; instead, it
is a 256-bit hash ($\Hash=\Sha$) of a serialized TL-object
(cf.~\ptref{sp:TL}) that can describe several types of public keys and
addresses depending on its constructor (first four bytes). In the
simplest case, this serialized TL-object consists just of a 4-byte
magic number and a 256-bit elliptic curve cryptography (ECC) public
key; in this case, the address will equal the hash of this 36-byte
structure. One might use, however, 2048-bit RSA keys, or any other
scheme of public-key cryptography instead.

When a node learns another node's abstract address, it must also
receive its ``preimage'' (i.e., the serialized TL-object, the hash of
which equals that abstract address) or else it will not be able to
encrypt and send datagrams to that address.

\nxsubpoint \embt(Lower-level networks. UDP implementation.)  From the
perspective of almost all TON Networking components, the only thing
that exists is a network (the Abstract Datagram Networking Layer) able
to (unreliably) send datagrams from one abstract address to
another. In principle, the Abstract Datagram Networking Layer (ADNL)
can be implemented over different existing network
technologies. However, we are going to implement it over UDP in
IPv4/IPv6 networks (such as the Internet or intranets), with an
optional TCP fallback if UDP is not available.

\nxsubpoint\label{sp:net.simple.dg} \embt(Simplest case of ADNL over
UDP.)  The simplest case of sending a datagram from a sender's
abstract address to any other abstract address (with known preimage)
can be implemented as follows.

Suppose that the sender somehow knows the IP-address and the UDP port
of the receiver who owns the destination abstract address, and that
both the receiver and the sender use abstract addresses derived from
256-bit ECC public keys.

In this case, the sender simply augments the datagram to be sent by
its ECC signature (done with its private key) and its source address
(or the preimage of the source address, if the receiver is not known
to know that preimage yet). The result is encrypted with the
recipient's public key, embedded into a UDP datagram and sent to the
known IP and port of the recipient. Because the first 256 bits of the
UDP datagram contain the recipient's abstract address, the recipient
can identify which private key should be used to decrypt the remainder
of the datagram. Only after that is the sender's identity revealed.

\nxsubpoint\label{sp:net.simplest.dg} \embt(Less secure way, with the
sender's address in plaintext.)  Sometimes a less secure scheme is
sufficient, when the recipient's and the sender's addresses are kept
in plaintext in the UDP datagram; the sender's private key and the
recipient's public key are combined together using ECDH (Elliptic
Curve Diffie--Hellman) to generate a 256-bit shared secret, which is
used afterwards, along with a random 256-bit nonce also included in
the unencrypted part, to derive AES keys used for encryption. The
integrity may be provided, for instance, by concatenating the hash of
the original plaintext data to the plaintext before encryption.

This approach has the advantage that, if more than one datagram is
expected to be exchanged between the two addresses, the shared secret
can be computed only once and then cached; then slower elliptic curve
operations will no longer be required for encrypting or decrypting the
next datagrams.

\nxsubpoint\label{sp:net.channels} \embt(Channels and channel
identifiers.)  In the simplest case, the first 256 bits of a UDP
datagram carrying an embedded TON ADNL datagram will be equal to the
recipient's address. However, in general they constitute a {\em
  channel identifier}. There are different types of channels. Some of
them are point-to-point; they are created by two parties who wish to
exchange a lot of data in the future and generate a shared secret by
exchanging several packets encrypted as described
in~\ptref{sp:net.simple.dg} or~\ptref{sp:net.simplest.dg}, by running
classical or elliptic curve Diffie--Hellman (if extra security is
required), or simply by one party generating a random shared secret
and sending it to the other party.

After that, a channel identifier is derived from the shared secret
combined with some additional data (such as the sender's and
recipient's addresses), for instance by hashing, and that identifier
is used as the first 256 bits of UDP datagrams carrying data encrypted
with the aid of that shared secret.

\nxsubpoint\label{sp:tunnels} \embt(Channel as a tunnel identifier.)
In general, a ``channel'', or ``channel identifier'' simply selects a
way of processing an inbound UDP datagram, known to the receiver. If
the channel is the receiver's abstract address, the processing is done
as outlined in~\ptref{sp:net.simple.dg} or \ptref{sp:net.simplest.dg};
if the channel is an established point-to-point channel discussed
in~\ptref{sp:net.channels}, the processing consists in decrypting the
datagram with the aid of the shared secret as explained in {\em
  loc.~cit.}, and so on.

In particular, a channel identifier can actually select a ``tunnel'',
when the immediate recipient simply forwards the received message to
somebody else---the actual recipient or another proxy. Some encryption
or decryption steps (reminiscent of ``onion routing'' \cite{Onion} or
even ``garlic
routing''\footnote{\url{https://geti2p.net/en/docs/how/garlic-routing}})
might be done along the way, and another channel identifier might be
used for re-encrypted forwarded packets (for example, a peer-to-peer
channel could be employed to forward the packet to the next recipient
on the path).

In this way, some support for ``tunneling'' and
``proxying''---somewhat similar to that provided by the TOR or $I^2P$
projects---can be added on the level of the TON Abstract Datagram
Network Layer, without affecting the functionality of all higher-level
TON network protocols, which would be agnostic of such an
addition. This opportunity is exploited by the {\em TON Proxy\/}
service (cf.~\ptref{sp:ex.ton.proxy}).

\nxsubpoint\label{sp:net.startup} \embt(Zero channel and the bootstrap
problem.)  Normally, a TON ADNL node will have some ``neighbor
table'', containing information about other known nodes, such as their
abstract addresses and their preimages (i.e., public keys) and their
IP addresses and UDP ports. Then it will gradually extend this table
by using information learned from these known nodes as answers to
special queries, and sometimes prune obsolete records.

However, when a TON ADNL node just starts up, it may happen that it
does not know any other node, and can learn only the IP address and
UDP port of a node, but not its abstract address. This happens, for
example, if a light client is not able to access any of the previously
cached nodes and any nodes hardcoded into the software, and must ask
the user to enter an IP address or a DNS domain of a node, to be
resolved through DNS.

In this case, the node will send packets to a special ``zero channel''
of the node in question. This does not require knowledge of the
recipient's public key (but the message should still contain the
sender's identity and signature), so the message is transferred
without encryption.  It should be normally used only to obtain an
identity (maybe a one-time identity created especially for this
purpose) of the receiver, and then to start communicating in a safer
way.

Once at least one node is known, it is easy to populate the ``neighbor
table'' and ``routing table'' by more entries, learning them from
answers to special queries sent to the already known nodes.

Not all nodes are required to process datagrams sent to the zero
channel, but those used to bootstrap light clients should support this
feature.

\nxsubpoint \embt(TCP-like stream protocol over ADNL.)  The ADNL,
being an unreliable (small-size) datagram protocol based on 256-bit
abstract addresses, can be used as a base for more sophisticated
network protocols. One can build, for example, a TCP-like stream
protocol, using ADNL as an abstract replacement for IP. However, most
components of the TON Project do not need such a stream protocol.

\nxsubpoint\label{sp:RLDP} \embt(RLDP, or Reliable Large Datagram
Protocol over ADNL.)  A reliable arbitrary-size datagram protocol
built upon the ADNL, called RLDP, is used instead of a TCP-like
protocol. This reliable datagram protocol can be employed, for
instance, to send RPC queries to remote hosts and receive answers from
them (cf.~\ptref{sp:pure.net.serv}).

\mysubsection{TON DHT: Kademlia-like Distributed Hash
  Table}\label{sect:kademlia}

The {\em TON Distributed Hash Table (DHT)\/} plays a crucial role in
the networking part of the TON Project, being used to locate other
nodes in the network. For example, a client wanting to commit a
transaction into a shardchain might want to find a validator or a
collator of that shardchain, or at least some node that might relay
the client's transaction to a collator. This can be done by looking up
a special key in the TON DHT. Another important application of the TON
DHT is that it can be used to quickly populate a new node's neighbor
table (cf.~\ptref{sp:net.startup}), simply by looking up a random key,
or the new node's address. If a node uses proxying and tunneling for
its inbound datagrams, it publishes the tunnel identifier and its
entry point (e.g., IP address and UDP port) in the TON DHT; then all
nodes wishing to send datagrams to that node will obtain this contact
information from the DHT first.

The TON DHT is a member of the family of {\em Kademlia-like distributed
  hash tables\/}~\cite{Kademlia}.

\nxsubpoint \embt(Keys of the TON DHT.)  The {\em keys\/} of the TON
DHT are simply 256-bit integers. In most cases, they are computed as
$\Sha$ of a TL-serialized object (cf.~\ptref{sp:TL}), called {\em
  preimage\/} of the key, or {\em key description}. In some cases, the
abstract addresses of the TON Network nodes (cf.~\ptref{sp:abs.addr})
can also be used as keys of the TON DHT, because they are also
256-bit, and they are also hashes of TL-serialized objects. For
example, if a node is not afraid of publishing its IP address, it can
be found by anybody who knows its abstract address by simply looking
up that address as a key in the DHT.

\nxsubpoint \embt(Values of the DHT.)  The {\em values\/} assigned to
these 256-bit keys are essentially arbitrary byte strings of limited
length. The interpretation of such byte strings is determined by the
preimage of the corresponding key; it is usually known both by the
node that looks up the key, and by the node that stores the key.

\nxsubpoint \embt(Nodes of the DHT. Semi-permanent network
identities.)  The key-value mapping of the TON DHT is kept on the {\em
  nodes\/} of the DHT---essentially, all members of the TON
Network. To this end, any node of the TON Network (perhaps with the
exception of some very light nodes), apart from any number of
ephemeral and permanent abstract addresses described
in~\ptref{sp:abs.addr}, has at least one ``semi-permanent address'',
which identifies it as a member of the TON DHT. This {\em
  semi-permanent\/} or {\em DHT address\/} should not to be changed
too often, otherwise other nodes would be unable to locate the keys
they are looking for. If a node does not want to reveal its ``true''
identity, it generates a separate abstract address to be used only for
the purpose of participating in the DHT. However, this abstract
address must be public, because it will be associated with the node's
IP address and port.

\nxsubpoint \embt(Kademlia distance.)  Now we have both 256-bit keys
and 256-bit (semi-permanent) node addresses. We introduce the
so-called {\em XOR distance\/} or {\em Kademlia distance~$d_K$} on the
set of 256-bit sequences, given by
\begin{equation}
  d_K(x,y):=(x\oplus y)\quad\text{interpreted as an unsigned 256-bit
    integer}
\end{equation}
Here $x\oplus y$ denotes the bitwise eXclusive OR (XOR) of two bit
sequences of the same length.

The Kademlia distance introduces a metric on the set $\st2^{256}$ of
all 256-bit sequences. In particular, we have $d_K(x,y)=0$ if and only
if $x=y$, $d_K(x,y)=d_K(y,x)$, and $d_K(x,z)\leq
d_K(x,y)+d_K(y,z)$. Another important property is that {\em there is
  only one point at any given distance from~$x$}: $d_K(x,y)=d_K(x,y')$
implies $y=y'$.

\nxsubpoint \embt(Kademlia-like DHTs and the TON DHT.)  We say that a
distributed hash table (DHT) with 256-bit keys and 256-bit node
addresses is a {\em Kademlia-like DHT\/} if it is expected to keep the
value of key $K$ on $s$ Kademlia-nearest nodes to $K$ (i.e., the $s$
nodes with smallest Kademlia distance from their addresses to $K$.)

Here $s$ is a small parameter, say, $s=7$, needed to improve
reliability of the DHT (if we would keep the key only on one node, the
nearest one to~$K$, the value of that key would be lost if that only
node goes offline).

The TON DHT is a Kademlia-like DHT, according to this definition. It
is implemented over the ADNL protocol described in~\ptref{sect:ANL}.

\nxsubpoint \embt(Kademlia routing table.)  Any node participating in
a Kademlia-like DHT usually maintains a {\em Kademlia routing
  table}. In the case of TON DHT, it consists of $n=256$ buckets,
numbered from $0$ to $n-1$. The $i$-th bucket will contain information
about some known nodes (a fixed number $t$ of ``best'' nodes, and
maybe some extra candidates) that lie at a Kademlia distance from
$2^i$ to $2^{i+1}-1$ from the node's address $a$.\footnote{If there
  are sufficiently many nodes in a bucket, it can be subdivided
  further into, say, eight sub-buckets depending on the top four bits
  of the Kademlia distance. This would speed up DHT lookups.} This
information includes their (semi-permanent) addresses, IP addresses
and UDP ports, and some availability information such as the time and
the delay of the last ping.

When a Kademlia node learns about any other Kademlia node as a result
of some query, it includes it into a suitable bucket of its routing
table, first as a candidate. Then, if some of the ``best'' nodes in
that bucket fail (e.g., do not respond to ping queries for a long
time), they can be replaced by some of the candidates. In this way the
Kademlia routing table stays populated.

New nodes from the Kademlia routing table are also included in the
ADNL neighbor table described in~\ptref{sp:net.startup}. If a ``best''
node from a bucket of the Kademlia routing table is used often, a
channel in the sense described in~\ptref{sp:net.channels} can be
established to facilitate the encryption of datagrams.

A special feature of the TON DHT is that it tries to select nodes with
the smallest round-trip delays as the ``best'' nodes for the buckets
of the Kademlia routing table.

\nxsubpoint (Kademlia network queries.)  A Kademlia node usually
supports the following network queries:
\begin{itemize}
\item $\Ping$ -- Checks node availability.
\item $\Store(key,value)$ -- Asks the node to keep $value$ as a value
  for key $key$. For TON DHT, the $\Store$ queries are slightly more
  complicated (cf.~\ptref{sp:DHT.store}).
\item $\FindNode(key,l)$ -- Asks the node to return $l$
  Kademlia-nearest known nodes (from its Kademlia routing table) to
  $key$.
\item $\FindValue(key,l)$ -- The same as above, but if the node knows
  the value corresponding to key $key$, it just returns that value.
\end{itemize}

When any node wants to look up the value of a key $K$, it first
creates a set $S$ of $s'$ nodes (for some small value of $s'$, say,
$s'=5$), nearest to $K$ with respect to the Kademlia distance among
all known nodes (i.e., they are taken from the Kademlia routing
table). Then a $\FindValue$ query is sent to each of them, and nodes
mentioned in their answers are included in $S$. Then the $s'$ nodes
from $S$, nearest to $K$, are also sent a $\FindValue$ query if this
hasn't been done before, and the process continues until the value is
found or the set $S$ stops growing. This is a sort of ``beam search''
of the node nearest to $K$ with respect to Kademlia distance.

If the value of some key $K$ is to be set, the same procedure is run
for $s'\geq s$, with $\FindNode$ queries instead of $\FindValue$, to
find $s$ nearest nodes to $K$. Afterwards, $\Store$ queries are sent
to all of them.

There are some less important details in the implementation of a
Kademlia-like DHT (for example, any node should look up $s$ nearest
nodes to itself, say, once every hour, and re-publish all stored keys
to them by means of $\Store$ queries). We will ignore them for the
time being.

\nxsubpoint \embt(Booting a Kademlia node.)  When a Kademlia node goes
online, it first populates its Kademlia routing table by looking up
its own address. During this process, it identifies the $s$ nearest
nodes to itself. It can download from them all $(key,value)$ pairs
known to them to populate its part of the DHT.

\nxsubpoint\label{sp:DHT.store} \embt(Storing values in TON DHT.)
Storing values in TON DHT is slightly different from a general
Kademlia-like DHT. When someone wishes to store a value, she must
provide not only the key $K$ itself to the $\Store$ query, but also
its {\em preimage\/}---i.e., a TL-serialized string (with one of
several predefined TL-constructors at the beginning) containing a
``description'' of the key. This key description is later kept by the
node, along with the key and the value.

The key description describes the ``type'' of the object being stored,
its ``owner'', and its ``update rules'' in case of future updates. The
owner is usually identified by a public key included in the key
description. If it is included, normally only updates signed by the
corresponding private key will be accepted. The ``type'' of the stored
object is normally just a byte string. However, in some cases it can
be more sophisticated---for example, an input tunnel description
(cf.~\ptref{sp:tunnels}), or a collection of node addresses.

The ``update rules'' can also be different. In some cases, they simply
permit replacing the old value with the new value, provided the new
value is signed by the owner (the signature must be kept as part of
the value, to be checked later by any other nodes after they obtain
the value of this key). In other cases, the old value somehow affects
the new value. For example, it can contain a sequence number, and the
old value is overwritten only if the new sequence number is larger (to
prevent replay attacks).

\nxsubpoint\label{sp:distr.torr.tr} \embt(Distributed ``torrent
trackers'' and ``network interest groups'' in TON DHT.)  Yet another
interesting case is when the value contains a list of nodes---perhaps
with their IP addresses and ports, or just with their abstract
addresses---and the ``update rule'' consists in including the
requester in this list, provided she can confirm her identity.

This mechanism might be used to create a distributed ``torrent
tracker'', where all nodes interested in a certain ``torrent'' (i.e.,
a certain file) can find other nodes that are interested in the same
torrent, or already have a copy.

{\em TON Storage\/} (cf.~\ptref{sp:ex.ton.storage}) uses this
technology to find the nodes that have a copy of a required file
(e.g., a snapshot of the state of a shardchain, or an old
block). However, its more important use is to create ``overlay
multicast subnetworks'' and ``network interest groups''
(cf.~\ptref{sect:overlay}). The idea is that only some nodes are
interested in the updates of a specific shardchain. If the number of
shardchains becomes very large, finding even one node interested in
the same shard may become complicated. This ``distributed torrent
tracker'' provides a convenient way to find some of these
nodes. Another option would be to request them from a validator, but
this would not be a scalable approach, and validators might choose not
to respond to such queries coming from arbitrary unknown nodes.

\nxsubpoint \embt(Fall-back keys.)  Most of the ``key types''
described so far have an extra 32-bit integer field in their TL
description, normally equal to zero. However, if the key obtained by
hashing that description cannot be retrieved from or updated in the
TON DHT, the value in this field is increased, and a new attempt is
made. In this way, one cannot ``capture'' and ``censor'' a key (i.e.,
perform a key retention attack) by creating a lot of abstract
addresses lying near the key under attack and controlling the
corresponding DHT nodes.

\nxsubpoint\label{sp:loc.serv} \embt(Locating services.)  Some
services, located in the TON Network and available through the
(higher-level protocols built upon the) TON ADNL described
in~\ptref{sect:ANL}, may want to publish their abstract addresses
somewhere, so that their clients would know where to find them.

However, publishing the service's abstract address in the TON
Blockchain may not be the best approach, because the abstract address
might need to be changed quite often, and because it could make sense
to provide several addresses, for reliability or load balancing
purposes.

An alternative is to publish a public key into the TON Blockchain, and
use a special DHT key indicating that public key as its ``owner'' in
the TL description string (cf.~\ptref{sp:TL}) to publish an up-to-date
list of the service's abstract addresses. This is one of the
approaches exploited by TON Services.

\nxsubpoint \embt(Locating owners of TON blockchain accounts.)  In
most cases, owners of TON blockchain accounts would not like to be
associated with abstract network addresses, and especially IP
addresses, because this can violate their privacy. In some cases,
however, the owner of a TON blockchain account may want to publish
one or several abstract addresses where she could be contacted.

A typical case is that of a node in the TON Payments ``lightning
network'' (cf.~\ptref{sect:lightning}), the platform for instant
cryptocurrency transfers. A public TON Payments node may want not only
to establish payment channels with other peers, but also to publish an
abstract network address that could be used to contact it at a later
time for transferring payments along the already-established channels.

One option would be to include an abstract network address in the
smart contract creating the payment channel. A more flexible option is
to include a public key in the smart contract, and then use DHT as
explained in~\ptref{sp:loc.serv}.

The most natural way would be to use the same private key that
controls the account in the TON Blockchain to sign and publish updates
in the TON DHT about the abstract addresses associated with that
account. This is done almost in the same way as described
in~\ptref{sp:loc.serv}; however, the DHT key employed would require a
special key description, containing only the $\accountid$ itself,
equal to $\Sha$ of the ``account description'', which contains the
public key of the account. The signature, included in the value of
this DHT key, would contain the account description as well.

In this way, a mechanism for locating abstract network addresses of
some owners of the TON Blockchain accounts becomes available.

\nxsubpoint\label{sp:loc.abs.addr} \embt(Locating abstract addresses.)
Notice that the TON DHT, while being implemented over TON ADNL, is
itself used by the TON ADNL for several purposes.

The most important of them is to locate a node or its contact data
starting from its 256-bit abstract address. This is necessary because
the TON ADNL should be able to send datagrams to arbitrary 256-bit
abstract addresses, even if no additional information is provided.

To this end, the 256-bit abstract address is simply looked up as a key
in the DHT. Either a node with this address (i.e., using this address
as a public semi-persistent DHT address) is found, in which case its
IP address and port can be learned; or, an input tunnel description
may be retrieved as the value of the key in question, signed by the
correct private key, in which case this tunnel description would be
used to send ADNL datagrams to the intended recipient.

Notice that in order to make an abstract address ``public'' (reachable
from any nodes in the network), its owner must either use it as a
semi-permanent DHT address, or publish (in the DHT key equal to the
abstract address under consideration) an input tunnel description with
another of its public abstract addresses (e.g., the semi-permanent
address) as the tunnel's entry point. Another option would be to
simply publish its IP address and UDP port.

\mysubsection{Overlay Networks and Multicasting
  Messages}\label{sect:overlay}

In a multi-blockchain system like the TON Blockchain, even full nodes
would normally be interested in obtaining updates (i.e., new blocks)
only about some shardchains. To this end, a special overlay
(sub)network must be built inside the TON Network, on top of the ADNL
protocol discussed in~\ptref{sect:ANL}, one for each shardchain.

Therefore, the need to build arbitrary overlay subnetworks, open to
any nodes willing to participate, arises. Special gossip protocols,
built upon ADNL, will be run in these overlay networks. In particular,
these gossip protocols may be used to propagate (broadcast) arbitrary
data inside such a subnetwork.

\nxsubpoint \embt(Overlay networks.)  An {\em overlay (sub)network\/}
is simply a (virtual) network implemented inside some larger
network. Usually only some nodes of the larger network participate in
the overlay subnetwork, and only some ``links'' between these nodes,
physical or virtual, are part of the overlay subnetwork.

In this way, if the encompassing network is represented as a graph
(perhaps a full graph in the case of a datagram network such as ADNL,
where any node can easily communicate to any other), the overlay
subnetwork is a {\em subgraph\/} of this graph.

In most cases, the overlay network is implemented using some protocol
built upon the network protocol of the larger network. It may use the
same addresses as the larger network, or use custom addresses.

\nxsubpoint\label{sp:ton.overlays} \embt(Overlay networks in TON.)
Overlay networks in TON are built upon the ADNL protocol discussed
in~\ptref{sect:ANL}; they use 256-bit ADNL abstract addresses as
addresses in the overlay networks as well. Each node usually selects
one of its abstract addresses to double as its address in the overlay
network.

In contrast to ADNL, the TON overlay networks usually do not support
sending datagrams to arbitrary other nodes. Instead, some
``semipermanent links'' are established between some nodes (called
``neighbors'' with respect to the overlay network under
consideration), and messages are usually forwarded along these links
(i.e., from a node to one of its neighbors). In this way, a TON
overlay network is a (usually not full) subgraph inside the (full)
graph of the ADNL network.

Links to neighbors in TON overlay networks can be implemented using
dedicated peer-to-peer ADNL channels (cf.~\ptref{sp:net.channels}).

Each node of an overlay network maintains a list of neighbors (with
respect to the overlay network), containing their abstract addresses
(which they use to identify them in the overlay network) and some link
data (e.g., the ADNL channel used to communicate with them).

\nxsubpoint \embt(Private and public overlay networks.)  Some overlay
networks are {\em public}, meaning that any node can join them at
will. Other are {\em private}, meaning that only certain nodes can be
admitted (e.g., those that can prove their identities as validators.)
Some private overlay networks can even be unknown to the ``general
public''. The information about such overlay networks is made
available only to certain trusted nodes; for example, it can be
encrypted with a public key, and only nodes having a copy of the
corresponding private key will be able to decrypt this information.

\nxsubpoint \embt(Centrally controlled overlay networks.)  Some
overlay networks are {\em centrally controlled}, by one or several
nodes, or by the owner of some widely-known public key. Others are
{\em decentralized}, meaning that there are no specific nodes
responsible for them.

\nxsubpoint \embt(Joining an overlay network.)  When a node wants to
join an overlay network, it first must learn its 256-bit {\em network
  identifier}, usually equal to $\Sha$ of the {\em description\/} of
the overlay network---a TL-serialized object (cf.~\ptref{sp:TL}) which
may contain, for instance, the central authority of the overlay
network (i.e., its public key and perhaps its abstract
address,\footnote{Alternatively, the abstract address might be stored
  in the DHT as explained in~\ptref{sp:loc.serv}.}) a string with the
name of the overlay network, a TON Blockchain shard identifier if this
is an overlay network related to that shard, and so on.

Sometimes it is possible to recover the overlay network description
starting from the network identifier, simply by looking it up in the
TON DHT. In other cases (e.g., for private overlay networks), one must
obtain the network description along with the network identifier.

\nxsubpoint\label{sp:loc.1.mem} \embt(Locating one member of the
overlay network.)  After a node learns the network identifier and the
network description of the overlay network it wants to join, it must
locate at least one node belonging to that network.

This is also needed for nodes that do not want to join the overlay
network, but want just to communicate with it; for example, there
might be an overlay network dedicated to collecting and propagating
transaction candidates for a specific shardchain, and a client might
want to connect to any node of this network to suggest a transaction.

The method used for locating members of an overlay network is defined
in the description of that network. Sometimes (especially for private
networks) one must already know a member node to be able to join. In
other cases, the abstract addresses of some nodes are contained in the
network description. A more flexible approach is to indicate in the
network description only the central authority responsible for the
network, and then the abstract addresses will be available through
values of certain DHT keys, signed by that central authority.

Finally, truly decentralized public overlay networks can use the
``distributed torrent-tracker'' mechanism described
in~\ptref{sp:distr.torr.tr}, also implemented with the aid of the TON
DHT.

\nxsubpoint\label{sp:loc.many.mem} \embt(Locating more members of the
overlay network. Creating links.)  Once one node of the overlay
network is found, a special query may be sent to that node requesting
a list of other members, for instance, neighbors of the node being
queried, or a random selection thereof.

This enables the joining member to populate her ``adjacency'' or
``neighbor list'' with respect to the overlay network, by selecting
some newly-learned network nodes and establishing links to them (i.e.,
dedicated ADNL point-to-point channels, as outlined
in~\ptref{sp:ton.overlays}). After that, special messages are sent to
all neighbors indicating that the new member is ready to work in the
overlay network. The neighbors include their links to the new member
in their neighbor lists.

\nxsubpoint\label{sp:rand.mem} \embt(Maintaining the neighbor list.)
An overlay network node must update its neighbor list from time to
time. Some neighbors, or at least links (channels) to them, may stop
responding; in this case, these links must be marked as ``suspended'',
some attempts to reconnect to such neighbors must be made, and, if
these attempts fail, the links must be destroyed.

On the other hand, every node sometimes requests from a randomly
chosen neighbor its list of neighbors (or some random selection
thereof), and uses it to partially update its own neighbor list, by
adding some newly-discovered nodes to it, and removing some of the old
ones, either randomly or depending on their response times and
datagram loss statistics.

\nxsubpoint \embt(The overlay network is a random subgraph.)  In this
way, the overlay network becomes a random subgraph inside the ADNL
network. If the degree of each vertex is at least three (i.e., if each
node is connected to at least three neighbors), this random graph is
known to be {\em connected\/} with a probability almost equal to
one. More precisely, the probability of a random graph with $n$
vertices being {\em dis\/}connected is exponentially small, and this
probability can be completely neglected if, say, $n\geq20$. (Of
course, this does not apply in the case of a global network partition,
when nodes on different sides of the partition have no chance to learn
about each other.) On the other hand, if $n$ is smaller than 20, it
would suffice to require each vertex to have, say, at least ten
neighbors.

\nxsubpoint\label{sp:ov.opt.low.lat} \embt(TON overlay networks are
optimized for lower latency.)  TON overlay networks optimize the
``random'' network graph generated by the previous method as
follows. Every node tries to retain at least three neighbors with the
minimal round-trip time, changing this list of ``fast neighbors'' very
rarely. At the same time, it also has at least three other ``slow
neighbors'' that are chosen completely randomly, so that the overlay
network graph would always contain a random subgraph. This is required
to maintain connectivity and prevent splitting of the overlay network
into several unconnected regional subnetworks. At least three
``intermediate neighbors'', which have intermediate round-trip times,
bounded by a certain constant (actually, a function of the round-trip
times of the fast and the slow neighbors), are also chosen and
retained.

In this way, the graph of an overlay network still maintains enough
randomness to be connected, but is optimized for lower latency and
higher throughput.

\nxsubpoint \embt(Gossip protocols in an overlay network.)  An overlay
network is often used to run one of the so-called {\em gossip
  protocols}, which achieve some global goal while letting every node
interact only with its neighbors. For example, there are gossip
protocols to construct an approximate list of all members of a (not
too large) overlay network, or to compute an estimate of the number of
members of an (arbitrarily large) overlay network, using only a
bounded amount of memory at each node (cf.~\cite[4.4.3]{DistrSys} or
\cite{Birman} for details).

\nxsubpoint \embt(Overlay network as a broadcast domain.)  The most
important gossip protocol running in an overlay network is the {\em
  broadcast protocol}, intended to propagate broadcast messages
generated by any node of the network, or perhaps by one of the
designated sender nodes, to all other nodes.

There are in fact several broadcast protocols, optimized for different
use cases. The simplest of them receives new broadcast messages and
relays them to all neighbors that have not yet sent a copy of that
message themselves.

\nxsubpoint \embt(More sophisticated broadcast protocols.)  Some
applications may warrant more sophisticated broadcast protocols. For
instance, for broadcasting messages of substantial size, it makes
sense to send to the neighbors not the newly-received message itself,
but its hash (or a collection of hashes of new messages). The neighbor
may request the message itself after learning a previously unseen
message hash, to be transferred, say, using the reliable large
datagram protocol (RLDP) discussed in~\ptref{sp:RLDP}. In this way,
the new message will be downloaded from one neighbor only.

\nxsubpoint \embt(Checking the connectivity of an overlay network.)
The connectivity of an overlay network can be checked if there is a
known node (e.g., the ``owner'' or the ``creator'' of the overlay
network) that must be in this overlay network. Then the node in
question simply broadcasts from time to time short messages containing
the current time, a sequence number and its signature. Any other node
can be sure that it is still connected to the overlay network if it
has received such a broadcast not too long ago. This protocol can be
extended to the case of several well-known nodes; for example, they
all will send such broadcasts, and all other nodes will expect to
receive broadcasts from more than half of the well-known nodes.

In the case of an overlay network used for propagating new blocks (or
just new block headers) of a specific shardchain, a good way for a
node to check connectivity is to keep track of the most recent block
received so far. Because a block is normally generated every five
seconds, if no new block is received for more than, say, thirty
seconds, the node probably has been disconnected from the overlay
network.

\nxsubpoint\label{sp:streaming.multicast} \embt(Streaming broadcast
protocol.)  Finally, there is a {\em streaming broadcast protocol\/}
for TON overlay networks, used, for example, to propagate block
candidates among validators of some shardchain (``shardchain task
group''), who, of course, create a private overlay network for that
purpose. The same protocol can be used to propagate new shardchain
blocks to all full nodes for that shardchain.

This protocol has already been outlined
in~\ptref{sp:sh.blk.cand.prop}: the new (large) broadcast message is
split into, say, $N$ one-kilobyte chunks; the sequence of these chunks
is augmented to $M\geq N$ chunks by means of an erasure code such as
the Reed--Solomon or a fountain code (e.g., the RaptorQ code
\cite{RaptorQ} \cite{Raptor}), and these $M$ chunks are streamed to
all neighbors in ascending chunk number order. The participating nodes
collect these chunks until they can recover the original large message
(one would have to successfully receive at least $N$ of the chunks for
this), and then instruct their neighbors to stop sending new chunks of
the stream, because now these nodes can generate the subsequent chunks
on their own, having a copy of the original message. Such nodes
continue to generate the subsequent chunks of the stream and send them
to their neighbors, unless the neighbors in turn indicate that this is
no longer necessary.

In this way, a node does not need to download a large message in its
entirety before propagating it further. This minimizes broadcast
latency, especially when combined with the optimizations described
in~\ptref{sp:ov.opt.low.lat}.

\nxsubpoint \embt(Constructing new overlay networks based on existing
ones.)  Sometimes one does not want to construct an overlay network
from scratch. Instead, one or several previously existing overlay
networks are known, and the membership of the new overlay network is
expected to overlap significantly with the combined membership of
these overlay networks.

An important example arises when a TON shardchain is split in two, or
two sibling shardchains are merged into one
(cf.~\ptref{sect:split.merge}). In the first case, the overlay
networks used for propagating new blocks to full nodes must be
constructed for each of the new shardchains; however, each of these
new overlay networks can be expected to be contained in the block
propagation network of the original shardchain (and comprise
approximately half its members). In the second case, the overlay
network for propagating new blocks of the merged shardchain will
consist approximately of the union of members of the two overlay
networks related to the two sibling shardchains being merged.

In such cases, the description of the new overlay network may contain
an explicit or implicit reference to a list of related existing
overlay networks. A node wishing to join the new overlay network may
check whether it is already a member of one of these existing
networks, and query its neighbors in these networks whether they are
interested in the new network as well. In case of a positive answer,
new point-to-point channels can be established to such neighbors, and
they can be included in the neighbor list for the new overlay network.

This mechanism does not totally supplant the general mechanism
described in~\ptref{sp:loc.1.mem} and \ptref{sp:loc.many.mem}; rather,
both are run in parallel and are used to populate the neighbor
list. This is needed to prevent inadvertent splitting of the new
overlay network into several unconnected subnetworks.

\nxsubpoint\label{sp:net.within.net} \embt(Overlay networks within
overlay networks.)  Another interesting case arises in the
implementation of {\em TON Payments} (a ``lightning network'' for
instant off-chain value transfers; cf.~\ptref{sect:lightning}). In
this case, first an overlay network containing all transit nodes of
the ``lightning network'' is constructed. However, some of these nodes
have established payment channels in the blockchain; they must always
be neighbors in this overlay network, in addition to any ``random''
neighbors selected by the general overlay network algorithms described
in~\ptref{sp:loc.1.mem}, \ptref{sp:loc.many.mem}
and~\ptref{sp:rand.mem}. These ``permanent links'' to the neighbors
with established payment channels are used to run specific lightning
network protocols, thus effectively creating an overlay subnetwork
(not necessarily connected, if things go awry) inside the encompassing
(almost always connected) overlay network.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%                  SERVICES
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\mysection{TON Services and Applications}\label{sect:services}

We have discussed the TON Blockchain and TON Networking technologies
at some length. Now we explain some ways in which they can be combined
to create a wide range of services and applications, and discuss some
of the services that will be provided by the TON Project itself,
either from the very beginning or at a later time.

\mysubsection{TON Service Implementation Strategies}%
\label{sect:ton.service.impl}

We start with a discussion of how different blockchain and
network-related applications and services may be implemented inside
the TON ecosystem. First of all, a simple classification is in order:

\nxsubpoint \embt(Applications and services.)  We will use the words
``application'' and ``service'' interchangeably. However, there is a
subtle and somewhat vague distinction: an {\em application\/} usually
provides some services directly to human users, while a {\em
  service\/} is usually exploited by other applications and
services. For example, TON Storage is a service, because it is
designed to keep files on behalf of other applications and services,
even though a human user might use it directly as well. A hypothetical
``Facebook in a blockchain'' (cf.~\ptref{sp:blockchain.facebook}) or
Telegram messenger, if made available through the TON Network (i.e.,
implemented as a ``ton-service''; cf.~\ptref{sp:telegram.ton.serv}),
would rather be an {\em application}, even though some ``bots'' might
access it automatically without human intervention.

\nxsubpoint\label{sp:on.off.chain} \embt(Location of the application:
on-chain, off-chain or mixed.)  A service or an application designed
for the TON ecosystem needs to keep its data and process that data
somewhere. This leads to the following classification of applications
(and services):
\begin{itemize}
\item {\em On-chain\/} applications (cf.~\ptref{sp:pure.blockchain}):
  All data and processing are in the TON Blockchain.
\item {\em Off-chain\/} applications (cf.~\ptref{sp:pure.net.serv}):
  All data and processing are outside the TON Blockchain, on servers
  available through the TON Network.
\item {\em Mixed\/} applications (cf.~\ptref{sp:mixed.serv}): Some,
  but not all, data and processing are in the TON Blockchain; the rest
  are on off-chain servers available through the TON Network.
\end{itemize}

\nxsubpoint \embt(Centralization: centralized and decentralized, or
distributed, applications.)  Another classification criterion is
whether the application (or service) relies on a centralized server
cluster, or is really ``distributed'' (cf.~\ptref{sp:fog}). All
on-chain applications are automatically decentralized and
distributed. Off-chain and mixed applications may exhibit different
degrees of centralization.

\medbreak
Now let us consider the above possibilities in more detail.

\nxsubpoint\label{sp:pure.blockchain} \embt(Pure ``on-chain''
applications: distributed applications, or ``dapps'', residing in the
blockchain.)  One of the possible approaches, mentioned
in~\ptref{sp:on.off.chain}, is to deploy a ``distributed application''
(commonly abbreviated as ``dapp'') completely in the TON Blockchain,
as one smart contract or a collection of smart contracts. All data
will be kept as part of the permanent state of these smart contracts,
and all interaction with the project will be done by means of (TON
Blockchain) messages sent to or received from these smart contracts.

We have already discussed in~\ptref{sp:blockchain.facebook} that this
approach has its drawbacks and limitations. It has its advantages,
too: such a distributed application needs no servers to run on or to
store its data (it runs ``in the blockchain''---i.e., on the
validators' hardware), and enjoys the blockchain's extremely high
(Byzantine) reliability and accessibility. The developer of such a
distributed application does not need to buy or rent any hardware; all
she needs to do is develop some software (i.e., the code for the smart
contracts). After that, she will effectively rent the computing power
from the validators, and will pay for it in Grams, either herself or
by putting this burden on the shoulders of her users.

\nxsubpoint\label{sp:pure.net.serv} \embt(Pure network services:
``ton-sites'' and ``ton-services''.)  Another extreme option is to
deploy the service on some servers and make it available to the users
through the ADNL protocol described in~\ptref{sect:ANL}, and maybe
some higher level protocol such as the RLDP discussed
in~\ptref{sp:RLDP}, which can be used to send RPC queries to the
service in any custom format and obtain answers to these queries. In
this way, the service will be totally off-chain, and will reside in
the TON Network, almost without using the TON Blockchain.

The TON Blockchain might be used only to locate the abstract address
or addresses of the service, as outlined in~\ptref{sp:loc.serv},
perhaps with the aid of a service such as the TON DNS
(cf.~\ptref{sp:ton.dns}) to facilitate translation of domain-like
human-readable strings into abstract addresses.

To the extent the ADNL network (i.e., the TON Network) is similar to
the Invisible Internet Project ($I^2P$), such (almost) purely network
services are analogous to the so-called ``eep-services'' (i.e.,
services that have an $I^2P$-address as their entry point, and are
available to clients through the $I^2P$ network). We will say that
such purely network services residing in the TON Network are
``ton-services''.

An ``eep-service'' may implement HTTP as its client-server protocol;
in the TON Network context, a ``ton-service'' might simply use RLDP
(cf.~\ptref{sp:RLDP}) datagrams to transfer HTTP queries and responses
to them. If it uses the TON DNS to allow its abstract address to be
looked up by a human-readable domain name, the analogy to a web site
becomes almost perfect. One might even write a specialized browser, or
a special proxy (``ton-proxy'') that is run locally on a user's
machine, accepts arbitrary HTTP queries from an ordinary web browser
the user employs (once the local IP address and the TCP port of the
proxy are entered into the browser's configuration), and forwards
these queries through the TON Network to the abstract address of the
service. Then the user would have a browsing experience similar to
that of the World Wide Web (WWW).

In the $I^2P$ ecosystem, such ``eep-services'' are called
``eep-sites''. One can easily create ``ton-sites'' in the TON
ecosystem as well. This is facilitated somewhat by the existence of
services such as the TON DNS, which exploit the TON Blockchain and the
TON DHT to translate (TON) domain names into abstract addresses.

\nxsubpoint\label{sp:telegram.ton.serv} \embt(Telegram Messenger as a
ton-service; MTProto over RLDP.)  We would like to mention in passing
that the MTProto
protocol,\footnote{\url{https://core.telegram.org/mtproto}} used by
Telegram Messenger\footnote{\url{https://telegram.org/}} for
client-server interaction, can be easily embedded into the RLDP
protocol discussed in~\ptref{sp:RLDP}, thus effectively transforming
Telegram into a ton-service. Because the TON Proxy technology can be
switched on transparently for the end user of a ton-site or a
ton-service, being implemented on a lower level than the RLDP and ADNL
protocols (cf.~\ptref{sp:tunnels}), this would make Telegram
effectively unblockable. Of course, other messaging and social
networking services might benefit from this technology as well.

\nxsubpoint\label{sp:mixed.serv} \embt(Mixed services: partly
off-chain, partly on-chain.)  Some services might use a mixed
approach: do most of the processing off-chain, but also have some
on-chain part (for example, to register their obligations towards
their users, and vice versa). In this way, part of the state would
still be kept in the TON Blockchain (i.e., an immutable public
ledger), and any misbehavior of the service or of its users could be
punished by smart contracts.

\nxsubpoint\label{sp:ex.ton.storage} \embt(Example: keeping files
off-chain; TON Storage.)  An example of such a service is given by
{\em TON Storage}. In its simplest form, it allows users to store
files off-chain, by keeping on-chain only a hash of the file to be
stored, and possibly a smart contract where some other parties agree
to keep the file in question for a given period of time for a
pre-negotiated fee. In fact, the file may be subdivided into chunks of
some small size (e.g., 1 kilobyte), augmented by an erasure code such
as a Reed--Solomon or a fountain code, a Merkle tree hash may be
constructed for the augmented sequence of chunks, and this Merkle tree
hash might be published in the smart contract instead of or along with
the usual hash of the file. This is somewhat reminiscent of the way
files are stored in a torrent.

An even simpler form of storing files is completely off-chain: one
might essentially create a ``torrent'' for a new file, and use TON DHT
as a ``distributed torrent tracker'' for this torrent
(cf.~\ptref{sp:distr.torr.tr}). This might actually work pretty well
for popular files. However, one does not get any availability
guarantees. For example, a hypothetical ``blockchain Facebook''
(cf.~\ptref{sp:blockchain.facebook}), which would opt to keep the
profile photographs of its users completely off-chain in such
``torrents'', might risk losing photographs of ordinary (not
especially popular) users, or at least risk being unable to present
these photographs for prolonged periods. The TON Storage technology,
which is mostly off-chain, but uses an on-chain smart contract to
enforce availability of the stored files, might be a better match for
this task.

\nxsubpoint\label{sp:fog} \embt(Decentralized mixed services, or ``fog
services''.)  So far, we have discussed {\em centralized\/} mixed
services and applications. While their on-chain component is processed
in a decentralized and distributed fashion, being located in the
blockchain, their off-chain component relies on some servers
controlled by the service provider in the usual centralized
fashion. Instead of using some dedicated servers, computing power
might be rented from a cloud computing service offered by one of the
large companies. However, this would not lead to decentralization of
the off-chain component of the service.

A decentralized approach to implementing the off-chain component of a
service consists in creating a {\em market}, where anybody possessing
the required hardware and willing to rent their computing power or
disk space would offer their services to those needing them.

For example, there might exist a registry (which might also be called
a ``market'' or an ``exchange'') where all nodes interested in keeping
files of other users publish their contact information, along with
their available storage capacity, availability policy, and
prices. Those needing these services might look them up there, and, if
the other party agrees, create smart contracts in the blockchain and
upload files for off-chain storage. In this way a service like {\em
  TON Storage\/} becomes truly decentralized, because it does not need
to rely on any centralized cluster of servers for storing files.

\nxsubpoint \embt(Example: ``fog computing'' platforms as
decentralized mixed services.)  Another example of such a
decentralized mixed application arises when one wants to perform some
specific computations (e.g., 3D rendering or training neural
networks), often requiring specific and expensive hardware. Then those
having such equipment might offer their services through a similar
``exchange'', and those needing such services would rent them, with
the obligations of the sides registered by means of smart
contracts. This is similar to what ``fog computing'' platforms, such
as Golem (\url{https://golem.network/}) or SONM
(\url{https://sonm.io/}), promise to deliver.

\nxsubpoint\label{sp:ex.ton.proxy} \embt(Example: TON Proxy is a fog
service.)  {\em TON Proxy\/} provides yet another example of a fog
service, where nodes wishing to offer their services (with or without
compensation) as tunnels for ADNL network traffic might register,
and those needing them might choose one of these nodes depending on
the price, latency and bandwidth offered. Afterwards, one might use
payment channels provided by {\em TON Payments\/} for processing
micropayments for the services of those proxies, with payments
collected, for instance, for every 128~KiB transferred.

\nxsubpoint \embt(Example: TON Payments is a fog service.)  The TON
Payments platform (cf.~\ptref{sect:payments}) is also an example of
such a decentralized mixed application.

\mysubsection{Connecting Users and Service
  Providers}\label{sect:reg.markt}

We have seen in~\ptref{sp:fog} that ``fog services'' (i.e., mixed
decentralized services) will usually need some {\em markets}, {\em
  exchanges\/} or {\em registries}, where those needing specific
services might meet those providing them.

Such markets are likely to be implemented as on-chain, off-chain or
mixed services themselves, centralized or distributed.

\nxsubpoint \embt(Example: connecting to TON Payments.)  For example,
if one wants to use TON Payments (cf.~\ptref{sect:payments}), the
first step would be to find at least some existing transit nodes of
the ``lightning network'' (cf.~\ptref{sect:lightning}), and establish
payment channels with them, if they are willing. Some nodes can be
found with the aid of the ``encompassing'' overlay network, which is
supposed to contain all transit lightning network nodes
(cf.~\ptref{sp:net.within.net}). However, it is not clear whether
these nodes will be willing to create new payment channels. Therefore,
a registry is needed where nodes ready to create new links can publish
their contact information (e.g., their abstract addresses).

\nxsubpoint \embt(Example: uploading a file into TON Storage.)
Similarly, if one wants to upload a file into the TON Storage, she
must locate some nodes willing to sign a smart contract binding them
to keep a copy of that file (or of any file below a certain size
limit, for that matter). Therefore, a registry of nodes offering their
services for storing files is needed.

\nxsubpoint \embt(On-chain, mixed and off-chain registries.)  Such a
registry of service providers might be implemented completely
on-chain, with the aid of a smart contract which would keep the
registry in its permanent storage. However, this would be quite slow
and expensive. A mixed approach is more efficient, where the
relatively small and rarely changed on-chain registry is used only to
point out some nodes (by their abstract addresses, or by their public
keys, which can be used to locate actual abstract addresses as
described in~\ptref{sp:loc.serv}), which provide off-chain
(centralized) registry services.

Finally, a decentralized, purely off-chain approach might consist of a
public overlay network (cf.~\ptref{sect:overlay}), where those willing
to offer their services, or those looking to buy somebody's services,
simply broadcast their offers, signed by their private keys. If the
service to be provided is very simple, even broadcasting the offers
might be not necessary: the approximate membership of the overlay
network itself might be used as a ``registry'' of those willing to
provide a particular service. Then a client requiring this service
might locate (cf.~\ptref{sp:loc.many.mem}) and query some nodes of
this overlay network, and then query their neighbors, if the nodes
already known are not ready to satisfy its needs.

\nxsubpoint\label{sp:side.chain.reg} \embt(Registry or exchange in a
side-chain.)  Another approach to implementing decentralized mixed
registries consists in creating an independent specialized blockchain
(``side-chain''), maintained by its own set of self-proclaimed
validators, who publish their identities in an on-chain smart contract
and provide network access to all interested parties to this
specialized blockchain, collecting transaction candidates and
broadcasting block updates through dedicated overlay networks
(cf.~\ptref{sect:overlay}). Then any full node for this sidechain can
maintain its own copy of the shared registry (essentially equal to the
global state of this side-chain), and process arbitrary queries
related to this registry.

\nxsubpoint \embt(Registry or exchange in a workchain.)  Another
option is to create a dedicated workchain inside the TON Blockchain,
specialized for creating registries, markets and exchanges. This might
be more efficient and less expensive than using smart contracts
residing in the basic workchain
(cf.~\ptref{sp:basic.workchain}). However, this would still be more
expensive than maintaining registries in side-chains
(cf.~\ptref{sp:side.chain.reg}).

\mysubsection{Accessing TON Services}

We have discussed in~\ptref{sect:ton.service.impl} the different
approaches one might employ for creating new services and applications
residing in the TON ecosystem. Now we discuss how these services might
be accessed, and some of the ``helper services'' that will be provided
by TON, including {\em TON DNS\/} and {\em TON Storage}.

\nxsubpoint\label{sp:ton.dns} \embt(TON DNS: a mostly on-chain
hierarchical domain name service.)  The {\em TON DNS\/} is a
predefined service, which uses a collection of smart contracts to keep
a map from human-readable domain names to (256-bit) addresses of ADNL
network nodes and TON Blockchain accounts and smart contracts.

While anybody might in principle implement such a service using the
TON Blockchain, it is useful to have such a predefined service with a
well-known interface, to be used by default whenever an application or
a service wants to translate human-readable identifiers into
addresses.

\nxsubpoint \embt(TON DNS use cases.)  For example, a user looking to
transfer some cryptocurrency to another user or to a merchant may
prefer to remember a TON DNS domain name of the account of that user
or merchant, instead of keeping their 256-bit account identifiers at
hand and copy-pasting them into the recipient field in their light
wallet client.

Similarly, TON DNS may be used to locate account identifiers of smart
contracts or entry points of ton-services and ton-sites
(cf.~\ptref{sp:pure.net.serv}), enabling a specialized client
(``ton-browser''), or a usual internet browser combined with a
specialized ton-proxy extension or stand-alone application, to deliver
a WWW-like browsing experience to the user.

\nxsubpoint \embt(TON DNS smart contracts.)  The TON DNS is
implemented by means of a tree of special (DNS) smart contracts. Each
DNS smart contract is responsible for registering subdomains of some
fixed domain. The ``root'' DNS smart contract, where level one domains
of the TON DNS system will be kept, is located in the masterchain. Its
account identifier must be hardcoded into all software that wishes to
access the TON DNS database directly.

Any DNS smart contract contains a hashmap, mapping variable-length
null-terminated UTF-8 strings into their ``values''. This hashmap is
implemented as a binary Patricia tree, similar to that described
in~\ptref{sp:patricia} but supporting variable-length bitstrings as
keys.

\nxsubpoint \embt(Values of the DNS hashmap, or TON DNS records.)  As
to the values, they are ``TON DNS records'' described by a TL-scheme
(cf.~\ptref{sp:TL}). They consist of a ``magic number'', selecting one
of the options supported, and then either an account identifier, or a
smart-contract identifier, or an abstract network address
(cf.~\ptref{sect:ANL}), or a public key used to locate abstract
addresses of a service (cf.~\ptref{sp:loc.serv}), or a description of
an overlay network, and so on. An important case is that of another
DNS smart contract: in such a case, that smart contract is used to
resolve subdomains of its domain. In this way, one can create separate
registries for different domains, controlled by the owners of those
domains.

These records may also contain an expiration time, a caching time
(usually very large, because updating values in a blockchain too often
is expensive), and in most cases a reference to the owner of the
subdomain in question. The owner has the right to change this record
(in particular, the owner field, thus transferring the domain to
somebody else's control), and to prolong it.

\nxsubpoint \embt(Registering new subdomains of existing domains.)  In
order to register a new subdomain of an existing domain, one simply
sends a message to the smart contract, which is the registrar of that
domain, containing the subdomain (i.e., the key) to be registered, the
value in one of several predefined formats, an identity of the owner,
an expiration date, and some amount of cryptocurrency as determined by
the domain's owner.

Subdomains are registered on a ``first-come, first-served'' basis.

\nxsubpoint\label{sp:dns.get} \embt(Retrieving data from a DNS smart
contract.)  In principle, any full node for the masterchain or
shardchain containing a DNS smart contract might be able to look up
any subdomain in the database of that smart contract, if the structure
and the location of the hashmap inside the persistent storage of the
smart contract are known.

However, this approach would work only for certain DNS smart
contracts. It would fail miserably if a non-standard DNS smart
contract were used.

Instead, an approach based on {\em general smart contract
  interfaces\/} and {\em get methods\/} (cf.~\ptref{sp:get.methods})
is used. Any DNS smart contract must define a ``get method'' with a
``known signature'', which is invoked to look up a key. Since this
approach makes sense for other smart contracts as well, especially
those providing on-chain and mixed services, we explain it in some
detail in~\ptref{sp:get.methods}.

\nxsubpoint \embt(Translating a TON DNS domain.)  Once any full node,
acting by itself or on behalf of some light client, can look up
entries in the database of any DNS smart contract, arbitrary TON DNS
domain names can be recursively translated, starting from the
well-known and fixed root DNS smart contract (account) identifier.

For example, if one wants to translate \texttt{A.B.C}, one looks up
keys \texttt{.C}, \texttt{.B.C}, and \texttt{A.B.C} in the root domain
database. If the first of them is not found, but the second is, and
its value is a reference to another DNS smart contract, then
\texttt{A} is looked up in the database of that smart contract and the
final value is retrieved.

\nxsubpoint \embt(Translating TON DNS domains for light nodes.)  In
this way, a full node for the masterchain---and also for all
shardchains involved in the domain look-up process---might translate
any domain name into its current value without external help. A light
node might request a full node to do this on its behalf and return the
value, along with a Merkle proof
(cf.~\ptref{sp:merkle.query.resp}). This Merkle proof would enable the
light node to verify that the answer is correct, so such TON DNS
responses cannot be ``spoofed'' by a malicious interceptor, in
contrast to the usual DNS protocol.

Because no node can be expected to be a full node with respect to all
shardchains, actual TON DNS domain translation would involve a
combination of these two strategies.

\nxsubpoint \embt(Dedicated ``TON DNS servers''.)  One might provide a
simple ``TON DNS server'', which would receive RPC ``DNS'' queries
(e.g., via the ADNL or RLDP protocols described in~\ptref{sect:ANL}),
requesting that the server translate a given domain, process these
queries by forwarding some subqueries to other (full) nodes if
necessary, and return answers to the original queries, augmented by
Merkle proofs if required.

Such ``DNS servers'' might offer their services (for free or not) to
any other nodes and especially light clients, using one of the methods
described in~\ptref{sect:reg.markt}. Notice that these servers, if
considered part of the TON DNS service, would effectively transform it
from a distributed on-chain service into a distributed mixed service
(i.e., a ``fog service'').

This concludes our brief overview of the TON DNS service, a scalable
on-chain registry for human-readable domain names of TON Blockchain
and TON Network entities.

\nxsubpoint \embt(Accessing data kept in smart contracts.)  We have
already seen that it is sometimes necessary to access data stored in a
smart contract without changing its state.

If one knows the details of the smart-contract implementation, one can
extract all the needed information from the smart contract's
persistent storage, available to all full nodes of the shardchain the
smart contract resides in. However, this is quite an inelegant way of
doing things, depending very much on the smart-contract
implementation.

\nxsubpoint\label{sp:get.methods} \embt(``Get methods'' of smart
contracts.)  A better way would be to define some {\em get methods\/}
in the smart contract, that is, some types of inbound messages that do
not affect the state of the smart contract when delivered, but
generate one or more output messages containing the ``result'' of the
get method. In this way, one can obtain data from a smart contract,
knowing only that it implements a get method with a known signature
(i.e., a known format of the inbound message to be sent and outbound
messages to be received as a result).

This way is much more elegant and in line with object oriented
programming (OOP). However, it has an obvious defect so far: one must
actually commit a transaction into the blockchain (sending the get
message to the smart contract), wait until it is committed and
processed by the validators, extract the answer from a new block, and
pay for gas (i.e., for executing the get method on the validators'
hardware). This is a waste of resources: get methods do not change the
state of the smart contract anyways, so they need not be executed in
the blockchain.

\nxsubpoint\label{sp:tent.exec.get} \embt(Tentative execution of get
methods of smart contracts.)  We have already remarked
(cf.~\ptref{sp:ext.msg}) that any full node can tentatively execute
any method of any smart contract (i.e., deliver any message to a smart
contract), starting from a given state of the smart contract, without
actually committing the corresponding transaction. The full node can
simply load the code of the smart contract under consideration into
the TON VM, initialize its persistent storage from the global state of
the shardchain (known to all full nodes of the shardchain), and
execute the smart-contract code with the inbound message as its input
parameter. The output messages created will yield the result of this
computation.

In this way, any full node can evaluate arbitrary get methods of
arbitrary smart contracts, provided their signature (i.e., the format
of inbound and outbound messages) is known. The node may keep track of
the cells of the shardchain state accessed during this evaluation, and
create a Merkle proof of the validity of the computation performed,
for the benefit of a light node that might have asked the full node to
do so (cf.~\ptref{sp:merkle.query.resp}).

\nxsubpoint \embt(Smart-contract interfaces in TL-schemes.)  Recall
that the methods implemented by a smart contract (i.e., the input
messages accepted by it) are essentially some TL-serialized objects,
which can be described by a TL-scheme (cf.~\ptref{sp:TL}). The
resulting output messages can be described by the same TL-scheme as
well. In this way, the interface provided by a smart contract to other
accounts and smart contracts may be formalized by means of a
TL-scheme.

In particular, (a subset of) get methods supported by a smart
contract can be described by such a formalized smart-contract
interface.

\nxsubpoint\label{sp:pub.int.smartc} \embt(Public interfaces of a
smart contract.)  Notice that a formalized smart-contract interface,
either in form of a TL-scheme (represented as a TL source file;
cf.~\ptref{sp:TL}) or in serialized form,\footnote{TL-schemes can be
  TL-serialized themselves;
  cf.\ \url{https://core.telegram.org/mtproto/TL-tl}.} can be
published---for example, in a special field in the smart-contract
account description, stored in the blockchain, or separately, if this
interface will be referred to many times. In the latter case a hash of
the supported public interface may be incorporated into the
smart-contract description instead of the interface description
itself.

An example of such a public interface is that of a DNS smart contract,
which is supposed to implement at least one standard get method for
looking up subdomains (cf.~\ptref{sp:dns.get}). A standard method for
registering new subdomains can be also included in the standard public
interface of DNS smart contracts.

\nxsubpoint\label{sp:ui.smartc} \embt(User interface of a smart
contract.)  The existence of a public interface for a smart contract
has other benefits, too. For example, a wallet client application may
download such an interface while examining a smart contract on the
request of a user, and display a list of public methods (i.e., of
available actions) supported by the smart contract, perhaps with some
human-readable comments if any are provided in the formal
interface. After the user selects one of these methods, a form may be
automatically generated according to the TL-scheme, where the user
will be prompted for all fields required by the chosen method and for
the desired amount of cryptocurrency (e.g., Grams) to be attached to
this request. Submitting this form will create a new blockchain
transaction containing the message just composed, sent from the user's
blockchain account.

In this way, the user will be able to interact with arbitrary smart
contracts from the wallet client application in a user-friendly way by
filling and submitting certain forms, provided these smart contracts
have published their interfaces.

\nxsubpoint\label{sp:ui.ton.serv} \embt(User interface of a
``ton-service''.)  It turns out that ``ton-services'' (i.e., services
residing in the TON Network and accepting queries through the ADNL and
RLDP protocols of~\ptref{sect:network}; cf.~\ptref{sp:pure.net.serv})
may also profit from having public interfaces, described by TL-schemes
(cf.~\ptref{sp:TL}). A client application, such as a light wallet or a
``ton-browser'', might prompt the user to select one of the methods
and to fill in a form with parameters defined by the interface,
similarly to what has just been discussed in~\ptref{sp:ui.smartc}. The
only difference is that the resulting TL-serialized message is not
submitted as a transaction in the blockchain; instead, it is sent as
an RPC query to the abstract address of the ``ton-service'' in
question, and the response to this query is parsed and displayed
according to the formal interface (i.e., a TL-scheme).

\nxsubpoint\label{sp:ui.ton.dns} \embt(Locating user interfaces via
TON DNS.)  The TON DNS record containing an abstract address of a
ton-service or a smart-contract account identifier might also contain
an optional field describing the public (user) interface of that
entity, or several supported interfaces. Then the client application
(be it a wallet, a ton-browser or a ton-proxy) will be able to
download the interface and interact with the entity in question (be it
a smart contract or a ton-service) in a uniform way.

\nxsubpoint \embt(Blurring the distinction between on-chain and off-chain
services.)  In this way, the distinction between on-chain, off-chain
and mixed services (cf.~\ptref{sp:on.off.chain}) is blurred for the
end user: she simply enters the domain name of the desired service
into the address line of her ton-browser or wallet, and the rest is
handled seamlessly by the client application.

\nxsubpoint\label{sp:telegram.integr} \embt(A light wallet and TON
entity explorer can be built into Telegram Messenger clients.)  An
interesting opportunity arises at this point. A light wallet and TON
entity explorer, implementing the above functionality, can be embedded
into the Telegram Messenger smartphone client application, thus
bringing the technology to more than 200 million people. Users would
be able to send hyperlinks to TON entities and resources by including
TON URIs (cf.~\ptref{sp:ton.uri}) in messages; such hyperlinks, if
selected, will be opened internally by the Telegram client application
of the receiving party, and interaction with the chosen entity will
begin.

\nxsubpoint \embt(``ton-sites'' as ton-services supporting an HTTP
interface.)  A {\em ton-site\/} is simply a ton-service that supports
an HTTP interface, perhaps along with some other interfaces. This
support may be announced in the corresponding TON DNS record.

\nxsubpoint \embt(Hyperlinks.)  Notice that the HTML pages returned by
ton-sites may contain {\em ton-hyperlinks}---that is, references to
other ton-sites, smart contracts and accounts by means of specially
crafted URI schemes (cf.~\ptref{sp:ton.uri})---containing either
abstract network addresses, account identifiers, or human-readable TON
DNS domains. Then a ``ton-browser'' might follow such a hyperlink when
the user selects it, detect the interface to be used, and display a
user interface form as outlined in \ptref{sp:ui.smartc}
and~\ptref{sp:ui.ton.serv}.

\nxsubpoint\label{sp:ton.uri} \embt(Hyperlink URLs may specify some
parameters.)  The hyperlink URLs may contain not only a (TON) DNS
domain or an abstract address of the service in question, but also the
name of the method to be invoked and some or all of its parameters. A
possible URI scheme for this might look as follows:
\begin{quote}
\texttt{ton://}\textit{<domain>}\texttt{/}\textit{<method>}\texttt{?}%
\textit{<field1>}\texttt{=}\textit{<value1>}\texttt{\&}%
\textit{<field2>}\texttt{=}\dots
\end{quote}
When the user selects such a link in a ton-browser, either the action
is performed immediately (especially if it is a get method of a smart
contract, invoked anonymously), or a partially filled form is
displayed, to be explicitly confirmed and submitted by the user (this
may be required for payment forms).

\nxsubpoint \embt(POST actions.)  A ton-site may embed into the HTML
pages it returns some usual-looking POST forms, with POST actions
referring either to ton-sites, ton-services or smart contracts by
means of suitable (TON) URLs. In that case, once the user fills and
submits that custom form, the corresponding action is taken, either
immediately or after an explicit confirmation.

\nxsubpoint\label{sp:ton.www} \embt(TON WWW.)  All of the above will
lead to the creation of a whole web of cross-referencing entities,
residing in the TON Network, which would be accessible to the end user
through a ton-browser, providing the user with a WWW-like browsing
experience. For end users, this will finally make blockchain
applications fundamentally similar to the web sites they are already
accustomed to.

\nxsubpoint \embt(Advantages of TON WWW.)  This ``TON WWW'' of
on-chain and off-chain services has some advantages over its
conventional counterpart. For example, payments are inherently
integrated in the system. User identity can be always presented to the
services (by means of automatically generated signatures on the
transactions and RPC requests generated), or hidden at will. Services
would not need to check and re-check user credentials; these
credentials can be published in the blockchain once and for all. User
network anonymity can be easily preserved by means of TON Proxy, and
all services will be effectively unblockable. Micropayments are also
possible and easy, because ton-browsers can be integrated with the TON
Payments system.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%                  PAYMENTS
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\mysection{TON Payments}\label{sect:payments}

The last component of the TON Project we will briefly discuss in this
text is {\em TON Payments}, the platform for (micro)payment channels
and ``lightning network'' value transfers. It would enable ``instant''
payments, without the need to commit all transactions into the
blockchain, pay the associated transaction fees (e.g., for the gas
consumed), and wait five seconds until the block containing the
transactions in question is confirmed.

The overall overhead of such instant payments is so small that one can
use them for micropayments. For example, a TON file-storing service
might charge the user for every 128 KiB of downloaded data, or a paid
TON Proxy might require some tiny micropayment for every 128 KiB of
traffic relayed.

While {\em TON Payments\/} is likely to be released later than the
core components of the TON Project, some considerations need to be
made at the very beginning. For example, the TON Virtual Machine (TON
VM; cf.~\ptref{sp:tonvm}), used to execute the code of TON Blockchain
smart contracts, must support some special operations with Merkle
proofs. If such support is not present in the original design, adding
it at a later stage might become problematic
(cf.~\ptref{sp:genome.change.never}). We will see, however, that the
TON VM comes with natural support for ``smart'' payment channels
(cf.~\ptref{sp:ton.smart.pc.supp}) out of the box.

\mysubsection{Payment Channels}

We start with a discussion of point-to-point payment channels, and how they can be implemented in the TON Blockchain.

\nxsubpoint \embt(The idea of a payment channel.)  Suppose two
parties, $A$ and $B$, know that they will need to make a lot of
payments to each other in the future. Instead of committing each
payment as a transaction in the blockchain, they create a shared
``money pool'' (or perhaps a small private bank with exactly two
accounts), and contribute some funds to it: $A$ contributes $a$
coins, and $B$ contributes $b$ coins. This is achieved by creating a
special smart contract in the blockchain, and sending the money to it.

Before creating the ``money pool'', the two sides agree to a certain
protocol. They will keep track of the {\em state\/} of the pool---that
is, of their balances in the shared pool. Originally, the state is
$(a,b)$, meaning that $a$ coins actually belong to~$A$, and $b$ coins
belong to~$B$. Then, if $A$ wants to pay $d$ coins to $B$, they can
simply agree that the new state is $(a',b')=(a-d,b+d)$. Afterwards,
if, say, $B$ wants to pay $d'$ coins to $A$, the state will become
$(a'',b'')=(a'+d',b'-d')$, and so on.

All this updating of balances inside the pool is done completely
off-chain. When the two parties decide to withdraw their due funds
from the pool, they do so according to the final state of the
pool. This is achieved by sending a special message to the smart
contract, containing the agreed-upon final state $(a^*,b^*)$ along
with the signatures of both~$A$ and $B$. Then the smart contract sends
$a^*$ coins to $A$, $b^*$ coins to $B$ and self-destructs.

This smart contract, along with the network protocol used by $A$ and
$B$ to update the state of the pool, is a simple {\em payment channel
  between $A$ and~$B$.} According to the classification described
in~\ptref{sp:on.off.chain}, it is a {\em mixed\/} service: part of its
state resides in the blockchain (the smart contract), but most of its
state updates are performed off-chain (by the network protocol). If
everything goes well, the two parties will be able to perform as many
payments to each other as they want (with the only restriction being
that the ``capacity'' of the channel is not overrun---i.e., their
balances in the payment channel both remain non-negative), committing
only two transactions into the blockchain: one to open (create) the
payment channel (smart contract), and another to close (destroy) it.

\nxsubpoint \embt(Trustless payment channels.)  The previous example
was somewhat unrealistic, because it assumes that both parties are
willing to cooperate and will never cheat to gain some
advantage. Imagine, for example, that $A$ will choose not to sign the
final balance $(a',b')$ with $a'<a$. This would put $B$ in a difficult
situation.

To protect against such scenarios, one usually tries to develop {\em
  trustless\/} payment channel protocols, which do not require the
parties to trust each other, and make provisions for punishing any
party who would attempt to cheat.

This is usually achieved with the aid of signatures. The payment
channel smart contract knows the public keys of $A$ and $B$, and it
can check their signatures if needed. The payment channel protocol
requires the parties to sign the intermediate states and send the
signatures to each other. Then, if one of the parties cheats---for
instance, pretends that some state of the payment channel never
existed---its misbehavior can be proved by showing its signature on
that state. The payment channel smart contract acts as an ``on-chain
arbiter'', able to process complaints of the two parties about each
other, and punish the guilty party by confiscating all of its money
and awarding it to the other party.

\nxsubpoint\label{sp:simple.sync.pc} \embt(Simple bidirectional
synchronous trustless payment channel.)  Consider the following, more
realistic example: Let the state of the payment channel be described
by triple $(\delta_i,i,o_i)$, where $i$ is the sequence number of the
state (it is originally zero, and then it is increased by one when a
subsequent state appears), $\delta_i$ is the {\em channel imbalance\/}
(meaning that $A$ and $B$ own $a+\delta_i$ and $b-\delta_i$ coins,
respectively), and $o_i$ is the party allowed to generate the next
state (either $A$ or $B$). Each state must be signed both by $A$ and
$B$ before any further progress can be made.

Now, if $A$ wants to transfer $d$ coins to $B$ inside the payment
channel, and the current state is $S_i=(\delta_i,i,o_i)$ with $o_i=A$,
then it simply creates a new state $S_{i+1}=(\delta_i-d,i+1,o_{i+1})$,
signs it, and sends it to $B$ along with its signature. Then $B$
confirms it by signing and sending a copy of its signature to
$A$. After that, both parties have a copy of the new state with both
of their signatures, and a new transfer may occur.

If $A$ wants to transfer coins to $B$ in a state $S_i$ with $o_i=B$,
then it first asks $B$ to commit a subsequent state $S_{i+1}$ with the
same imbalance $\delta_{i+1}=\delta_i$, but with $o_{i+1}=A$. After
that, $A$ will be able to make its transfer.

When the two parties agree to close the payment channel, they both put
their special {\em final\/} signatures on the state $S_k$ they believe
to be final, and invoke the {\em clean\/} or {\em two-sided
finalization method\/} of the payment channel smart contract by sending
it the final state along with both final signatures.

If the other party does not agree to provide its final signature, or
simply if it stops responding, it is possible to close the channel
unilaterally. For this, the party wishing to do so will invoke the
{\em unilateral finalization\/} method, sending to the smart contract
its version of the final state, its final signature, and the most
recent state having a signature of the other party. After that, the
smart contract does not immediately act on the final state
received. Instead, it waits for a certain period of time (e.g., one
day) for the other party to present its version of the final
state. When the other party submits its version and it turns out to be
compatible with the already submitted version, the ``true'' final
state is computed by the smart contract and used to distribute the
money accordingly. If the other party fails to present its version of
the final state to the smart contract, then the money is redistributed
according to the only copy of the final state presented.

If one of the two parties cheats---for example, by signing two
different states as final, or by signing two different next
states $S_{i+1}$ and $S'_{i+1}$, or by signing an invalid new state
$S_{i+1}$ (e.g., with imbalance $\delta_{i+1}<-a$ or $>b$)---then the
other party may submit proof of this misbehavior to a third method of
the smart contract. The guilty party is punished immediately by losing
its share in the payment channel completely.

This simple payment channel protocol is {\em fair\/} in the sense that
any party can always get its due, with or without the cooperation of
the other party, and is likely to lose all of its funds committed to
the payment channel if it tries to cheat.

\nxsubpoint\label{sp:sync.pc.as.blockch} \embt(Synchronous payment
channel as a simple virtual blockchain with two validators.)  The
above example of a simple synchronous payment channel can be recast as
follows. Imagine that the sequence of states $S_0$, $S_1$, \dots,
$S_n$ is actually the sequence of blocks of a very simple
blockchain. Each block of this blockchain contains essentially only
the current state of the blockchain, and maybe a reference to the
previous block (i.e., its hash). Both parties $A$ and $B$ act as
validators for this blockchain, so every block must collect both of
their signatures. The state $S_i$ of the blockchain defines the
designated producer $o_i$ for the next block, so there is no race
between $A$ and $B$ for producing the next block. Producer $A$ is
allowed to create blocks that transfer funds from $A$ to $B$ (i.e.,
decrease the imbalance: $\delta_{i+1}\leq\delta_i$), and $B$ can only
transfer funds from $B$ to $A$ (i.e., increase $\delta$).

If the two validators agree on the final block (and the final state)
of the blockchain, it is finalized by collecting special ``final''
signatures of the two parties, and submitting them along with the
final block to the channel smart contract for processing and
re-distributing the money accordingly.

If a validator signs an invalid block, or creates a fork, or signs two
different final blocks, it can be punished by presenting a proof of
its misbehavior to the smart contract, which acts as an ``on-chain
arbiter'' for the two validators; then the offending party will lose
all its money kept in the payment channel, which is analogous to a
validator losing its stake.

\nxsubpoint\label{sp:async.pc} \embt(Asynchronous payment channel as a
virtual blockchain with two workchains.)  The synchronous payment
channel discussed in \ptref{sp:simple.sync.pc} has a certain
disadvantage: one cannot begin the next transaction (money transfer
inside the payment channel) before the previous one is confirmed by
the other party. This can be fixed by replacing the single virtual
blockchain discussed in~\ptref{sp:sync.pc.as.blockch} by a system of
two interacting virtual workchains (or rather shardchains).

The first of these workchains contains only transactions by $A$, and
its blocks can be generated only by~$A$; its states are
$S_i=(i,\phi_i,j,\psi_j)$, where $i$ is the block sequence number
(i.e., the count of transactions, or money transfers, performed by $A$
so far), $\phi_i$ is the total amount transferred from $A$ to $B$ so
far, $j$ is the sequence number of the most recent valid block in
$B$'s blockchain that $A$ is aware of, and $\psi_j$ is the amount of
money transferred from $B$ to $A$ in its $j$ transactions. A signature
of $B$ put onto its $j$-th block should also be a part of this
state. Hashes of the previous block of this workchain and of the
$j$-th block of the other workchain may be also included. Validity
conditions for $S_i$ include $\phi_i\geq 0$, $\phi_i\geq\phi_{i-1}$ if
$i>0$, $\psi_j\geq0$, and $-a\leq\psi_j-\phi_i\leq b$.

Similarly, the second workchain contains only transactions by $B$, and
its blocks are generated only by~$B$; its states are
$T_j=(j,\psi_j,i,\phi_i)$, with similar validity conditions.

Now, if $A$ wants to transfer some money to $B$, it simply creates a
new block in its workchain, signs it, and sends to $B$, without
waiting for confirmation.

The payment channel is finalized by $A$ signing (its version of) the
final state of its blockchain (with its special ``final signature''),
$B$ signing the final state of its blockchain, and presenting these
two final states to the clean finalization method of the payment
channel smart contract. Unilateral finalization is also possible, but
in that case the smart contract will have to wait for the other party
to present its version of the final state, at least for some grace
period.

\nxsubpoint \embt(Unidirectional payment channels.)  If only $A$ needs
to make payments to $B$ (e.g., $B$ is a service provider, and $A$ its
client), then a unilateral payment channel can be
created. Essentially, it is just the first workchain described
in~\ptref{sp:async.pc} without the second one. Conversely, one can say
that the asynchronous payment channel described in \ptref{sp:async.pc}
consists of two unidirectional payment channels, or ``half-channels'',
managed by the same smart contract.

\nxsubpoint\label{sp:pc.promises} \embt(More sophisticated payment
channels. Promises.)  We will see later in~\ptref{sp:ch.money.tr} that
the ``lightning network'' (cf.~\ptref{sect:lightning}), which enables
instant money transfers through chains of several payment channels,
requires higher degrees of sophistication from the payment channels
involved.

In particular, we want to be able to commit ``promises'', or
``conditional money transfers'': $A$ agrees to send $c$ coins to $B$,
but $B$ will get the money only if a certain condition is fulfilled,
for instance, if $B$ can present some string $u$ with $\Hash(u)=v$ for
a known value of $v$. Otherwise, $A$ can get the money back after a
certain period of time.

Such a promise could easily be implemented on-chain by a simple smart
contract. However, we want promises and other kinds of conditional
money transfers to be possible off-chain, in the payment channel,
because they considerably simplify money transfers along a chain of
payment channels existing in the ``lightning network''
(cf.~\ptref{sp:ch.money.tr}).

The ``payment channel as a simple blockchain'' picture outlined
in~\ptref{sp:sync.pc.as.blockch} and~\ptref{sp:async.pc} becomes
convenient here. Now we consider a more complicated virtual
blockchain, the state of which contains a set of such unfulfilled
``promises'', and the amount of funds locked in such promises. This
blockchain---or the two workchains in the asynchronous case---will
have to refer explicitly to the previous blocks by their
hashes. Nevertheless, the general mechanism remains the same.

\nxsubpoint\label{sp:sm.pc.chal} \embt(Challenges for the
sophisticated payment channel smart contracts.)  Notice that, while
the final state of a sophisticated payment channel is still small, and
the ``clean'' finalization is simple (if the two sides have agreed on
their amounts due, and both have signed their agreement, nothing else
remains to be done), the unilateral finalization method and the method
for punishing fraudulent behavior need to be more complex. Indeed, they
must be able to accept Merkle proofs of misbehavior, and to check
whether the more sophisticated transactions of the payment channel
blockchain have been processed correctly.

In other words, the payment channel smart contract must be able to
work with Merkle proofs, to check their ``hash validity'', and must
contain an implementation of $\evtrans$ and $\evblock$ functions
(cf.~\ptref{sp:blk.transf}) for the payment channel (virtual)
blockchain.

\nxsubpoint\label{sp:ton.smart.pc.supp} \embt(TON VM support for
``smart'' payment channels.)  The TON VM, used to run the code of TON
Blockchain smart contracts, is up to the challenge of executing the
smart contracts required for ``smart'', or sophisticated, payment
channels (cf.~\ptref{sp:sm.pc.chal}).

At this point the ``everything is a bag of cells'' paradigm
(cf.~\ptref{sp:everything.is.BoC}) becomes extremely convenient. Since
all blocks (including the blocks of the ephemeral payment channel
blockchain) are represented as bags of cells (and described by some
algebraic data types), and the same holds for messages and Merkle
proofs as well, a Merkle proof can easily be embedded into an inbound
message sent to the payment channel smart contract. The ``hash
condition'' of the Merkle proof will be checked automatically, and
when the smart contract accesses the ``Merkle proof'' presented, it
will work with it as if it were a value of the corresponding algebraic
data type---albeit incomplete, with some subtrees of the tree replaced
by special nodes containing the Merkle hash of the omitted
subtree. Then the smart contract will work with that value, which
might represent, for instance, a block of the payment channel
(virtual) blockchain along with its state, and will evaluate the
$\evblock$ function (cf.~\ptref{sp:blk.transf}) of that blockchain on
this block and the previous state. Then either the computation
finishes, and the final state can be compared with that asserted in
the block, or an ``absent node'' exception is thrown while attempting
to access an absent subtree, indicating that the Merkle proof is
invalid.

In this way, the implementation of the verification code for smart
payment channel blockchains turns out to be quite straightforward
using TON Blockchain smart contracts. One might say that {\em the TON
  Virtual Machine comes with built-in support for checking the
  validity of other simple blockchains.} The only limiting factor is
the size of the Merkle proof to be incorporated into the inbound
message to the smart contract (i.e., into the transaction).

\nxsubpoint\label{sp:pc.within.pc} \embt(Simple payment channel within
a smart payment channel.)  We would like to discuss the possibility of
creating a simple (synchronous or asynchronous) payment channel inside
an existing payment channel.

While this may seem somewhat convoluted, it is not much harder to
understand and implement than the ``promises'' discussed
in~\ptref{sp:pc.promises}. Essentially, instead of promising to pay
$c$ coins to the other party if a solution to some hash problem is
presented, $A$ promises to pay up to $c$ coins to $B$ according to the
final settlement of some other (virtual) payment channel
blockchain. Generally speaking, this other payment channel blockchain
need not even be between $A$ and $B$; it might involve some other
parties, say, $C$ and $D$, willing to commit $c$ and $d$ coins into
their simple payment channel, respectively. (This possibility is
exploited later in~\ptref{sp:virt.pc}.)

If the encompassing payment channel is asymmetric, two promises need
to be committed into the two workchains: $A$ will promise to pay
$-\delta$ coins to $B$ if the final settlement of the ``internal''
simple payment channel yields a negative final imbalance $\delta$ with
$0\leq-\delta\leq c$; and $B$ will have to promise to pay $\delta$ to
$A$ if $\delta$ is positive. On the other hand, if the encompassing
payment channel is symmetric, this can be done by committing a single
``simple payment channel creation'' transaction with parameters
$(c,d)$ into the single payment channel blockchain by~$A$ (which would
freeze $c$ coins belonging to~$A$), and then committing a special
``confirmation transaction'' by~$B$ (which would freeze $d$ coins
of~$B$).

We expect the internal payment channel to be extremely simple (e.g.,
the simple synchronous payment channel discussed
in~\ptref{sp:simple.sync.pc}), to minimize the size of Merkle proofs
to be submitted. The external payment channel will have to be
``smart'' in the sense described in~\ptref{sp:pc.promises}.

\mysubsection{Payment Channel Network, or ``Lightning
  Network''}\label{sect:lightning}

Now we are ready to discuss the ``lightning network'' of TON Payments
that enables instant money transfers between any two participating
nodes.

\nxsubpoint \embt(Limitations of payment channels.)  A payment channel
is useful for parties who expect a lot of money transfers between
them. However, if one needs to transfer money only once or twice to a
particular recipient, creating a payment channel with her would be
impractical. Among other things, this would imply freezing a
significant amount of money in the payment channel, and would require
at least two blockchain transactions anyway.

\nxsubpoint \embt(Payment channel networks, or ``lightning
networks''.)  Payment channel networks overcome the limitations of
payment channels by enabling money transfers along {\em chains} of
payment channels. If $A$ wants to transfer money to $E$, she does not
need to establish a payment channel with $E$. It would be sufficient
to have a chain of payment channels linking $A$ with $E$ through
several intermediate nodes---say, four payment channels: from $A$ to
$B$, from $B$ to $C$, from $C$ to $D$ and from $D$ to $E$.

\nxsubpoint \embt(Overview of payment channel networks.)  Recall that
a {\em payment channel network}, known also as a ``lightning
network'', consists of a collection of participating nodes, some of
which have established long-lived payment channels between them. We
will see in a moment that these payment channels will have to be
``smart'' in the sense of~\ptref{sp:pc.promises}. When a
participating node $A$ wants to transfer money to any other
participating node $E$, she tries to find a path linking $A$ to $E$
inside the payment channel network. When such a path is found, she
performs a ``chain money transfer'' along this path.

\nxsubpoint\label{sp:ch.money.tr} \embt(Chain money transfers.)
Suppose that there is a chain of payment channels from $A$ to $B$,
from $B$ to $C$, from $C$ to $D$, and from $D$ to $E$. Suppose,
further, that $A$ wants to transfer $x$ coins to $E$.

A simplistic approach would be to transfer $x$ coins to $B$ along
the existing payment channel, and ask him to forward the money further
to $C$. However, it is not evident why $B$ would not simply take the
money for himself. Therefore, one must employ a more sophisticated
approach, not requiring all parties involved to trust each other.

This can be achieved as follows. $A$ generates a large random number
$u$ and computes its hash $v=\Hash(u)$. Then she creates a promise to
pay $x$ coins to $B$ if a number $u$ with hash $v$ is presented
(cf.~\ptref{sp:pc.promises}), inside her payment channel
with~$B$. This promise contains $v$, but not $u$, which is still kept
secret.

After that, $B$ creates a similar promise to $C$ in their payment
channel. He is not afraid to give such a promise, because he is aware
of the existence of a similar promise given to him by $A$. If $C$ ever
presents a solution of the hash problem to collect $x$ coins promised
by $B$, then $B$ will immediately submit this solution to $A$ to
collect $x$ coins from $A$.

Then similar promises of $C$ to $D$ and of $D$ to $E$ are
created. When the promises are all in place, $A$ triggers the transfer
by communicating the solution $u$ to all parties involved---or just to
$E$.

Some minor details are omitted in this description. For example, these
promises must have different expiration times, and the amount promised
might slightly differ along the chain ($B$ might promise only
$x-\epsilon$ coins to $C$, where $\epsilon$ is a small pre-agreed
transit fee). We ignore such details for the time being, because they
are not too relevant for understanding how payment channels work and
how they can be implemented in TON.

\nxsubpoint\label{sp:virt.pc} \embt(Virtual payment channels inside a
chain of payment channels.)  Now suppose that $A$ and $E$ expect to
make a lot of payments to each other. They might create a new payment
channel between them in the blockchain, but this would still be quite
expensive, because some funds would be locked in this payment
channel. Another option would be to use chain money transfers
described in~\ptref{sp:ch.money.tr} for each payment. However, this
would involve a lot of network activity and a lot of transactions in
the virtual blockchains of all payment channels involved.

An alternative is to create a virtual payment channel inside the chain
linking $A$ to $E$ in the payment channel network. For this, $A$ and
$E$ create a (virtual) blockchain for their payments, as if they were
going to create a payment channel in the blockchain. However, instead
of creating a payment channel smart contract in the blockchain, they
ask all intermediate payment channels---those linking $A$ to $B$, $B$
to $C$, etc.---to create simple payment channels inside them, bound
to the virtual blockchain created by $A$ and $E$
(cf.~\ptref{sp:pc.within.pc}). In other words, now a promise to
transfer money according to the final settlement between $A$ and~$E$
exists inside every intermediate payment channel.

If the virtual payment channel is unidirectional, such promises can be
implemented quite easily, because the final imbalance $\delta$ is
going to be non-positive, so simple payment channels can be created
inside intermediate payment channels in the same order as described
in~\ptref{sp:ch.money.tr}. Their expiration times can also be set in
the same way.

If the virtual payment channel is bidirectional, the situation is
slightly more complicated. In that case, one should split the promise
to transfer $\delta$ coins according to the final settlement into two
half-promises, as explained in \ptref{sp:pc.within.pc}: to transfer
$\delta^-=\max(0,-\delta)$ coins in the forward direction, and to
transfer $\delta^+=\max(0,\delta)$ in the backward direction. These
half-promises can be created in the intermediate payment channels
independently, one chain of half-promises in the direction from $A$
to~$E$, and the other chain in the opposite direction.

\nxsubpoint\label{sp:lnet.find.path} \embt(Finding paths in the
lightning network.)  One point remains undiscussed so far: how will
$A$ and $E$ find a path connecting them in the payment network?  If
the payment network is not too large, an OSPF-like protocol can be
used: all nodes of the payment network create an overlay network
(cf.~\ptref{sp:net.within.net}), and then every node propagates all
available link (i.e., participating payment channel) information to
its neighbors by a gossip protocol. Ultimately, all nodes will have a
complete list of all payment channels participating in the payment
network, and will be able to find the shortest paths by
themselves---for example, by applying a version of Dijkstra's
algorithm modified to take into account the ``capacities'' of the
payment channels involved (i.e., the maximal amounts that can be
transferred along them). Once a candidate path is found, it can be
probed by a special ADNL datagram containing the full path, and asking
each intermediate node to confirm the existence of the payment channel
in question, and to forward this datagram further according to the
path. After that, a chain can be constructed, and a protocol for chain
transfers (cf.~\ptref{sp:ch.money.tr}), or for creating a virtual
payment channel inside a chain of payment channels
(cf.~\ptref{sp:virt.pc}), can be run.

\nxsubpoint \embt(Optimizations.)  Some optimizations might be done
here. For example, only transit nodes of the lightning network need to
participate in the OSPF-like protocol discussed
in~\ptref{sp:lnet.find.path}. Two ``leaf'' nodes wishing to connect
through the lightning network would communicate to each other the
lists of transit nodes they are connected to (i.e., with which they
have established payment channels participating in the payment
network). Then paths connecting transit nodes from one list to transit
nodes from the other list can be inspected as outlined above
in~\ptref{sp:lnet.find.path}.

\nxsubpoint \embt(Conclusion.)  We have outlined how the blockchain
and network technologies of the TON project are adequate to the task
of creating {\em TON Payments}, a platform for off-chain instant money
transfers and micropayments. This platform can be extremely useful
for services residing in the TON ecosystem, allowing them to easily
collect micropayments when and where required.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%                  CONCLUSION
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\section*{Conclusion}
\markbothsame{\textsc{Conclusion}}
\addcontentsline{toc}{section}{Conclusion}

We have proposed a scalable multi-blockchain architecture capable of
supporting a massively popular cryptocurrency and decentralized
applications with user-friendly interfaces.

To achieve the necessary scalability, we proposed the {\em TON
  Blockchain}, a ``tightly-coupled'' multi-blockchain system
(cf.~\ptref{sp:blkch.interact}) with bottom-up approach to sharding
(cf.~\ptref{sp:shard.supp} and~\ptref{sp:ISP}). To further increase
potential performance, we introduced the 2-blockchain mechanism for
replacing invalid blocks (cf.~\ptref{sp:inv.sh.blk.corr}) and Instant
Hypercube Routing for faster communication between shards
(cf.~\ptref{sp:instant.hypercube}). A brief comparison of the TON
Blockchain to existing and proposed blockchain projects
(cf.~\ptref{sect:class.blkch} and~\ptref{sect:compare.blkch})
highlights the benefits of this approach for systems that seek to
handle millions of transactions per second.

The {\em TON Network}, described in Chapter~\ptref{sect:network},
covers the networking demands of the proposed multi-blockchain
infrastructure. This network component may also be used in combination
with the blockchain to create a wide spectrum of applications and
services, impossible using the blockchain alone
(cf.~\ptref{sp:blockchain.facebook}). These services, discussed in
Chapter~\ptref{sect:services}, include {\em TON DNS}, a service for
translating human-readable object identifiers into their addresses;
{\em TON Storage}, a distributed platform for storing arbitrary files;
{\em TON Proxy}, a service for anonymizing network access and
accessing TON-powered services; and {\em TON Payments\/}
(cf. Chapter~\ptref{sect:payments}), a platform for instant off-chain
money transfers across the TON ecosystem that applications may use for
micropayments.

The TON infrastructure allows for specialized light client wallet and
``ton-browser'' desktop and smartphone applications that enable a
browser-like experience for the end user (cf.~\ptref{sp:ton.www}),
making cryptocurrency payments and interaction with smart contracts
and other services on the TON Platform accessible to the mass
user. Such a light client can be integrated into the Telegram
Messenger client (cf.~\ptref{sp:telegram.integr}), thus eventually
bringing a wealth of blockchain-based applications to hundreds of
millions of users.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%                  BIBLIOGRAPHY
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\markbothsame{\textsc{References}}

\begin{thebibliography}{2}

\bibitem{Birman}
  {\sc K.~Birman}, {\sl Reliable Distributed Systems: Technologies, Web Services and Applications}, Springer, 2005.
  
\bibitem{EthWP}
  {\sc V.~Buterin}, {\sl Ethereum: A next-generation smart contract and decentralized application platform}, \url{https://github.com/ethereum/wiki/wiki/White-Paper}, 2013.

\bibitem{BenOr}
  {\sc M.~Ben-Or, B.~Kelmer, T.~Rabin}, {\sl Asynchronous secure computations with optimal resilience}, in {\em Proceedings of the thirteenth annual ACM symposium on Principles of distributed computing}, p.~183--192. ACM, 1994.

\bibitem{PBFT}
  {\sc M.~Castro, B.~Liskov, et al.}, {\sl Practical byzantine fault tolerance}, {\it Proceedings of the Third Symposium on Operating Systems Design and Implementation\/} (1999), p.~173--186, available at \url{http://pmg.csail.mit.edu/papers/osdi99.pdf}.

\bibitem{EOSWP}
  {\sc EOS.IO}, {\sl EOS.IO technical white paper}, \url{https://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.md}, 2017.

\bibitem{Onion}
  {\sc D.~Goldschlag, M.~Reed, P.~Syverson}, {\sl Onion Routing for Anonymous and Private Internet Connections}, {\it Communications of the ACM}, {\bf 42}, num.~2 (1999), \url{http://www.onion-router.net/Publications/CACM-1999.pdf}.

\bibitem{Byzantine}
  {\sc L.~Lamport, R.~Shostak, M.~Pease}, {\sl The byzantine generals problem}, {\it ACM Transactions on Programming Languages and Systems}, {\bf 4/3} (1982), p.~382--401.

\bibitem{BitShWP}
  {\sc S.~Larimer}, {\sl The history of BitShares}, \url{https://docs.bitshares.org/bitshares/history.html}, 2013.

\bibitem{RaptorQ}
  {\sc M.~Luby, A.~Shokrollahi, et al.}, {\sl RaptorQ forward error correction scheme for object delivery}, IETF RFC 6330, \url{https://tools.ietf.org/html/rfc6330}, 2011.

\bibitem{Kademlia}
  {\sc P.~Maymounkov, D.~Mazi\`eres}, {\sl Kademlia: A peer-to-peer information system based on the XOR metric}, in {\em IPTPS '01 revised papers from the First International Workshop on Peer-to-Peer Systems}, p.~53--65, available at \url{http://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf}, 2002.

\bibitem{HoneyBadger}
  {\sc A.~Miller, Yu Xia, et al.}, {\sl The honey badger of BFT protocols}, Cryptology e-print archive 2016/99, \url{https://eprint.iacr.org/2016/199.pdf}, 2016.

\bibitem{BitcWP}
  {\sc S.~Nakamoto}, {\sl Bitcoin: A peer-to-peer electronic cash system}, \url{https://bitcoin.org/bitcoin.pdf}, 2008.

\bibitem{STGM}
  {\sc S.~Peyton Jones}, {\sl Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine}, {\it Journal of Functional Programming\/} {\bf 2} (2), p.~127--202, 1992.

\bibitem{Raptor}
  {\sc A.~Shokrollahi, M.~Luby}, {\sl Raptor Codes}, {\it IEEE Transactions on Information Theory\/} {\bf 6}, no.\ 3--4 (2006), p.~212--322.

\bibitem{DistrSys}
  {\sc M.~van Steen, A.~Tanenbaum}, {\sl Distributed Systems, 3rd ed.}, 2017.

\bibitem{HoTT}
  {\sc The Univalent Foundations Program}, {\sl Homotopy Type Theory: Univalent Foundations of Mathematics}, Institute for Advanced Study, 2013, available at \url{https://homotopytypetheory.org/book}.

\bibitem{PolkaWP}
  {\sc G.~Wood}, {\sl PolkaDot: vision for a heterogeneous multi-chain framework}, draft~1, \url{https://github.com/w3f/polkadot-white-paper/raw/master/PolkaDotPaper.pdf}, 2016.

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%                  APPENDICES
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\appendix
\myappendix{The TON Coin, or the Gram}\label{app:coins}

The principal cryptocurrency of the TON Blockchain, and in particular
of its masterchain and basic workchain, is the {\em TON Coin}, also
known as the {\em Gram\/} (GRM). It is used to make deposits required
to become a validator; transaction fees, gas payments (i.e.,
smart-contract message processing fees) and persistent storage
payments are also usually collected in Grams.

\nxpoint \embt(Subdivision and terminology.)  A {\em Gram\/} is
subdivided into one billion ($10^9$) smaller units, called {\em
  nanograms}, {\em ngrams} or simply {\em nanos}. All transfers and
account balances are expressed as non-negative integer multiples of
nanos. Other units include:
\begin{itemize}
\item A {\em nano}, {\em ngram} or {\em nanogram} is the smallest
  unit, equal to $10^{-9}$ Grams.
\item A {\em micro\/} or {\em microgram\/} equals one thousand
  ($10^3$) nanos.
\item A {\em milli\/} is one million ($10^6$) nanos, or one thousandth
  part ($10^{-3}$) of a Gram.
\item A {\em Gram\/} equals one billion ($10^9$) nanos.
\item A {\em kilogram}, or {\em kGram}, equals one thousand ($10^3$)
  Grams.
\item A {\em megagram}, or {\em MGram}, equals one million ($10^6$)
  Grams, or $10^{15}$ nanos.
\item Finally, a {\em gigagram}, or {\em GGram}, equals one billion
  ($10^9$) Grams, or $10^{18}$ nanos.
\end{itemize}

There will be no need for larger units, because the initial supply of
Grams will be limited to five billion ($5\cdot10^9$) Grams (i.e., 5
Gigagrams).

\nxpoint \embt(Smaller units for expressing gas prices.)  If the
necessity for smaller units arises, ``specks'' equal to $2^{-16}$
nanograms will be used. For example, gas prices may be indicated in
specks. However, the actual fee to be paid, computed as the product of
the gas price and the amount of gas consumed, will be always rounded
down to the nearest multiple of $2^{16}$ specks and expressed as an
integer number of nanos.

\nxpoint \embt(Original supply, mining rewards and inflation.)  The
total supply of Grams is originally limited to $5$ Gigagrams (i.e.,
five billion Grams or $5\cdot10^{18}$ nanos).

This supply will increase very slowly, as rewards to validators for
mining new masterchain and shardchain blocks accumulate. These rewards
would amount to approximately $20\%$ (the exact number may be adjusted
in future) of the validator's stake per year, provided the validator
diligently performs its duties, signs all blocks, never goes offline
and never signs invalid blocks. In this way, the validators will have
enough profit to invest into better and faster hardware needed to
process the ever growing quantity of users' transactions.

We expect that at most $10\%$\footnote{The maximum total amount of
  validator stakes is a configurable parameter of the blockchain, so
  this restriction can be enforced by the protocol if necessary.} of
the total supply of Grams, on average, will be bound in validator
stakes at any given moment. This will produce an inflation rate of
$2\%$ per year, and as a result, will double the total supply of Grams
(to ten Gigagrams) in 35 years. Essentially, this inflation represents
a payment made by all members of the community to the validators for
keeping the system up and running.

On the other hand, if a validator is caught misbehaving, a part or all
of its stake will be taken away as a punishment, and a larger portion
of it will subsequently be ``burned'', decreasing the total supply of
Grams. This would lead to deflation. A smaller portion of the fine may
be redistributed to the validator or the ``fisherman'' who committed a
proof of the guilty validator's misbehavior.

\nxpoint\label{sp:gram.price} \embt(Original price of Grams.)  The
price of the first Gram to be sold will equal approximately
$\$0.1$ (USD). Every subsequent Gram to be sold (by the TON Reserve,
controlled by the TON Foundation) will be priced one billionth higher
than the previous one. In this way, the $n$-th Gram to be put into
circulation will be sold at approximately
\begin{equation}\label{eq:gram.price}
  p(n)\approx 0.1\cdot (1+10^{-9})^n\quad\text{USD},
\end{equation}
or an approximately equivalent (because of quickly changing market
exchange rates) amount of other (crypto)currencies, such as BTC or
ETH.

\nxsubpoint\label{sp:exp.priced} \embt(Exponentially priced
cryptocurrencies.)  We say that the Gram is an {\em exponentially
  priced cryptocurrency}, meaning that the price of the $n$-th Gram to
be put into circulation is approximately $p(n)$ given by the formula
\begin{equation}
  p(n)=p_0\cdot e^{\alpha n}
\end{equation}
with specific values $p_0=0.1$ USD and $\alpha=10^{-9}$.

More precisely, a small fraction $dn$ of a new coin is worth
$p(n)\,dn$ dollars, once $n$ coins are put into circulation. (Here $n$
is not necessarily an integer.)

Other important parameters of such a cryptocurrency include $n$, the
total number of coins in circulation, and $N\geq n$, the total number
of coins that can exist. For the Gram, $N=5\cdot 10^9$.

\nxsubpoint \embt(Total price of first $n$ coins.)  The total price
$T(n)=\int_0^n p(n)\,dn\approx p(0)+p(1)+\cdots+p(n-1)$ of the first
$n$ coins of an exponentially priced cryptocurrency (e.g., the Gram)
to be put into circulation can be computed by
\begin{equation}
  T(n)=p_0\cdot\alpha^{-1}(e^{\alpha n}-1)\quad.
\end{equation}

\nxsubpoint \embt(Total price of next $\Delta n$ coins.)  The total
price $T(n+\Delta n)-T(n)$ of $\Delta n$ coins put into circulation
after $n$ previously existing coins can be computed by
\begin{equation}\label{eq:T.m.n}
  T(n+\Delta n)-T(n)=p_0\cdot\alpha^{-1}(e^{\alpha(n+\Delta n)}-e^{\alpha n})
  =p(n)\cdot\alpha^{-1}(e^{\alpha\,\Delta n}-1)\quad.
\end{equation}

\nxsubpoint \embt(Buying next coins with total value $T$.)  Suppose
that $n$ coins have already been put into circulation, and that one
wants to spend $T$ (dollars) on buying new coins. The quantity of
newly-obtained coins $\Delta n$ can be computed by putting $T(n+\Delta
n)-T(n)=T$ into \eqref{eq:T.m.n}, yielding
\begin{equation}\label{eq:new.coins}
  \Delta n=\alpha^{-1}\log\left(1+\frac{T\cdot\alpha}{p(n)}\right)\quad.
\end{equation}
Of course, if $T\lll p(n)\alpha^{-1}$, then $\Delta n\approx T/p(n)$.

\nxsubpoint \embt(Market price of Grams.)  Of course, if the free
market price falls below $p(n):=0.1\cdot (1+10^{-9})^n$, once $n$
Grams are put into circulation, nobody would buy new Grams from the
TON Reserve; they would choose to buy their Grams on the free market
instead, without increasing the total quantity of Grams in
circulation. On the other hand, the market price of a Gram cannot
become much higher than $p(n)$, otherwise it would make sense to
obtain new Grams from the TON Reserve. This means that the market
price of Grams would not be subject to sudden spikes (and drops); this
is important because stakes (validator deposits) are frozen for at
least one month, and gas prices cannot change too fast either. So, the
overall economic stability of the system requires some mechanism that
would prevent the exchange rate of the Gram from changing too
drastically, such as the one described above.

\nxsubpoint \embt(Buying back the Grams.)  If the market price of the
Gram falls below $0.5\cdot p(n)$, when there are a total of $n$ Grams
in circulation (i.e., not kept on a special account controlled by the
TON Reserve), the TON Reserve reserves the right to buy some Grams
back and decrease $n$, the total quantity of Grams in
circulation. This may be required to prevent sudden falls of the
Gram exchange rate.

\nxsubpoint \embt(Selling new Grams at a higher price.)  The TON
Reserve will sell only up to one half (i.e., $2.5\cdot10^9$ Grams) of
the total supply of Grams according to the price
formula~\eqref{eq:gram.price}.  It reserves the right not to sell any
of the remaining Grams at all, or to sell them at a higher price than
$p(n)$, but never at a lower price (taking into account the uncertainty
of quickly changing exchange rates). The rationale here is that once
at least half of all Grams have been sold, the total value of the Gram
market will be sufficiently high, and it will be more difficult for outside forces to manipulate the exchange rate than it may be at the very
beginning of the Gram's deployment.

\nxpoint\label{sp:unalloc.gr} \embt(Using unallocated Grams.)  The TON
Reserve will use the bulk of ``unallocated'' Grams (approximately
$5\cdot10^9-n$ Grams)---i.e., those residing in the special account of
the TON Reserve and some other accounts explicitly linked to it---only
as validator stakes (because the TON Foundation itself will likely
have to provide most of the validators during the first deployment
phase of the TON Blockchain), and for voting in the masterchain for or
against proposals concerning changes in the ``configurable
parameters'' and other protocol changes, in the way determined by the
TON Foundation (i.e., its creators---the development team). This also
means that the TON Foundation will have a majority of votes during the
first deployment phase of the TON Blockchain, which may be useful if a
lot of parameters end up needing to be adjusted, or if the need arises
for hard or soft forks. Later, when less than half of all Grams remain
under control of the TON Foundation, the system will become more
democratic. Hopefully it will have become more mature by then, without
the need to adjust parameters too frequently.

\nxsubpoint\label{sp:dev.grams} \embt(Some unallocated Grams will be
given to developers.)  A predefined (relatively small) quantity of
``unallocated'' Grams (e.g., 200 Megagrams, equal to 4\% of the total
supply) will be transferred during the deployment of the TON
Blockchain to a special account controlled by the TON Foundation, and
then some ``rewards'' may be paid from this account to the developers
of the open source TON software, with a minimum two-year vesting
period.

\nxsubpoint\label{sp:TON.own.grams} \embt(The TON Foundation needs
Grams for operational purposes.)  Recall that the TON Foundation will
receive the fiat and cryptocurrency obtained by selling Grams from the
TON Reserve, and will use them for the development and deployment of
the TON Project. For instance, the original set of validators, as well
as an initial set of TON Storage and TON Proxy nodes may be installed
by the TON Foundation.

While this is necessary for the quick start of the project, the
ultimate goal is to make the project as decentralized as possible. To
this end, the TON Foundation may need to encourage installation of
third-party validators and TON Storage and TON Proxy nodes---for
example, by paying them for storing old blocks of the TON Blockchain
or proxying network traffic of a selected subset of services. Such
payments will be made in Grams; therefore, the TON Foundation will
need a significant amount of Grams for operational purposes.

\nxsubpoint \embt(Taking a pre-arranged amount from the Reserve.) The
TON Foundation will transfer to its account a small part of the TON
Reserve---say, 10\% of all coins (i.e.\ 500 Megagrams) after the end
of the initial sale of Grams---to be used for its own purposes as
outlined in~\ptref{sp:TON.own.grams}. This is best done simultaneously
with the transfer of the funds intended for TON developers, as
mentioned in~\ptref{sp:dev.grams}.

After the transfers to the TON Foundation and the TON developers, the
TON Reserve price $p(n)$ of the Gram will immediately rise by a
certain amount, known in advance. For example, if 10\% of all coins
are transferred for the purposes of the TON Foundation, and 4\% are
transferred for the encouragement of the developers, then the total
quantity $n$ of coins in circulation will immediately increase by
$\Delta n=7\cdot10^8$, with the price of the Gram multiplying by
$e^{\alpha\,\Delta n}=e^{0.7}\approx 2$ (i.e, doubling).

The remainding ``unallocated'' Grams will be used by the TON Reserve
as explained above in~\ptref{sp:unalloc.gr}. If the TON Foundation
needs any more Grams thereafter, it will simply convert into Grams
some of the funds it had previously obtained during the sale of the
coins, either on the free market or by buying Grams from the TON
Reserve.  To prevent excessive centralization, the TON Foundation will
never endeavour to have more than 10\% of the total amount of Grams
(i.e., 500 Megagrams) on its account.

\nxpoint\label{sp:bulk.sales} \embt(Bulk sales of Grams.)  When a lot
of people simultaneously want to buy large amounts of Grams from the
TON Reserve, it makes sense not to process their orders immediately,
because this would lead to results very dependent on the timing of
specific orders and their processing sequence.

Instead, orders for buying Grams may be collected during some
pre-defined period of time (e.g., a day or a month) and then processed
all together at once. If $k$ orders with $i$-th order worth $T_i$
dollars arrive, then the total amount $T=T_1+T_2+\cdots+T_k$ is used
to buy $\Delta n$ new coins according to \eqref{eq:new.coins}, and the
sender of the $i$-th order is allotted $\Delta n\cdot T_i/T$ of these
coins. In this way, all buyers obtain their Grams at the same average
price of $T/\Delta n$ USD per Gram.

After that, a new round of collecting orders for buying new Grams
begins.

When the total value of Gram buying orders becomes low enough, this
system of ``bulk sales'' may be replaced with a system of immediate
sales of Grams from the TON Reserve according to
formula~\eqref{eq:new.coins}.

The ``bulk sales'' mechanism will probably be used extensively during
the initial phase of collecting investments in the TON Project.

\end{document}
