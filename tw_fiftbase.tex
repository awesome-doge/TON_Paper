\documentclass[12pt,oneside]{article}
\usepackage{xeCJK}
\setCJKmainfont{Noto Serif CJK TC}

%\usepackage[T1]{fontenc}
%\usepackage{euler}
\usepackage{amssymb, amsmath, amsfonts, stmaryrd}
\usepackage[mathscr]{euscript}
\usepackage{mathrsfs}
\usepackage{theorem}
%\usepackage[english]{babel}
\usepackage{bm}
\usepackage[all]{xy}
\usepackage{array}
\usepackage{multirow}
%\usepackage{chngcntr}
%\CompileMatrices
\usepackage[bookmarks=false,pdfauthor={Nikolai Durov},pdftitle={Fift: A Brief Introduction}]{hyperref}
\usepackage{fancyhdr}
\usepackage{caption}
%
\setlength{\headheight}{15.2pt}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.5pt}
%
\def\makepoint#1{\medbreak\noindent{\bf #1.\ }}
\def\zeropoint{\setcounter{subsection}{-1}}
\def\zerosubpoint{\setcounter{subsubsection}{-1}}
\def\nxpoint{\refstepcounter{subsection}%
  \smallbreak\makepoint{\thesubsection}}
\def\nxsubpoint{\refstepcounter{subsubsection}%
  \smallbreak\makepoint{\thesubsubsection}}
\def\nxsubsubpoint{\refstepcounter{paragraph}%
  \makepoint{\paragraph}}
%\setcounter{secnumdepth}{4}
%\counterwithin{paragraph}{subsubsection}
\def\refpoint#1{{\rm\textbf{\ref{#1}}}}
\let\ptref=\refpoint
\def\embt(#1.){\textbf{#1.}}
\def\embtx(#1){\textbf{#1}}
\def\emb#1{\textbf{#1.}}
\long\def\nodo#1{}
%
%\def\markbothsame#1{\markboth{#1}{#1}}
\fancyhf{}
\fancyfoot[C]{\thepage}
\def\markbothsame#1{\fancyhead[C]{#1}}
\def\mysection#1{\section{#1}\fancyhead[C]{\textsc{Chapter \textbf{\thesection.} #1}}}
\def\mysubsection#1{\subsection{#1}\fancyhead[C]{\small{\textsc{\textrm{\thesubsection.} #1}}}}
\def\myappendix#1{\section{#1}\fancyhead[C]{\textsc{Appendix \textbf{\thesection.} #1}}}
%
\let\tp=\textit
\let\vr=\textit
\def\workchainid{\vr{workchain\_id\/}}
\def\shardpfx{\vr{shard\_prefix}}
\def\accountid{\vr{account\_id\/}}
\def\currencyid{\vr{currency\_id\/}}
\def\uint{\tp{uint}}
\def\opsc#1{\operatorname{\textsc{#1}}}
\def\CellRepr{\opsc{CellRepr}}
\def\blkseqno{\opsc{blk-seqno}}
\def\blkprev{\opsc{blk-prev}}
\def\blkhash{\opsc{blk-hash}}
\def\Hash{\opsc{Hash}}
\def\Sha{\opsc{sha256}}
\def\SHA#1{\opsc{sha#1}}
\def\Int{\opsc{int}}
\def\height{\opsc{height}}
\def\len{\opsc{len}}
\def\leaf{\opsc{Leaf}}
\def\node{\opsc{Node}}
\def\Seqno{\opsc{SeqNo}}
\def\LT{\opsc{Lt}}
\def\NextHop{\opsc{NextHop}}
\def\root{\opsc{Root}}
\def\emptyroot{\opsc{EmptyRoot}}
\def\code{\opsc{code}}
\def\Ping{\opsc{Ping}}
\def\Store{\opsc{Store}}
\def\FindNode{\opsc{Find\_Node}}
\def\FindValue{\opsc{Find\_Value}}
\def\Bytes{\tp{Bytes}}
\def\Transaction{\tp{Transaction}}
\def\Account{\tp{Account}}
\def\State{\tp{State}}
\def\Maybe{\opsc{Maybe}}
\def\List{\opsc{List}}
\def\Block{\tp{Block}}
\def\Blockchain{\tp{Blockchain}}
\def\isValidBc{\tp{isValidBc}}
\def\evtrans{\vr{ev\_trans}}
\def\evblock{\vr{ev\_block}}
\def\Hashmap{\tp{Hashmap}}
\def\HashmapE{\tp{HashmapE}}
\def\Type{\tp{Type}}
\def\nat{\tp{nat\/}}
\def\hget{\vr{hget\/}}
\def\bbB{{\mathbb{B}}}
\def\bbP{{\mathbb{P}}}
\def\bbF{{\mathbb{F}}}
\def\bbZ{{\mathbb{Z}}}
\def\st#1{{\mathbf{#1}}}
\def\sgn{\operatorname{sgn}}
\def\charact{\operatorname{char}}
\def\caret{\^{}}
\def\cF{\mathscr{F}}
%
\hfuzz=0.8pt

\title{Fift：簡介}
\author{Nikolai Durov\\
譯者：Dr. Awesome Doge}
\begin{document}

%\pagestyle{myheadings}
\maketitle

\begin{abstract}
  本文旨在簡要介紹 Fift，這是一種專門為建立和管理 TON 區塊鏈智慧合約而設計的新程式語言，以及其用於與 TON 虛擬機~\cite{TVM} 和 TON 區塊鏈~\cite{TBC} 互動的功能。
\end{abstract}

\section*{引言}
\markbothsame{引言}

本文件簡要介紹 Fift，這是一種基於堆疊的通用程式語言，經過最佳化以建立、除錯和管理 TON 區塊鏈智慧合約。

Fift 專門設計用於與 TON 虛擬機（TON VM 或 TVM）~\cite{TVM} 和 TON 區塊鏈~\cite{TBC} 互動。特別是，它原生支援與 TVM 共享的 257 位元整數運算和 TVM 單元操作，以及 TON 區塊鏈採用的基於 Ed25519 的密碼學介面。Fift 發行版中還包含用於編寫新智慧合約的 TVM 程式碼巨集組譯器。

作為一種基於堆疊的語言，Fift 與 Forth 類似。由於本文的簡潔性，對 Forth 的一些了解可能有助於理解 Fift。\footnote{有很好的 Forth 入門書籍；我們推薦~\cite{Brodie}。}然而，這兩種語言之間存在顯著差異。例如，Fift 強制執行執行時期型別檢查，並在其堆疊中保留不同型別的值（不僅僅是整數）。

Fift 中定義的詞彙（內建函數或原語）列表及其簡要說明，呈現在附錄~\ref{app:words} 中。

請注意，本文件的當前版本描述了 Fift 的初步測試版本；某些細節可能會在將來發生變化。

\clearpage
\tableofcontents

\clearpage
\mysection{概述}\label{sect:overview}

Fift 是一種簡單的基於堆疊的程式語言，設計用於測試和除錯 TON 虛擬機 \cite{TVM} 和 TON 區塊鏈 \cite{TBC}，但也可能適用於其他用途。當 Fift 被呼叫時（通常透過執行名為 {\tt fift} 的二進位檔案），它要麼讀取、解析並解釋命令列中指示的一個或多個來源檔案，要麼進入互動模式並解釋從標準輸入讀取和解析的 Fift 命令。還有一種「腳本模式」，透過命令列開關 {\tt -s} 啟動，在此模式下，除第一個參數外的所有命令列參數透過變數 {\tt \$$n$} 和 {\tt \$\#} 傳遞給 Fift 程式。這樣，Fift 既可用於互動式實驗和除錯，也可用於編寫簡單的腳本。

Fift 操作的所有資料都保存在一個（後進先出）堆疊中。每個堆疊條目都附加了一個{\em 型別標籤}，它明確地確定儲存在相應堆疊條目中的值的型別。Fift 支援的值型別包括 {\em Integer}（表示帶符號的 257 位元整數）、{\em Cell}（表示 TVM 單元，由最多 1023 個資料位元和最多四個對其他單元的參考組成，如 \cite{TVM} 中所述）、{\em Slice}（用於解析單元的 {\em Cell} 部分視圖）和 {\em Builder}（用於建構新單元）。這些資料型別（及其實作）與 TVM~\cite{TVM} 共享，並且可以在必要時安全地從 Fift 堆疊傳遞到 TVM 堆疊，反之亦然（例如，當使用 Fift 原語（如 {\tt runvmcode}）從 Fift 呼叫 TVM 時）。

除了與 TVM 共享的資料型別外，Fift 還引入了一些獨特的資料型別，例如 {\em Bytes}（任意位元組序列）、{\em String}（UTF-8 字串）、{\em WordList} 和 {\em WordDef}（由 Fift 用於建立新的「詞彙」並操作其定義）。事實上，Fift 可以擴展以操作任意「物件」（由通用型別 {\em Object} 表示），前提是它們在當前實作中派生自 C++ 類別 {\tt td::CntObject}。

Fift 來源檔案和函式庫通常保存在後綴為 {\tt .fif} 的文字檔案中。函式庫和包含檔案的搜尋路徑透過 {\tt -I} 命令列參數或 {\tt FIFTPATH} 環境變數傳遞給 Fift 執行檔。如果兩者都未設定，則使用預設函式庫搜尋路徑 {\tt /usr/lib/fift}。

在啟動時，標準 Fift 函式庫從檔案 {\tt Fift.fif} 讀取，然後才解釋任何其他來源。它必須存在於函式庫搜尋路徑中，否則 Fift 執行將失敗。

Fift 的基本資料結構是其全域{\em 字典}，包含{\em 詞彙}——或者更準確地說，{\em 詞彙定義}——對應於內建原語和函數以及使用者定義的函數。\footnote{Fift 詞彙通常比其他程式語言的函數或子程式更短。可以在~\cite{Brodie2} 中找到不錯的討論和一些指南（針對 Forth 詞彙）。}在 Fift 中，只需在互動模式下輸入詞彙的名稱（不帶空格字元的 UTF-8 字串）即可執行該詞彙。當 Fift 啟動時，一些詞彙（{\em 原語}）已經被定義（在當前實作中透過一些 C++ 程式碼）；其他詞彙在標準函式庫 {\tt Fift.fif} 中定義。之後，使用者可以透過定義新詞彙或重新定義舊詞彙來擴展字典。

字典應該被分割成多個{\em 詞彙表}或{\em 命名空間}；然而，命名空間尚未實作，因此所有詞彙目前都在同一個全域命名空間中定義。

Fift 輸入來源檔案和標準輸入（在互動模式下）的解析器相當簡單：輸入逐行讀取，然後跳過空白字元，並偵測並從輸入行中移除剩餘行的最長前綴（即字典詞彙的名稱）。\footnote{請注意，與 Forth 不同，Fift 詞彙名稱區分大小寫：{\tt dup} 和 {\tt DUP} 是不同的詞彙。}之後，執行找到的詞彙，並重複此過程直到行尾。當輸入行耗盡時，從當前輸入檔案或標準輸入讀取後續行。

為了被偵測，大多數詞彙需要在它們之後立即有一個空白字元或行尾；這透過在字典中的詞彙名稱後附加空格來反映。其他詞彙，稱為{\em 前綴詞彙}，不需要在它們之後立即有空白字元。

如果沒有找到詞彙，則將輸入行的第一個剩餘字元直到下一個空白或行尾字元組成的字串解釋為{\em Integer} 並推入堆疊。例如，如果我們呼叫 Fift，輸入 {\tt 2 3 + .}（並按 Enter），Fift 首先將等於 $2$ 的 {\em Integer} 常數推入其堆疊，然後是等於 $3$ 的另一個整數常數。之後，內建原語「{\tt +}」被解析並在字典中找到；當呼叫時，它從堆疊中取出兩個最頂層的元素並用它們的和（在我們的例子中為 $5$）替換它們。最後，「{\tt .}」是一個原語，它列印堆疊頂部 {\em Integer} 的十進位表示，後跟一個空格。結果，我們觀察到 Fift 解釋器在標準輸出中列印「{\tt 5 ok}」。字串「{\tt ok}」由解釋器在互動模式下完成解釋從標準輸入讀取的行時列印。

內建詞彙列表可以在附錄~\ref{app:words} 中找到。

\mysection{Fift 基礎}
本章介紹 Fift 程式語言的基本功能。討論最初是非正式和不完整的，但逐漸變得更正式和更精確。在某些情況下，後面的章節和附錄~\ref{app:words} 提供了關於本章首次提及的詞彙的更多細節；類似地，一些將在後面章節中詳細解釋的技巧已經在此處適當使用。

\mysubsection{Fift 堆疊值型別列表}\label{p:stack.types}
目前，以下資料型別的值可以保存在 Fift 堆疊中：
\begin{itemize}
\item {\em Integer} --- 帶符號的 257 位元整數。在堆疊記號中通常用 $x$、$y$ 或 $z$ 表示（當描述 Fift 詞彙的堆疊效果時）。
\item {\em Cell} --- TVM 單元，由最多 1023 個資料位元和最多 4 個對其他單元的參考組成（參見~\cite{TVM}）。通常用~$c$ 或其變體表示，例如 $c'$ 或 $c_2$。
\item {\em Slice} --- TVM 單元的部分視圖，用於從 {\em Cell} 中解析資料。通常用~$s$ 表示。
\item {\em Builder} --- 部分建構的 {\em Cell}，包含最多 1023 個資料位元和最多四個參考；可用於建立新的 {\em Cell}。通常用~$b$ 表示。
\item {\em Null} --- 具有唯一「空」值的型別。用於初始化新的 {\em Box}。通常用~$\bot$ 表示。
\item {\em Tuple} --- 這些型別中任何型別的值的有序集合（不一定相同）；可用於表示任意代數資料型別和 Lisp 風格列表的值。
\item {\em String} --- （通常是可列印的）UTF-8 字串。通常用~$S$ 表示。
\item {\em Bytes} --- 任意 8 位元位元組序列，通常用於表示二進位資料。通常用~$B$ 表示。
\item {\em WordList} --- （部分建立的）詞彙參考列表，用於建立新的 Fift 詞彙定義。通常用~$l$ 表示。
\item {\em WordDef} --- 執行權杖，通常表示現有 Fift 詞彙的定義。通常用~$e$ 表示。
\item {\em Box} --- 記憶體中可用於儲存一個堆疊值的位置。通常用~$p$ 表示。
\item {\em Atom} --- 由其名稱（字串）唯一標識的簡單實體。可用於表示識別符號、標籤、操作名稱、標記和堆疊標記。通常用~$a$ 表示。
\item {\em Object} --- 派生自基底類別 {\tt td::CntObject} 的任何類別的任意 C++ 物件；可由 Fift 擴充功能用於操作其他資料型別並與其他 C++ 函式庫介面。
\end{itemize}

上面列出的前六種型別與 TVM 共享；其餘的是 Fift 特定的。請注意，並非所有 TVM 堆疊型別都出現在 Fift 中。例如，TVM {\em Continuation} 型別未被 Fift 明確識別；如果此型別的值最終出現在 Fift 堆疊中，它將作為通用 {\em Object} 進行操作。

\mysubsection{註解}\label{p:comments}
Fift 識別兩種註解：「{\tt // }」（後面必須跟一個空格）開啟單行註解直到行尾，{\tt /*} 定義多行註解直到 {\tt */}。詞彙 {\tt //} 和 {\tt /*} 都在標準 Fift 函式庫（{\tt Fift.fif}）中定義。

\mysubsection{終止 Fift}\label{p:exit.fift}
詞彙 {\tt bye} 以零退出碼終止 Fift 解釋器。如果需要非零退出碼（例如，在 Fift 腳本中），可以使用詞彙 {\tt halt}，它以給定的退出碼（作為堆疊頂部的 {\em Integer} 傳遞）終止 Fift。相反，{\tt quit} 不退出到作業系統，而是退出到 Fift 解釋器的頂層。

\mysubsection{簡單整數運算}\label{p:arith.op}
當 Fift 遇到字典中不存在但可以解釋為整數常數（或「字面值」）的詞彙時，其值被推入堆疊（如~\ptref{p:int.lit} 中更詳細地解釋的那樣）。除此之外，定義了幾個整數算術原語：
\begin{itemize}
\item {\tt +}（$x$ $y$ -- $x+y$），用堆疊頂部傳遞的兩個 {\em Integer} $x$ 和 $y$ 的和 $x+y$ 替換它們。所有更深的堆疊元素保持不變。如果 $x$ 或 $y$ 不是 {\em Integer}，或者如果和不適合帶符號的 257 位元 {\em Integer}，則拋出異常。
\item {\tt -}（$x$ $y$ -- $x-y$），計算兩個 {\em Integer} $x$ 和 $y$ 的差 $x-y$。請注意，第一個參數 $x$ 是距堆疊頂部的第二個條目，而第二個參數 $y$ 從堆疊頂部取得。
\item {\tt negate}（$x$ -- $-x$），改變 {\em Integer} 的符號。
\item {\tt *}（$x$ $y$ -- $xy$），計算兩個 {\em Integer} $x$ 和 $y$ 的積 $xy$。
\item {\tt /}（$x$ $y$ -- $q:=\lfloor x/y\rfloor$），計算兩個 {\em Integer} 的向下取整商 $\lfloor x/y\rfloor$。
\item {\tt mod}（$x$ $y$ -- $r:=x\bmod y$），計算 $x$ 除以 $y$ 的餘數 $x\bmod y=x-y\cdot\lfloor x/y\rfloor$。
\item {\tt /mod}（$x$ $y$ -- $q$ $r$），同時計算商和餘數。
\item {\tt /c}、{\tt /r}（$x$ $y$ -- $q$），類似於 {\tt /} 的除法詞彙，但分別使用向上取整（$q:=\lceil x/y\rceil$）和最接近整數取整（$q:=\lfloor 1/2+x/y\rfloor$）。
\item {\tt /cmod}、{\tt /rmod}（$x$ $y$ -- $q$ $r:=x-qy$），類似於 {\tt /mod} 的除法詞彙，但使用向上取整或最接近整數取整。
\item {\tt <{}<}（$x$ $y$ -- $x\cdot 2^y$），計算二進位數 $x$ 的算術左移 $y\geq0$ 個位置，產生 $x\cdot 2^y$。
\item {\tt >{}>}（$x$ $y$ -- $q:=\lfloor x\cdot 2^{-y}\rfloor$），計算算術右移 $y\geq0$ 個位置。
\item {\tt >{}>c}、{\tt >{}>r}（$x$ $y$ -- $q$），類似於 {\tt >{}>}，但使用向上取整或最接近整數取整。
\item {\tt and}、{\tt or}、{\tt xor}（$x$ $y$ -- $x\oplus y$），計算兩個 {\em Integer} 的位元 AND、OR 或 XOR。
\item {\tt not}（$x$ -- $-1-x$），{\em Integer} 的位元補數。
\item {\tt */}（$x$ $y$ $z$ -- $\lfloor xy/z\rfloor$），「先乘後除」：將兩個整數 $x$ 和 $y$ 相乘產生 513 位元中間結果，然後將乘積除以 $z$。
\item {\tt */mod}（$x$ $y$ $z$ -- $q$ $r$），類似於 {\tt */}，但同時計算商和餘數。
\item {\tt */c}、{\tt */r}（$x$ $y$ $z$ -- $q$）、{\tt */cmod}、{\tt */rmod}（$x$ $y$ $z$ -- $q$ $r$），類似於 {\tt */} 或 {\tt */mod}，但使用向上取整或最接近整數取整。
\item {\tt *>{}>}、{\tt *>{}>c}、{\tt *>{}>r}（$x$ $y$ $z$ -- $q$），類似於 {\tt */} 及其變體，但用右移替換除法。計算以指示方式（向下、向上或最接近整數）取整的 $q=xy/2^z$。
\item {\tt <{}</}、{\tt <{}</c}、{\tt <{}</r}（$x$ $y$ $z$ -- $q$），類似於 {\tt */}，但用左移替換乘法。計算以指示方式取整的 $q=2^zx/y$（注意與 {\tt */} 相比，參數 $y$ 和 $z$ 的順序不同）。
\end{itemize}

此外，詞彙「{\tt .}」可用於列印堆疊頂部傳遞的 {\em Integer} 的十進位表示（後跟單個空格），「{\tt x.}」列印堆疊頂部整數的十六進位表示。之後整數從堆疊中移除。

上述原語可用於在互動模式下使用 Fift 解釋器作為以逆波蘭記號（運算符號在運算元之後）表示的算術表示式的簡單計算器。例如，
\begin{verbatim}
7 4 - .
\end{verbatim}
計算 $7-4=3$ 並列印「{\tt 3 ok}」，和
\begin{verbatim}
2 3 4 * + .
2 3 + 4 * .
\end{verbatim}
計算 $2+3\cdot 4=14$ 和 $(2+3)\cdot 4=20$，並列印「{\tt 14 20 ok}」。

\mysubsection{堆疊操作詞彙}\label{p:stack.ops}
堆疊操作詞彙重新排列堆疊頂部附近的一個或多個值，無論其型別如何，並保持所有更深的堆疊值不變。下面列出了一些最常用的堆疊操作詞彙：
\begin{itemize}
\item {\tt dup}（$x$ -- $x$ $x$），複製堆疊頂部條目。如果堆疊為空，則拋出異常。\footnote{請注意，Fift 詞彙名稱區分大小寫，因此不能輸入 {\tt DUP} 而不是 {\tt dup}。}
\item {\tt drop}（$x$ -- ），移除堆疊頂部條目。
\item {\tt swap}（$x$ $y$ -- $y$ $x$），交換兩個最頂層的堆疊條目。
\item {\tt rot}（$x$ $y$ $z$ -- $y$ $z$ $x$），旋轉三個最頂層的堆疊條目。
\item {\tt -rot}（$x$ $y$ $z$ -- $z$ $x$ $y$），以相反方向旋轉三個最頂層的堆疊條目。等同於 {\tt rot rot}。
\item {\tt over}（$x$ $y$ -- $x$ $y$ $x$），在堆疊頂部條目之上建立距頂部第二個堆疊條目的副本。
\item {\tt tuck}（$x$ $y$ -- $y$ $x$ $y$），等同於 {\tt swap over}。
\item {\tt nip}（$x$ $y$ -- $y$），移除距頂部的第二個堆疊條目。等同於 {\tt swap drop}。
\item {\tt 2dup}（$x$ $y$ -- $x$ $y$ $x$ $y$），等同於 {\tt over over}。
\item {\tt 2drop}（$x$ $y$ -- ），等同於 {\tt drop drop}。
\item {\tt 2swap}（$a$ $b$ $c$ $d$ -- $c$ $d$ $a$ $b$），交換兩對最頂層的堆疊條目。
\item {\tt pick}（$x_n$ \dots $x_0$ $n$ -- $x_n$ \dots $x_0$ $x_n$），建立距堆疊頂部第 $n$ 個條目的副本，其中 $n\geq0$ 也在堆疊中傳遞。特別是，{\tt 0 pick} 等同於 {\tt dup}，{\tt 1 pick} 等同於 {\tt over}。
\item {\tt roll}（$x_n$ \dots $x_0$ $n$ -- $x_{n-1}$ \dots $x_0$ $x_n$），旋轉前 $n$ 個堆疊條目，其中 $n\geq0$ 也在堆疊中傳遞。特別是，{\tt 1 roll} 等同於 {\tt swap}，{\tt 2 roll} 等同於 {\tt rot}。
\item {\tt -roll}（$x_n$ \dots $x_0$ $n$ -- $x_0$ $x_n$ \dots $x_1$），以相反方向旋轉前 $n$ 個堆疊條目，其中 $n\geq0$ 也在堆疊中傳遞。特別是，{\tt 1 -roll} 等同於 {\tt swap}，{\tt 2 -roll} 等同於 {\tt -rot}。
\item {\tt exch}（$x_n$ \dots $x_0$ $n$ -- $x_0$ \dots $x_n$），將堆疊頂部與距頂部第 $n$ 個堆疊條目交換，其中 $n\geq0$ 也從堆疊中取得。特別是，{\tt 1 exch} 等同於 {\tt swap}，{\tt 2 exch} 等同於 {\tt swap rot}。
\item {\tt exch2}（\dots $n$ $m$ -- \dots），將距頂部第 $n$ 個堆疊條目與距頂部第 $m$ 個堆疊條目交換，其中 $n\geq0$、$m\geq0$ 從堆疊中取得。
\item {\tt ?dup}（$x$ -- $x$ $x$ 或 $0$），複製 {\em Integer} $x$，但僅當它非零時。否則保持不變。
\end{itemize}
例如，「{\tt 5 dup * .}」將計算 $5\cdot 5=25$ 並列印「{\tt 25 ok}」。

可以使用詞彙「{\tt .s}」——它列印整個堆疊的內容，從最深的元素開始，而不從堆疊中移除列印的元素——隨時檢查堆疊的內容，並檢查任何堆疊操作詞彙的效果。例如，
\begin{verbatim}
1 2 3 4 .s
rot .s
\end{verbatim}
列印
\begin{verbatim}
1 2 3 4
 ok
1 3 4 2
 ok
\end{verbatim}

當 Fift 不知道如何列印未知型別的堆疊值時，它會列印 {\tt ???}。

\mysubsection{定義新詞彙}\label{p:colon.def}
最簡單的形式，定義新的 Fift 詞彙非常容易，可以藉助三個特殊詞彙來完成：「{\tt \{}」、「{\tt \}}」和「{\tt :}」。只需用 {\tt \{}（後面必須跟一個空格）打開定義，然後列出構成新定義的所有詞彙，然後用 {\tt \}}（也跟一個空格）關閉定義，最後透過編寫 {\tt:\ $\langle\textit{new-word-name}\rangle$} 將結果定義（由堆疊中的 {\em WordDef} 值表示）分配給新詞彙。例如，
\begin{verbatim}
{ dup * } : square
\end{verbatim}
定義了一個新詞彙 {\tt square}，它在呼叫時執行 {\tt dup} 和 {\tt *}。這樣，輸入 {\tt 5 square} 就等同於輸入 {\tt 5 dup *}，並產生相同的結果（$25$）：
\begin{verbatim}
5 square .
\end{verbatim}
列印「{\tt 25 ok}」。還可以將新詞彙用作新定義的一部分：
\begin{verbatim}
{ dup square square * } : **5
3 **5 .
\end{verbatim}
列印「{\tt 243 ok}」，這確實是 $3^5$。

如果「{\tt :}」之後指示的詞彙已經定義，它將被默默地重新定義。然而，所有其他詞彙的現有定義將繼續使用重新定義詞彙的舊定義。例如，如果我們在已經如上定義 {\tt **5} 之後重新定義 {\tt square}，{\tt **5} 將繼續使用 {\tt square} 的原始定義。

\mysubsection{命名常數}\label{p:constants}
可以透過使用定義詞彙 {\tt constant} 而不是定義詞彙「{\tt :}」（冒號）來定義{\em（命名）常數}——即在呼叫時推入預定義值的詞彙。例如，
\begin{verbatim}
1000000000 constant Gram
\end{verbatim}
定義了等於 {\em Integer} $10^9$ 的常數 {\tt Gram}。換句話說，每當呼叫 {\tt Gram} 時，$1000000000$ 將被推入堆疊：
\begin{verbatim}
Gram 2 * .
\end{verbatim}
列印「{\tt 2000000000 ok}」。

當然，可以使用計算結果來初始化常數的值：
\begin{verbatim}
Gram 1000 / constant mGram
mGram .
\end{verbatim}
列印「{\tt 1000000 ok}」。

常數的值不一定必須是 {\em Integer}。例如，可以用相同的方式定義字串常數：
\begin{verbatim}
"Hello, world!" constant hello
hello type cr
\end{verbatim}
在單獨一行上列印「{\tt Hello, world!}」。

如果重新定義常數，所有其他詞彙的現有定義將繼續使用常數的舊值。在這方面，常數的行為不像全域變數。

還可以使用定義詞彙 {\tt 2constant} 將兩個值儲存到一個「雙」常數中。例如，
\begin{verbatim}
355 113 2constant pifrac
\end{verbatim}
定義了一個新詞彙 {\tt pifrac}，它在呼叫時將推入 $355$ 和 $113$（按此順序）。雙常數的兩個組成部分可以是不同型別。

如果想在區塊或冒號定義中建立具有固定名稱的常數，應使用 {\tt =:} 和 {\tt 2=:} 而不是 {\tt constant} 和 {\tt 2constant}：
\begin{verbatim}
{ dup =: x dup * =: y } : setxy
3 setxy x . y . x y + .
7 setxy x . y . x y + .
\end{verbatim}
產生
\begin{verbatim}
3 9 12  ok
7 49 56  ok
\end{verbatim}
如果想恢復這種「常數」的執行時期值，可以在常數名稱前加上詞彙 {\tt @'}：
\begin{verbatim}
{ ."( " @' x . .", " @' y . .") " } : showxy
3 setxy showxy
\end{verbatim}
產生
\begin{verbatim}
( 3 , 9 ) ok
\end{verbatim}
這種方法的缺點是 {\tt @'} 每次執行 {\tt showxy} 時都必須在字典中查找常數 {\tt x} 和 {\tt y} 的當前定義。變數（參見~\ptref{p:variables}）提供了一種更有效的方式來實現類似的結果。

\mysubsection{整數和分數常數，或字面值}\label{p:int.lit}
Fift 識別十進位、二進位和十六進位格式的未命名整數常數（稱為{\em 字面值}以將它們與命名常數區分開來）。二進位字面值以 {\tt 0b} 為前綴，十六進位字面值以 {\tt 0x} 為前綴，十進位字面值不需要前綴。例如，{\tt 0b1011}、{\tt 11} 和 {\tt 0xb} 表示相同的整數（$11$）。整數字面值可以以減號「{\tt -}」為前綴來改變其符號；減號在 {\tt 0x} 和 {\tt 0b} 前綴之前和之後都被接受。

當 Fift 遇到字典中不存在但是有效整數字面值（適合 257 位元帶符號整數型別 {\em Integer}）的字串時，其值被推入堆疊。

除此之外，Fift 對十進位和普通分數提供一些支援。如果字串由兩個由斜線 {\tt /} 分隔的有效整數字面值組成，則 Fift 將其解釋為分數字面值，並在堆疊中用兩個 {\em Integer} $p$ 和 $q$ 表示它，分子 $p$ 和分母 $q$。例如，{\tt -17/12} 將 $-17$ 和 $12$ 推入 Fift 堆疊（因此等同於 {\tt -17 12}），{\tt -0x11/0b1100} 做同樣的事情。十進位、二進位和十六進位分數，例如 {\tt 2.39} 或 {\tt -0x11.ef}，也由兩個整數 $p$ 和 $q$ 表示，其中 $q$ 是基數（分別為 10、2 或 16）的適當次方。例如，{\tt 2.39} 等同於 {\tt 239 100}，{\tt -0x11.ef} 等同於 {\tt -0x11ef 0x100}。

這種分數表示特別方便用於縮放原語 {\tt */} 及其變體，從而將普通和十進位分數轉換為適當的定點表示。例如，如果我們想用 nanogram 的整數數量表示 Gram 的分數數量，可以定義一些輔助詞彙
\begin{verbatim}
1000000000 constant Gram
{ Gram * } : Gram*
{ Gram swap */r } : Gram*/
\end{verbatim}
然後編寫 {\tt 2.39 Gram*/} 或 {\tt 17/12 Gram*/} 而不是整數字面值 {\tt 2390000000} 或 {\tt 1416666667}。

如果經常需要使用這樣的 Gram 字面值，可以如下引入新的主動前綴詞彙 {\tt GR\$}：
\begin{verbatim}
{ bl word (number) ?dup 0= abort"not a valid Gram amount"
  1- { Gram swap */r } { Gram * } cond
  1 'nop
} ::_ GR$
\end{verbatim}
使 {\tt GR\$3}、{\tt GR\$2.39} 和 {\tt GR\$17/12} 分別等同於整數字面值 {\tt 3000000000}、{\tt 2390000000} 和 {\tt 1416666667}。這樣的值可以透過以下詞彙以類似形式列印：
\begin{verbatim}
{ dup abs <# ' # 9 times char . hold #s rot sign #>
  nip -trailing0 } : (.GR)
{ (.GR) ."GR$" type space } : .GR
-17239000000 .GR
\end{verbatim}
產生 {\tt GR\$-17.239 ok}。上述定義使用了本文件後面部分（特別是第~\ptref{s:dict.compiler} 章）中解釋的技巧。

我們還可以透過定義適當的「有理數算術詞彙」來自己操作分數：
\begin{verbatim}
// a b c d -- (a*d-b*c) b*d
{ -rot over * 2swap tuck * rot - -rot * } : R-
// a b c d -- a*c b*d
{ rot * -rot * swap } : R*
// a b --
{ swap ._ ."/" . } : R.
1.7 2/3 R- R.
\end{verbatim}
將輸出「{\tt 31/30 ok}」，表示 $1.7-2/3=31/30$。這裡「{\tt .\_}」是「{\tt .}」的變體，它在 {\em Integer} 的十進位表示後不列印空格。

\mysubsection{字串字面值}\label{p:string.lit}
字串字面值透過前綴詞彙 {\tt "} 引入，它掃描該行的其餘部分直到下一個 {\tt "} 字元，並將由此獲得的字串作為型別 {\em String} 的值推入堆疊。例如，{\tt "Hello, world!"} 將相應的 {\em String} 推入堆疊：
\begin{verbatim}
"Hello, world!" .s
\end{verbatim}

\mysubsection{簡單字串操作}\label{p:string.ops}
以下詞彙可用於操作字串：
\begin{itemize}
\item {\tt"$\langle\textit{string}\rangle$"}（ -- $S$），將 {\em String} 字面值推入堆疊。
\item {\tt."$\langle\textit{string}\rangle$"}（ -- ），將常數字串列印到標準輸出。
\item {\tt type}（$S$ -- ），將從堆疊頂部取得的 {\em String} $S$ 列印到標準輸出。
\item {\tt cr}（ -- ），將回車（或換行字元）輸出到標準輸出。
\item {\tt emit}（$x$ -- ），將具有由 {\em Integer} $x$ 給出的 Unicode 碼點的 UTF-8 編碼字元列印到標準輸出。
\item {\tt char $\langle\textit{string}\rangle$}（ -- $x$），推入帶有 {\tt $\langle\textit{string}\rangle$} 第一個字元的 Unicode 碼點的 {\em Integer}。
\item {\tt bl}（ -- $x$），推入空格的 Unicode 碼點，即 32。
\item {\tt space}（ -- ），列印一個空格，等同於 {\tt bl emit}。
\item {\tt \$+}（$S$ $S'$ -- $S.S'$），串接兩個字串。
\item {\tt \$len}（$S$ -- $x$），計算字串的位元組長度（不是 UTF-8 字元長度！）。
\item {\tt +"$\langle\textit{string}\rangle$"}（$S$ -- $S'$），將 {\em String}~$S$ 與字串字面值串接。等同於 {\tt "$\langle\textit{string}\rangle$" \$+}。
\item {\tt word}（$x$ -- $S$），從當前輸入行的其餘部分解析由 Unicode 碼點 $x$ 的字元分隔的詞彙，並將結果作為 {\em String} 推入。例如，{\tt bl word abracadabra type} 將列印字串「{\tt abracadabra}」。如果 $x=0$，跳過前導空格，然後掃描到當前輸入行的末尾。如果 $x=32$，在解析下一個詞彙之前跳過前導空格。
\item {\tt (.)}（$x$ -- $S$），返回帶有 {\em Integer}~$x$ 十進位表示的 {\em String}。
\item {\tt (number)}（$S$ -- $0$ 或 $x$ $1$ 或 $x$ $y$ $2$），嘗試將 {\em String} $S$ 解析為~\ptref{p:int.lit} 中解釋的整數或分數字面值。
\end{itemize}
例如，{\tt ."*"}、{\tt "*" type}、{\tt 42 emit} 和 {\tt char * emit} 是輸出單個星號的四種不同方式。

\mysubsection{布林表示式，或旗標}\label{p:bool}
Fift 沒有用於表示布林值的單獨值型別。相反，任何非零 {\em Integer} 可用於表示真（$-1$ 是標準表示），而零 {\em Integer} 表示假。比較原語通常返回 $-1$ 表示成功，否則返回 $0$。

常數 {\tt true} 和 {\tt false} 可用於將這些特殊整數推入堆疊：
\begin{itemize}
\item {\tt true}（ -- $-1$），將 $-1$ 推入堆疊。
\item {\tt false}（ -- $0$），將 $0$ 推入堆疊。
\end{itemize}

如果布林值是標準的（$0$ 或 $-1$），可以透過~\ptref{p:arith.op} 中列出的位元邏輯運算 {\tt and}、{\tt or}、{\tt xor}、{\tt not} 來操作它們。否則，必須首先使用 {\tt 0<>} 將它們轉換為標準形式：
\begin{itemize}
\item {\tt 0<>}（$x$ -- $x\neq0$），如果 {\em Integer} $x$ 非零則推入 $-1$，否則推入 $0$。
\end{itemize}

\mysubsection{整數比較運算}\label{p:int.comp}
幾個整數比較運算可用於獲得布林值：
\begin{itemize}
\item {\tt <}（$x$ $y$ -- $?$），檢查 $x<y$ 是否成立（即如果 $x<y$ 則推入 $-1$，否則推入 $0$）。
\item {\tt >}、{\tt =}、{\tt <>}、{\tt <=}、{\tt >=}（$x$ $y$ -- $?$），比較 $x$ 和 $y$ 並根據比較結果推入 $-1$ 或 $0$。
\item {\tt 0<}（$x$ -- $?$），檢查 $x<0$ 是否成立（即如果 $x$ 為負則推入 $-1$，否則推入 $0$）。等同於 {\tt 0 <}。
\item {\tt 0>}、{\tt 0=}、{\tt 0<>}、{\tt 0<=}、{\tt 0>=}（$x$ -- $?$），將 $x$ 與零比較。
\item {\tt cmp}（$x$ $y$ -- $z$），如果 $x>y$ 則推入 $1$，如果 $x<y$ 則推入 $-1$，如果 $x=y$ 則推入 $0$。
\item {\tt sgn}（$x$ -- $y$），如果 $x>0$ 則推入 $1$，如果 $x<0$ 則推入 $-1$，如果 $x=0$ 則推入 $0$。等同於 {\tt 0 cmp}。
\end{itemize}
範例：
\begin{verbatim}
2 3 < .
\end{verbatim}
列印「{\tt -1 ok}」，因為 $2$ 小於 $3$。

一個更複雜的範例：
\begin{verbatim}
{ "true " "false " rot 0= 1+ pick type 2drop } : ?.
2 3 < ?.  2 3 = ?.  2 3 > ?.
\end{verbatim}
列印「{\tt true false false ok}」。

\mysubsection{字串比較運算}\label{p:string.cmp.ops}
字串可以透過以下詞彙進行字典序比較：
\begin{itemize}
\item {\tt \$=}（$S$ $S'$ -- $?$），如果字串 $S$ 和 $S'$ 相等則返回 $-1$，否則返回 $0$。
\item {\tt \$cmp}（$S$ $S'$ -- $x$），如果字串 $S$ 和 $S'$ 相等則返回 $0$，如果 $S$ 在字典序上小於 $S'$ 則返回 $-1$，如果 $S$ 在字典序上大於 $S'$ 則返回 $1$。
\end{itemize}

\mysubsection{命名和未命名變數}\label{p:variables}
除了~\ptref{p:constants} 中介紹的常數外，Fift 支援{\em 變數}，這是表示可變值的更有效方式。例如，~\ptref{p:constants} 的最後兩個程式碼片段可以使用變數而不是常數來編寫，如下所示：
\begin{verbatim}
variable x  variable y
{ dup x ! dup * y ! } : setxy
3 setxy x @ . y @ . x @ y @ + .
7 setxy x @ . y @ . x @ y @ + .
{ ."( " x @ . .", " y @ . .") " } : showxy
3 setxy showxy
\end{verbatim}
產生與之前相同的輸出：
\begin{verbatim}
3 9 12 ok
7 49 56 ok
( 3 , 9 ) ok
\end{verbatim}

短語 {\tt variable x} 建立一個新的 {\em Box}，即一個可用於儲存任何 Fift 支援型別的單一值的記憶體位置，並將 {\tt x} 定義為等於此 {\em Box} 的常數：
\begin{itemize}
\item {\tt variable}（ -- ），從輸入的其餘部分掃描以空白分隔的詞彙名稱 $S$，分配一個空的 {\em Box}，並將新的普通詞彙 $S$ 定義為常數，它在呼叫時將推入新的 {\em Box}。等同於 {\tt hole constant}。
\item {\tt hole}（ -- $p$），建立一個不包含任何值的新 {\em Box}~$p$。等同於 {\tt null box}。
\item {\tt box}（$x$ -- $p$），建立一個包含指定值~$x$ 的新 {\em Box}。等同於 {\tt hole tuck !}。
\end{itemize}
當前儲存在 {\em Box} 中的值可以透過詞彙 {\tt @}（發音為「fetch」）取得，並可以透過詞彙 {\tt !}（發音為「store」）修改：
\begin{itemize}
\item {\tt @}（$p$ -- $x$），取得當前儲存在 {\em Box}~$p$ 中的值。
\item {\tt !}（$x$ $p$ -- ），將新值~$x$ 儲存到 {\em Box}~$p$ 中。
\end{itemize}
存在幾個輔助詞彙可以更複雜的方式修改當前值：
\begin{itemize}
\item {\tt +!}（$x$ $p$ -- ），將儲存在 {\em Box}~$p$ 中的整數值增加 {\em Integer}~$x$。等同於 {\tt tuck @ + swap !}。
\item {\tt 1+!}（$p$ -- ），將儲存在 {\em Box}~$p$ 中的整數值增加一。等同於 {\tt 1 swap +!}。
\item {\tt 0!}（$p$ -- ），將 {\em Integer} $0$ 儲存到 {\em Box}~$p$ 中。等同於 {\tt 0 swap !}。
\end{itemize}
這樣我們可以實作一個簡單的計數器：
\begin{verbatim}
variable counter
{ counter 0! } : reset-counter
{ counter @ 1+ dup counter ! } : next-counter
reset-counter next-counter . next-counter . next-counter .
reset-counter next-counter .
\end{verbatim}
產生
\begin{verbatim}
1 2 3 ok
1 ok
\end{verbatim}
在這些定義就位後，我們甚至可以透過短語 {\tt forget counter} 忘記 {\tt counter} 的定義。那麼存取此變數值的唯一方法是透過 {\tt reset-counter} 和 {\tt next-counter}。

變數通常由 {\tt variable} 建立而沒有值，或者更確切地說具有 {\em Null} 值。如果想建立已初始化的變數，可以使用短語 {\tt box constant}：
\begin{verbatim}
17 box constant x
x 1+! x @ .
\end{verbatim}
列印「{\tt 18 ok}」。如果經常需要已初始化的變數，甚至可以定義特殊的定義詞彙：
\begin{verbatim}
{ box constant } : init-variable
17 init-variable x
"test" init-variable y
x 1+! x @ . y @ type
\end{verbatim}
列印「{\tt 18 test ok}」。

到目前為止，變數與常數相比只有一個缺點：必須透過輔助詞彙 {\tt @} 存取它們的當前值。當然，可以透過為變數定義「getter」和「setter」詞彙來緩解這一點，並使用這些詞彙編寫更好看的程式碼：
\begin{verbatim}
variable x-box
{ x-box @ } : x
{ x-box ! } : x!
{ x x * 5 x * + 6 + } : f(x)
{ ."( " x . .", " f(x) . .") " } : .xy
3 x! .xy  5 x! .xy
\end{verbatim}
列印「{\tt ( 3 , 30 ) ( 5 , 56 ) ok}」，這是 $f(x)=x^2+5x+6$ 圖形上的點 $(x,f(x))$，其中 $x=3$ 和 $x=5$。

同樣，如果我們想為所有變數定義「getter」，可以首先定義一個定義詞彙，如~\ptref{p:custom.defw} 中所述，並使用此詞彙同時定義 getter 和 setter：
\begin{verbatim}
{ hole dup 1 ' @ does create 1 ' ! does create } : variable-set
variable-set x x!
variable-set y y!
{ ."x=" x . ."y=" y . ."x*y=" x y * . cr } : show
{ y 1+ y! } : up
{ x 1+ x! } : right
{ x y x! y! } : reflect
2 x! 5 y! show up show right show up show reflect show
\end{verbatim}
產生
\begin{verbatim}
x=2 y=5 x*y=10
x=2 y=6 x*y=12
x=3 y=6 x*y=18
x=3 y=7 x*y=21
x=7 y=3 x*y=21
\end{verbatim}

\mysubsection{元組和陣列}\label{p:tuples}
Fift 也支援{\em Tuple}，即堆疊值型別的任意值的不可變有序集合（參見~\ptref{p:stack.types}）。當 {\em Tuple}~$t$ 由值 $x_1$、\dots、$x_n$（按此順序）組成時，我們寫作 $t=(x_1,\ldots,x_n)$。數字~$n$ 稱為 {\em Tuple}~$t$ 的{\em 長度}；它也用~$|t|$ 表示。長度為二的元組也稱為{\em 對}，長度為三的元組稱為{\em 三元組}。
\begin{itemize}
\item {\tt tuple}（$x_1$ \dots $x_n$ $n$ -- $t$），從 $n\geq0$ 個最頂層堆疊值建立新的 {\em Tuple} $t:=(x_1,\ldots,x_n)$。
\item {\tt pair}（$x$ $y$ -- $t$），建立新的對 $t=(x,y)$。等同於 {\tt 2 tuple}。
\item {\tt triple}（$x$ $y$ $z$ -- $t$），建立新的三元組 $t=(x,y,z)$。等同於 {\tt 3 tuple}。
\item {\tt |}（ -- $t$），建立空的 {\em Tuple} $t=()$。等同於 {\tt 0 tuple}。
\item {\tt ,}（$t$ $x$ -- $t'$），將 $x$ 附加到 {\em Tuple}~$t$ 的末尾，並返回結果 {\em Tuple}~$t'$。
\item {\tt .dump}（$x$ -- ），以與 {\tt .s} 傾印所有堆疊元素相同的方式傾印最頂層的堆疊條目。
\end{itemize}
例如，
\begin{verbatim}
| 2 , 3 , 9 , .dump
\end{verbatim}
和
\begin{verbatim}
2 3 9 triple .dump
\end{verbatim}
都建構並列印三元組 $(2,3,9)$：
\begin{verbatim}
[ 2 3 9 ] ok
\end{verbatim}
請注意，{\em Tuple} 的組成部分不一定是同一型別，並且 {\em Tuple} 的組成部分也可以是 {\em Tuple}：
\begin{verbatim}
1 2 3 triple 4 5 6 triple 7 8 9 triple triple constant Matrix
Matrix .dump cr
| 1 "one" pair , 2 "two" pair , 3 "three" pair , .dump
\end{verbatim}
產生
\begin{verbatim}
[ [ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ] ]
[ [ 1 "one" ] [ 2 "two" ] [ 3 "three" ] ]  ok
\end{verbatim}

一旦建構了 {\em Tuple}，我們可以提取其任何組成部分，或將 {\em Tuple} 完全解包到堆疊中：
\begin{itemize}
\item {\tt untuple}（$t$ $n$ -- $x_1$ \dots $x_n$），返回 {\em Tuple}~$t=(x_1,\ldots,x_n)$ 的所有組成部分，但僅當其長度等於~$n$ 時。否則拋出異常。
\item {\tt unpair}（$t$ -- $x$ $y$），解包對 $t=(x,y)$。等同於 {\tt 2 untuple}。
\item {\tt untriple}（$t$ -- $x$ $y$ $z$），解包三元組 $t=(x,y,z)$。等同於 {\tt 3 untuple}。
\item {\tt explode}（$t$ -- $x_1$ \dots $x_n$ $n$），解包未知長度~$n$ 的 {\em Tuple}~$t=(x_1,\ldots,x_n)$，並返回該長度。
\item {\tt count}（$t$ -- $n$），返回 {\em Tuple}~$t$ 的長度 $n=|t|$。
\item {\tt tuple?}（$t$ -- $?$），檢查 $t$ 是否為 {\em Tuple}，並相應地返回 $-1$ 或 $0$。
\item {\tt []}（$t$ $i$ -- $x$），返回 {\em Tuple}~$t$ 的第 $(i+1)$ 個組成部分 $t_{i+1}$，其中 $0\leq i<|t|$。
\item {\tt first}（$t$ -- $x$），返回 {\em Tuple} 的第一個組成部分。等同於 {\tt 0 []}。
\item {\tt second}（$t$ -- $x$），返回 {\em Tuple} 的第二個組成部分。等同於 {\tt 1 []}。
\item {\tt third}（$t$ -- $x$），返回 {\em Tuple} 的第三個組成部分。等同於 {\tt 2 []}。
\end{itemize}
例如，我們可以存取矩陣的單個元素和行：
\begin{verbatim}
1 2 3 triple 4 5 6 triple 7 8 9 triple triple constant Matrix
Matrix .dump cr
Matrix 1 [] 2 [] . cr
Matrix third .dump cr
\end{verbatim}
產生
\begin{verbatim}
[ [ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ] ]
6
[ 7 8 9 ]
\end{verbatim}

請注意，{\em Tuple} 在某種程度上類似於其他程式語言的陣列，但它是不可變的：我們無法改變 {\em Tuple} 的單個元件。如果我們仍然想建立類似陣列的東西，我們需要一個由 {\em Box} 組成的 {\em Tuple}（參見~\ptref{p:variables}）：
\begin{itemize}
\item {\tt allot}（$n$ -- $t$），建立一個由 $n$ 個新的空 {\em Box} 組成的 {\em Tuple}。等同於 {\tt | \{ hole , \} rot times}。
\end{itemize}
例如，
\begin{verbatim}
10 allot constant A
| 3 box , 1 box , 4 box , 1 box , 5 box , 9 box , constant B
{ over @ over @ swap rot ! swap ! } : swap-values-of
{ B swap [] } : B[]
{ B[] swap B[] swap-values-of } : swap-B
{ B[] @ . } : .B[]
0 1 swap-B  1 3 swap-B  0 2 swap-B
0 .B[] 1 .B[] 2 .B[] 3 .B[]
\end{verbatim}
建立了一個長度為 10 的未初始化陣列 $A$、一個長度為 6 的已初始化陣列 $B$，然後交換 $B$ 的某些元素，並印出結果 $B$ 的前四個元素：
\begin{verbatim}
4 1 1 3  ok
\end{verbatim}

\mysubsection{串列}\label{p:lists}
Fift 也可以表示 Lisp 風格的串列。首先，引入兩個特殊詞彙來操作 {\em Null} 型別的值，用於表示空串列（不要與空 {\em Tuple} 混淆）：
\begin{itemize}
\item {\tt null}（ -- $\bot$），推入 {\em Null} 型別的唯一值 $\bot$，也用於表示空串列。
\item {\tt null?}（$x$ -- $?$），檢查 $x$ 是否為 {\em Null}。也可用於檢查串列是否為空。
\end{itemize}
之後，{\tt cons} 和 {\tt uncons} 被定義為 {\tt pair} 和 {\tt unpair} 的別名：
\begin{itemize}
\item {\tt cons}（$h$ $t$ -- $l$），從其頭部（第一個元素）$h$ 和尾部（由所有剩餘元素組成的串列）$t$ 建構串列。等同於 {\tt pair}。
\item {\tt uncons}（$l$ -- $h$ $t$），將非空串列分解為其頭部和尾部。等同於 {\tt unpair}。
\item {\tt car}（$l$ -- $h$），回傳串列的頭部。等同於 {\tt first}。
\item {\tt cdr}（$l$ -- $t$），回傳串列的尾部。等同於 {\tt second}。
\item {\tt cadr}（$l$ -- $h'$），回傳串列的第二個元素。等同於 {\tt cdr car}。
\item {\tt list}（$x_1$ \dots $x_n$ $n$ -- $l$），建構一個長度為 $n$ 的串列 $l$，元素依序為 $x_1$、\ldots、$x_n$。等同於 {\tt null ' cons rot times}。
\item {\tt .l}（$l$ -- ），印出 Lisp 風格的串列 $l$。
\end{itemize}
例如，
\begin{verbatim}
2 3 9  3 tuple .dump cr
2 3 9  3 list dup .dump space dup .l cr
"test" swap cons .l cr
\end{verbatim}
產生
\begin{verbatim}
[ 2 3 9 ]
[ 2 [ 3 [ 9 (null) ] ] ]  (2 3 9)
("test" 2 3 9)
\end{verbatim}
請注意，三元素串列 $(2\ 3\ 9)$ 不同於三元組 $(2,3,9)$。

\mysubsection{原子}\label{p:atoms}
{\em Atom}（原子）是由其名稱唯一識別的簡單實體。{\em Atom} 可用於表示識別符號、標籤、運算名稱、標籤和堆疊標記。Fift 提供以下詞彙來操作 {\em Atom}：
\begin{itemize}
\item {\tt (atom)}（$S$ $x$ -- $a$ $-1$ 或 $0$），回傳由 {\em String} $S$ 給定名稱的唯一 {\em Atom} $a$。如果尚不存在這樣的 {\em Atom}，則在 {\em Integer} $x$ 非零時建立它，或在 $x$ 為零時回傳單一零以表示失敗。
\item {\tt atom}（$S$ -- $a$），回傳名稱為 $S$ 的唯一 {\em Atom} $a$，必要時建立這樣的原子。等同於 {\tt true (atom) drop}。
\item {\tt `$\langle\textit{word\/}\rangle$}（ -- $a$），引入 {\em Atom} 字面值，等於名稱等於 $\langle\textit{word\/}\rangle$ 的唯一 {\em Atom}。等同於 {\tt "$\langle\textit{word\/}\rangle$" atom}。
\item {\tt anon}（ -- $a$），建立一個新的唯一匿名 {\em Atom}。
\item {\tt atom?}（$u$ -- $?$），檢查 $u$ 是否為 {\em Atom}。
\item {\tt eq?}（$u$ $v$ -- $?$），檢查 $u$ 和 $v$ 是否為相等的 {\em Integer}、{\em Atom} 或 {\em Null}。如果它們不相等，或者它們屬於不同型別，或者不屬於列出的型別之一，則回傳零。
\end{itemize}

例如，
\begin{verbatim}
`+ 2 `* 3 4 3 list 3 list .l
\end{verbatim}
建立並印出串列
\begin{verbatim}
(+ 2 (* 3 4))
\end{verbatim}
這是算術表示式 $2+3\cdot 4$ 的 Lisp 風格表示。這類表示式的解譯器可能使用 {\tt eq?} 來檢查運算符號（參見~\ptref{p:recursion} 關於 Fift 中遞迴函數的說明）：
\begin{verbatim}
variable 'eval
{ 'eval @ execute } : eval
{ dup tuple? {
    uncons uncons uncons
    null? not abort"three-element list expected"
    swap eval swap eval rot
    dup `+ eq? { drop + } {
      dup `- eq? { drop - } {
        `* eq? not abort"unknown operation" *
      } cond
    } cond
  } if
} 'eval !
`+ 2 `* 3 4 3 list 3 list dup .l cr eval . cr
\end{verbatim}
印出
\begin{verbatim}
(+ 2 (* 3 4))
14
\end{verbatim}
如果我們載入 {\tt Lisp.fif} 以啟用 Lisp 風格的串列語法，我們可以輸入
\begin{verbatim}
"Lisp.fif" include
( `+ 2 ( `* 3 4 ) ) dup .l cr eval . cr
\end{verbatim}
得到與之前相同的結果。在 {\tt Lisp.fif} 中定義的詞彙 {\tt (}，使用由 {\tt anon} 建立的匿名 {\em Atom} 來標記當前堆疊位置，然後 {\tt )} 從數個頂層堆疊項目建立串列，掃描堆疊直到找到匿名 {\em Atom} 標記：
\begin{verbatim}
variable ')
{ ") without (" abort } ') !
{ ') @ execute } : )
{ null { -rot 2dup eq? not } { swap rot cons } while 2drop
} : list-until-marker
{ anon dup ') @ 2 { ') ! list-until-marker } does ') ! } : (
\end{verbatim}

\mysubsection{腳本模式中的命令列引數}\label{p:cmdline.ops}
Fift 解譯器可以通過在命令列選項中傳遞 {\tt -s} 來以{\em 腳本模式}呼叫。在此模式下，所有後續的命令列引數都不會被掃描以尋找 Fift 啟動命令列選項。相反，{\tt -s} 之後的下一個引數用作 Fift 來源檔案的檔名，所有後續的命令列引數通過特殊詞彙 {\tt \$$n$} 和 {\tt \$\#} 傳遞給 Fift 程式：
\begin{itemize}
\item {\tt \$\#}（ -- $x$），推入傳遞給 Fift 程式的命令列引數總數。
\item {\tt \$$n$}（ -- $S$），將第 $n$ 個命令列引數作為 {\em String} $S$ 推入。例如，{\tt \$0} 推入正在執行的腳本名稱，{\tt \$1} 推入第一個命令列引數，依此類推。
\item {\tt \$()}（$x$ -- $S$），類似於 {\tt \$$n$} 推入第 $x$ 個命令列引數，但 {\em Integer} $x$ 從堆疊中取得。
\end{itemize}
此外，如果 Fift 來源檔案的第一行以兩個字元「{\tt \#!}」開頭，則此行將被忽略。這樣就可以在 *ix 系統中編寫簡單的 Fift 腳本。例如，如果
\begin{verbatim}
#!/usr/bin/fift -s
{ ."usage: " $0 type ." <num1> <num2>" cr
  ."Computes the product of two integers." cr 1 halt } : usage
{ ' usage if } : ?usage
$# 2 <> ?usage
$1 (number) 1- ?usage
$2 (number) 1- ?usage
* . cr
\end{verbatim}
被儲存到當前目錄中的檔案 {\tt cmdline.fif}，並設定其執行位元（例如，通過 {\tt chmod 755 cmdline.fif}），那麼它可以從 shell 或任何其他程式呼叫，前提是 Fift 解譯器安裝為 {\tt /usr/bin/fift}，其標準函式庫 {\tt Fift.fif} 安裝為 {\tt /usr/lib/fift/Fift.fif}：
\begin{verbatim}
$ ./cmdline.fif 12 -5
\end{verbatim}
印出
\begin{verbatim}
-60
\end{verbatim}
當從 *ix shell（如 Bourne-again shell（Bash））呼叫時。

\mysection{區塊、迴圈和條件式}
與算術運算類似，Fift 中的執行流程由基於堆疊的基本操作控制。這導致了反向波蘭表示法和基於堆疊的算術的典型反轉：首先將表示條件分支或迴圈主體的區塊推入堆疊，然後呼叫條件式或迭代執行基本操作。在這方面，Fift 更類似於 PostScript 而不是 Forth。

\mysubsection{定義和執行區塊}\label{p:blocks}
區塊通常使用特殊詞彙「{\tt \{}」和「{\tt \}}」來定義。粗略地說，在 {\tt \{} 和 {\tt \}} 之間列出的所有詞彙構成新區塊的主體，該區塊作為 {\em WordDef} 型別的值推入堆疊。區塊可以通過定義詞彙「{\tt :}」儲存為新 Fift 詞彙的定義（如~\ptref{p:colon.def} 中所述），或通過詞彙 {\tt execute} 執行：
\begin{verbatim}
17 { 2 * } execute .
\end{verbatim}
印出「{\tt 34 ok}」，本質上等同於「{\tt 17 2 * .}」。一個稍微複雜的例子：
\begin{verbatim}
{ 2 * } 17 over execute swap execute .
\end{verbatim}
將「匿名函數」$x\mapsto 2x$ 兩次應用於 $17$，並印出結果 $2\cdot(2\cdot 17)=68$。這樣，區塊就是執行令牌，可以複製、儲存到常數中、用於定義新詞彙或執行。

詞彙 {\tt '} 恢復詞彙的當前定義。也就是說，構造 {\tt ' $\langle\textit{word-name}\rangle$} 推入等同於詞彙 $\langle\textit{word-name}\rangle$ 當前定義的執行令牌。例如，
\begin{verbatim}
' dup execute
\end{verbatim}
等同於 {\tt dup}，而
\begin{verbatim}
' dup : duplicate
\end{verbatim}
將 {\tt duplicate} 定義為 {\tt dup}（當前定義）的同義詞。

或者，我們可以複製一個區塊來定義兩個具有相同定義的新詞彙：
\begin{verbatim}
{ dup * }
 dup : square : **2
\end{verbatim}
將 {\tt square} 和 {\tt **2} 都定義為等同於 {\tt dup *}。

\mysubsection{區塊的條件式執行}\label{p:cond.ops}
區塊的條件式執行使用詞彙 {\tt if}、{\tt ifnot} 和 {\tt cond} 實現：
\begin{itemize}
\item {\tt if}（$x$ $e$ -- ），執行 $e$（必須是執行令牌，即 {\em WordDef}），\footnote{{\em WordDef} 比 {\em WordList} 更通用。例如，基本運算 {\tt +} 的定義是 {\em WordDef}，但不是 {\em WordList}，因為 {\tt +} 不是用其他 Fift 詞彙定義的。}但僅當 {\em Integer} $x$ 非零時執行。
\item {\tt ifnot}（$x$ $e$ -- ），執行執行令牌 $e$，但僅當 {\em Integer} $x$ 為零時執行。
\item {\tt cond}（$x$ $e$ $e'$ -- ），如果 {\em Integer} $x$ 非零，則執行 $e$，否則執行 $e'$。
\end{itemize}

例如，\ptref{p:int.comp} 中的最後一個例子可以更方便地改寫為
\begin{verbatim}
{ { ."true " } { ."false " } cond } : ?.
2 3 < ?.  2 3 = ?.  2 3 > ?.
\end{verbatim}
仍然產生「{\tt true false false ok}」。

請注意，如前例所示，區塊可以任意巢狀。例如，可以編寫
\begin{verbatim}
{ ?dup
  { 0<
    { ."negative " }
    { ."positive " }
    cond
  }
  { ."zero " }
  cond
} : chksign
-17 chksign
\end{verbatim}
得到「{\tt negative ok}」，因為 $-17$ 是負數。

\mysubsection{簡單迴圈}\label{p:simple.loops}
最簡單的迴圈由 {\tt times} 實現：
\begin{itemize}
\item {\tt times}（$e$ $n$ -- ），如果 $n\geq0$，則恰好執行 $e$ $n$ 次。如果 $n$ 為負數，則拋出例外。
\end{itemize}
例如，
\begin{verbatim}
1 { 10 * } 70 times .
\end{verbatim}
計算並印出 $10^{70}$。

我們可以使用這種迴圈來實現簡單的階乘函數：
\begin{verbatim}
{ 0 1 rot { swap 1+ tuck * } swap times nip } : fact
5 fact .
\end{verbatim}
印出「{\tt 120 ok}」，因為 $5!=1\cdot 2\cdot 3\cdot 4\cdot 5=120$。

這個迴圈可以修改為計算費波那契數：
\begin{verbatim}
{ 0 1 rot { tuck + } swap times nip } : fibo
6 fibo .
\end{verbatim}
計算第六個費波那契數 $F_6=13$。

\mysubsection{具有退出條件的迴圈}\label{p:loops}
可以藉助 {\tt until} 和 {\tt while} 建立更複雜的迴圈：
\begin{itemize}
\item {\tt until}（$e$ -- ），執行 $e$，然後移除堆疊頂端整數並檢查它是否為零。如果是，則通過執行 $e$ 開始迴圈的新迭代。否則退出迴圈。
\item {\tt while}（$e$ $e'$ -- ），執行 $e$，然後移除並檢查堆疊頂端整數。如果為零，則退出迴圈。否則執行 $e'$，然後通過執行 $e$ 並在之後檢查退出條件來開始新的迴圈迭代。
\end{itemize}
例如，我們可以計算大於 1000 的前兩個費波那契數：
\begin{verbatim}
{ 1 0 rot { -rot over + swap rot 2dup >= } until drop
} : fib-gtr
1000 fib-gtr . .
\end{verbatim}
印出「{\tt 1597 2584 ok}」。

我們可以使用這個詞彙來計算黃金比例 $\phi=(1+\sqrt{5})/2\approx 1.61803$ 的前 70 位十進位數字：
\begin{verbatim}
1 { 10 * } 70 times dup fib-gtr */ .
\end{verbatim}
印出「{\tt $161803\ldots2604$ ok}」。

\mysubsection{遞迴}\label{p:recursion}
請注意，每當在 {\tt \{ \dots \}} 區塊內提及詞彙時，當前（編譯時）的定義就會包含在正在建立的 {\em WordList} 中。這樣，我們可以在定義詞彙的新版本時參照其先前的定義：
\begin{verbatim}
{ + . } : print-sum
{ ."number " . } : .
{ 1+ . } : print-next
2 . 3 . 2 3 print-sum 7 print-next
\end{verbatim}
產生「{\tt number 2 number 3 5 number 8 ok}」。請注意，{\tt print-sum} 繼續使用「{\tt .}」的原始定義，但 {\tt print-next} 已經使用了修改後的「{\tt .}」。

這個特性在某些情況下可能很方便，但它阻止我們以最直接的方式引入遞迴定義。例如，階乘的經典遞迴定義
\begin{verbatim}
{ ?dup { dup 1- fact * } { 1 } cond } : fact
\end{verbatim}
將無法編譯，因為在編譯定義時 {\tt fact} 恰好是未定義的詞彙。

繞過這個障礙的一個簡單方法是使用詞彙 {\tt @'}（參見~\ptref{p:dict.lookup}），它在執行時查找下一個詞彙的當前定義，然後執行它，類似於我們在~\ptref{p:constants} 中已經做的：
\begin{verbatim}
{ ?dup { dup 1- @' fact * } { 1 } cond } : fact
5 fact .
\end{verbatim}
如預期產生「{\tt 120 ok}」。

然而，這個解決方案相當低效，因為每次遞迴執行 {\tt fact} 時都會使用字典查找。我們可以通過使用變數（參見~\ptref{p:variables} 和~\ptref{p:constants}）來避免這種字典查找：
\begin{verbatim}
variable 'fact
{ 'fact @ execute } : fact
{ ?dup { dup 1- fact * } { 1 } cond } 'fact !
5 fact .
\end{verbatim}
這個稍長的階乘定義通過引入一個特殊變數 {\tt 'fact} 來保存階乘的最終定義，從而避免了執行時的字典查找。\footnote{保存稍後要 {\tt execute} 的 {\em WordDef} 的變數稱為{\em 向量變數}。將 {\tt fact} 替換為 {\tt 'fact @ execute}（其中 {\tt 'fact} 是向量變數）的過程稱為{\em 向量化}。}然後 {\tt fact} 被定義為執行當前儲存在 {\tt 'fact} 中的任何 {\em WordDef}，一旦構造了階乘遞迴定義的主體，就通過短語 {\tt 'fact !} 將其儲存到此變數中，該短語替換了更常見的短語 {\tt :\ fact}。

我們可以通過為向量變數 {\tt 'fact} 使用特殊的「取值器」和「設定器」詞彙來重寫上述定義，就像我們在~\ptref{p:variables} 中為變數所做的那樣：
\begin{verbatim}
variable 'fact
{ 'fact @ execute } : fact
{ 'fact ! } : :fact
forget 'fact
{ ?dup { dup 1- fact * } { 1 } cond } :fact
5 fact .
\end{verbatim}
如果我們需要引入大量遞迴和相互遞迴的定義，我們可能首先引入一個自訂定義詞彙（參見~\ptref{p:custom.defw}）來同時定義匿名向量變數的「取值器」和「設定器」詞彙，類似於我們在~\ptref{p:variables} 中所做的：
\begin{verbatim}
{ hole dup 1 { @ execute } does create 1 ' ! does create
} : vector-set
vector-set fact :fact
{ ?dup { dup 1- fact * } { 1 } cond } :fact
5 fact .
\end{verbatim}
此片段的前三行定義 {\tt fact} 和 {\tt :fact}，本質上與前一片段的前四行定義它們的方式相同。

如果我們希望使 {\tt fact} 在未來不可改變，我們可以在階乘的定義完成後新增一行 {\tt forget :fact}：
\begin{verbatim}
{ hole dup 1 { @ execute } does create 1 ' ! does create
} : vector-set
vector-set fact :fact
{ ?dup { dup 1- fact * } { 1 } cond } :fact
forget :fact
5 fact .
\end{verbatim}
或者，我們可以修改 {\tt vector-set} 的定義，使 {\tt :fact} 在被呼叫一次後會忘記自己：
\begin{verbatim}
{ hole dup 1 { @ execute } does create
  bl word tuck 2 { (forget) ! } does swap 0 (create)
} : vector-set-once
vector-set-once fact :fact
{ ?dup { dup 1- fact * } { 1 } cond } :fact
5 fact .
\end{verbatim}

然而，某些向量變數必須被修改多次，例如，在合併排序演算法中修改比較詞彙 {\tt less} 的行為：
\begin{verbatim}
{ hole dup 1 { @ execute } does create 1 ' ! does create
} : vector-set
vector-set sort :sort
vector-set merge :merge
vector-set less :less
{ null null rot
  { dup null? not }
  { uncons swap rot cons -rot } while drop
} : split
{ dup null? { drop } {
    over null? { nip } {
      over car over car less ' swap if
      uncons rot merge cons
    } cond
  } cond
} :merge
{ dup null? {
    dup cdr null? {
      split sort swap sort merge
    } ifnot
  } ifnot
} :sort
forget :merge
forget :sort
// set `less` to compare numbers, sort a list of numbers
' < :less
3 1 4 1 5 9 2 6 5  9 list
 dup .l cr sort .l cr
// set `less` to compare strings, sort a list of strings
{ $cmp 0< } :less
"once" "upon" "a" "time" "there" "lived" "a" "kitten"  8 list
dup .l cr sort .l cr
\end{verbatim}
產生以下輸出：
\begin{verbatim}
(3 1 4 1 5 9 2 6 5)
(1 1 2 3 4 5 5 6 9)
("once" "upon" "a" "time" "there" "lived" "a" "kitten")
("a" "a" "kitten" "lived" "once" "there" "time" "upon")
\end{verbatim}

\mysubsection{拋出例外}\label{p:exception.ops}
兩個內建詞彙用於拋出例外：
\begin{itemize}
\item {\tt abort}（$S$ -- ），拋出一個例外，錯誤訊息取自 {\em String} $S$。
\item {\tt abort"$\langle\textit{message}\rangle$"}（$x$ -- ），如果 $x$ 是非零整數，則拋出一個例外，錯誤訊息為 $\langle\textit{message}\rangle$。
\end{itemize}
這些詞彙拋出的例外由 C++ 例外 {\tt fift::IntError} 表示，其值等於指定的字串。它通常在 Fift 解譯器內部處理，通過中止所有執行直到頂層，並印出包含正在解譯的來源檔名稱、行號、當前解譯的詞彙和指定的錯誤訊息的訊息。例如：
\begin{verbatim}
{ dup 0= abort"Division by zero" / } : safe/
5 0 safe/ .
\end{verbatim}
印出「{\tt safe/: Division by zero}」，沒有通常的「{\tt ok}」。在此過程中堆疊被清空。

順便一提，當 Fift 解譯器遇到無法解析為整數字面值的未知詞彙時，會拋出訊息為「{\tt -?}」的例外，效果如上所述，包括堆疊被清空。

\mysection{字典、解譯器和編譯器}\label{s:dict.compiler}
在本章中，我們介紹幾個用於字典操作和編譯器控制的特定 Fift 詞彙。「編譯器」是 Fift 解譯器的一部分，它從詞彙名稱建立詞彙參照串列（由 {\em WordList} 堆疊值表示）；它由用於定義區塊的基本運算「{\tt \{}」啟動，如~\ptref{p:colon.def} 和~\ptref{p:blocks} 中所述。

本章包含的大部分資訊相當複雜，在第一次閱讀時可以跳過。然而，這裡描述的技術被 Fift 組譯器大量使用，用於編譯 TVM 程式碼。因此，如果想要理解 Fift 組譯器的當前實現，本節是不可或缺的。

\mysubsection{Fift 解譯器的狀態}\label{sp:fift.state}
Fift 解譯器的狀態由一個稱為 {\tt state} 的內部整數變數控制，目前無法從 Fift 本身存取。當 {\tt state} 為零時，所有從輸入（即 Fift 來源檔案或互動模式下的標準輸入）解析的詞彙都會在字典中查找，然後立即執行。當 {\tt state} 為正數時，在字典中找到的詞彙不會執行。相反，它們（或更確切地說，對其當前定義的參照）被{\em 編譯}，即新增到正在建構的 {\em WordList} 的末尾。

通常，{\tt state} 等於當前開啟區塊的數量。例如，在解譯「{\tt \{ 0= \{ ."zero"}」之後，{\tt state} 變數將等於二，因為有兩個巢狀區塊。正在建構的 {\em WordList} 保存在堆疊頂部。

基本運算「{\tt \{}」只是將一個新的空 {\em WordList} 推入堆疊，並將 {\tt state} 加一。基本運算「{\tt \}}」在 {\tt state} 已經為零時拋出例外；否則將 {\tt state} 減一，並將結果 {\em WordList} 留在堆疊中，表示剛剛建構的區塊。\footnote{詞彙 {\tt \}} 還將此 {\em WordList} 轉換為 {\em WordDef}，後者具有不同的型別標籤，因此是不同的 Fift 值，即使 C++ 實現使用相同的底層 C++ 物件。}之後，如果 {\tt state} 的結果值非零，則新區塊作為字面值（未命名常數）編譯到外圍區塊中。

\mysubsection{活躍詞彙和普通詞彙}\label{p:active.words}
所有字典詞彙都有一個特殊旗標，指示它們是{\em 活躍}詞彙還是{\em 普通}詞彙。預設情況下，所有詞彙都是普通的。特別是，所有使用「{\tt :}」和 {\tt constant} 定義的詞彙都是普通的。

當 Fift 解譯器在字典中找到詞彙定義時，它會檢查該詞彙是否為普通詞彙。如果是，則當前詞彙定義要麼被執行（如果 {\tt state} 為零），要麼被「編譯」（如果 {\tt state} 大於零），如~\ptref{sp:fift.state} 中所述。

另一方面，如果詞彙是活躍的，則即使 {\tt state} 為正數，它也總是被執行。活躍詞彙預期在堆疊中留下一些值 $x_1$ \dots $x_n$ $n$ $e$，其中 $n\geq 0$ 是整數，$x_1\dots x_n$ 是 $n$ 個任意型別的值，$e$ 是執行令牌（{\em WordDef} 型別的值）。之後，解譯器根據 {\tt state} 執行不同的動作：如果 {\tt state} 為零，則丟棄 $n$ 並執行 $e$，就像找到 {\tt nip execute} 短語一樣。如果 {\tt state} 非零，則此集合被「編譯」到當前 {\em WordList}（位於堆疊中 $x_1$ 的正下方）中，其方式與呼叫 {\tt (compile)} 基本運算相同。此編譯相當於在當前 {\em WordList} 的末尾新增一些程式碼，當呼叫時會將 $x_1$、\dots、$x_n$ 推入堆疊，然後新增對 $e$ 的參照（表示延遲執行 $e$）。如果 $e$ 等於特殊值 {\tt 'nop}（表示執行時不執行任何操作的執行令牌），則省略最後一步。

\mysubsection{編譯字面值}
當 Fift 解譯器遇到字典中不存在的詞彙時，它會呼叫基本運算 {\tt (number)} 嘗試將其解析為整數或分數字面值。如果此嘗試成功，則推入特殊值 {\tt 'nop}，並且解譯以與遇到活躍詞彙相同的方式繼續進行。換句話說，如果 {\tt state} 為零，則字面值只是留在堆疊中；否則，呼叫 {\tt (compile)} 來修改當前 {\em WordList}，使其在執行時推入字面值。

\mysubsection{定義新的活躍詞彙}\label{p:def.active}
新的活躍詞彙的定義與新的普通詞彙類似，但使用「{\tt ::}」而不是「{\tt :}」。例如，
\begin{verbatim}
{ bl word 1 ' type } :: say
\end{verbatim}
定義活躍詞彙 {\tt say}，它掃描其後的下一個以空格分隔的詞彙，並將其作為字面值與當前定義的 {\tt type} 的參照一起編譯到當前 {\em WordList} 中（如果 {\tt state} 非零，即如果 Fift 解譯器正在編譯區塊）。當呼叫時，區塊的此新增部分將把儲存的字串推入堆疊並執行 {\tt type}，從而印出 {\tt say} 之後的下一個詞彙。另一方面，如果 {\tt state} 為零，則這兩個動作由 Fift 解譯器立即執行。這樣，
\begin{verbatim}
1 2 say hello + .
\end{verbatim}
將印出「{\tt hello3 ok}」，而
\begin{verbatim}
{ 2 say hello + . } : test
1 test 4 test
\end{verbatim}
將印出「{\tt hello3 hello6 ok}」。

當然，可以使用區塊來表示所需的動作，而不是 {\tt ' type}。例如，如果我們想要一個在儲存的詞彙後印出空格的 {\tt say} 版本，我們可以寫
\begin{verbatim}
{ bl word 1 { type space } } :: say
{ 2 say hello + . } : test
1 test 4 test
\end{verbatim}
得到「{\tt hello 3 hello 6 ok}」。

順便一提，詞彙 {\tt "}（引入字串字面值）和 {\tt ."}（印出字串字面值）可以定義如下：
\begin{verbatim}
{ char " word 1 'nop } ::_ "
{ char " word 1 ' type } ::_ ."
\end{verbatim}
新的定義詞彙「{\tt ::\_}」定義活躍{\em 前綴}詞彙，即不需要後面有空格的活躍詞彙。

\mysubsection{定義詞彙和字典操作}\label{p:dict.create}
{\em 定義詞彙}是在 Fift 字典中定義新詞彙的詞彙。例如，「{\tt :}」、「{\tt ::\_}」和 {\tt constant} 都是定義詞彙。所有這些定義詞彙都可以使用基本運算 {\tt (create)} 定義；實際上，如果需要，使用者可以引入自訂定義詞彙。讓我們列出一些定義詞彙和字典操作詞彙：
\begin{itemize}
\item {\tt create $\langle\textit{word-name}\rangle$}（$e$ -- ），使用從輸入掃描的下一個詞彙作為名稱，使用 {\em WordDef} $e$ 作為其定義來定義新的普通詞彙。如果該詞彙已存在，則會被默默地重新定義。
\item {\tt (create)}（$e$ $S$ $x$ -- ），建立一個名稱等於 {\em String} $S$ 且定義等於 {\em WordDef} $e$ 的新詞彙，使用在 {\em Integer} $0\leq x\leq 3$ 中傳遞的旗標。如果在 $x$ 中設定了位元 $+1$，則建立活躍詞彙；如果設定了位元 $+2$，則建立前綴詞彙。
\item {\tt : $\langle\textit{word-name}\rangle$}（$e$ -- ），使用 {\em WordDef} $e$ 作為其定義，在字典中定義新的普通詞彙 $\langle\textit{word-name}\rangle$。如果指定的詞彙已存在於字典中，則會被默默地重新定義。
\item {\tt forget $\langle\textit{word-name}\rangle$}（ -- ），忘記（從字典中移除）指定詞彙的定義。
\item {\tt (forget)}（$S$ -- ），忘記名稱在 {\em String} $S$ 中指定的詞彙。如果找不到該詞彙，則拋出例外。
\item {\tt :\_ $\langle\textit{word-name}\rangle$}（$e$ -- ），定義新的普通{\em 前綴}詞彙 $\langle\textit{word-name}\rangle$，這意味著 Fift 輸入解析器在詞彙名稱之後不需要空格或行尾字元。在所有其他方面，它與「{\tt:}」類似。
\item {\tt :: $\langle\textit{word-name}\rangle$}（$e$ -- ），使用 {\em WordDef} $e$ 作為其定義，在字典中定義新的{\em 活躍}詞彙 $\langle\textit{word-name}\rangle$。如果指定的詞彙已存在於字典中，則會被默默地重新定義。
\item {\tt ::\_ $\langle\textit{word-name}\rangle$}（$e$ -- ），定義新的活躍{\em 前綴}詞彙 $\langle\textit{word-name}\rangle$，這意味著 Fift 輸入解析器在詞彙名稱之後不需要空格或行尾字元。在所有其他方面，它與「{\tt::}」類似。
\item {\tt constant $\langle\textit{word-name}\rangle$}（$x$ -- ），定義新的普通詞彙 $\langle\textit{word-name}\rangle$，當呼叫時會推入給定的值 $x$。
\item {\tt 2constant $\langle\textit{word-name}\rangle$}（$x$ $y$ -- ），定義新的普通詞彙 $\langle\textit{word-name}\rangle$，當呼叫時會推入給定的值 $x$ 和 $y$（依此順序）。
\item {\tt =: $\langle\textit{word-name}\rangle$}（$x$ -- ），定義新的普通詞彙 $\langle\textit{word-name}\rangle$，當呼叫時會推入給定的值 $x$，與 {\tt constant} 類似，但在區塊和冒號定義內有效。
\item {\tt 2=: $\langle\textit{word-name}\rangle$}（$x$ $y$ -- ），定義新的普通詞彙 $\langle\textit{word-name}\rangle$，當呼叫時會推入給定的值 $x$ 和 $y$（依此順序），與 {\tt 2constant} 類似，但在區塊和冒號定義內有效。
\end{itemize}
請注意，上述大多數詞彙都可以根據 {\tt (create)} 來定義：
\begin{verbatim}
{ bl word 1 2 ' (create) } "::" 1 (create)
{ bl word 0 2 ' (create) } :: :
{ bl word 2 2 ' (create) } :: :_
{ bl word 3 2 ' (create) } :: ::_
{ bl word 0 (create) } : create
{ bl word (forget) } : forget
\end{verbatim}

\mysubsection{字典查找}\label{p:dict.lookup}
以下詞彙可用於在字典中查找詞彙：
\begin{itemize}
\item {\tt ' $\langle\textit{word-name}\rangle$}（ -- $e$），推入在編譯時恢復的詞彙 $\langle\textit{word-name}\rangle$ 的定義。如果找不到指定的詞彙，則拋出例外。請注意，對於普通詞彙，{\tt ' $\langle\textit{word-name}\rangle$ execute} 總是等同於 {\tt $\langle\textit{word-name}\rangle$}，但對於活躍詞彙則不然。
\item {\tt nop}（ -- ），不執行任何操作。
\item {\tt 'nop}（ -- $e$），推入 {\tt nop} 的預設定義——一個執行時不執行任何操作的執行令牌。
\item {\tt find}（$S$ -- $e$ $-1$ 或 $e$ $1$ 或 $0$），在字典中查找 {\em String} $S$，如果找到，則將其定義作為 {\em WordDef} $e$ 回傳，後跟普通詞彙的 $-1$ 或活躍詞彙的 $1$。否則推入 $0$。
\item {\tt (') $\langle\textit{word-name}\rangle$}（ -- $e$），與 {\tt '} 類似，但在執行時回傳指定詞彙的定義，每次呼叫時執行字典查找。可用於通過使用短語 {\tt (') $\langle\textit{word-name}\rangle$ execute} 來恢復詞彙定義和其他區塊內常數的當前值。
\item {\tt @' $\langle\textit{word-name}\rangle$}（ -- $e$），與 {\tt (')} 類似，但在執行時恢復指定詞彙的定義，每次呼叫時執行字典查找，然後執行此定義。可用於通過使用短語 {\tt @' $\langle\textit{word-name}\rangle$}（等同於 {\tt (') $\langle\textit{word-name}\rangle$ execute}）來恢復詞彙定義和其他區塊內常數的當前值，參見~\ptref{p:constants}。
\item {\tt [compile] $\langle\textit{word-name}\rangle$}（ -- ），編譯 $\langle\textit{word-name}\rangle$，就像它是普通詞彙一樣，即使它是活躍的。本質上等同於 {\tt ' $\langle\textit{word-name}\rangle$ execute}。
\item {\tt words}（ -- ），印出字典中當前定義的所有詞彙的名稱。
\end{itemize}

\mysubsection{建立和操作詞彙串列}\label{p:wordlist.ops}
在 Fift 堆疊中，詞彙定義和字面值的參照串列由 {\em WordList} 型別的值表示，用作區塊或詞彙定義。一些用於操作 {\em WordList} 的詞彙包括：
\begin{itemize}
\item {\tt \{}（ -- $l$），一個活躍詞彙，將內部變數 {\tt state} 加一，並將一個新的空 {\em WordList} 推入堆疊。
\item {\tt \}}（$l$ -- $e$），一個活躍詞彙，將 {\em WordList} $l$ 轉換為 {\em WordDef}（執行令牌）$e$，從而使對 $l$ 的所有進一步修改變得不可能，並將內部變數 {\tt state} 減一，推入整數 $1$，後跟 {\tt 'nop}。其淨效果是將建構的 {\em WordList} 轉換為執行令牌，並將此執行令牌推入堆疊，無論是立即還是在外部區塊的執行期間。
\item {\tt (\{)}（ -- $l$），將一個空 {\em WordList} 推入堆疊。
\item {\tt (\})}（$l$ -- $e$），將 {\em WordList} 轉換為執行令牌，使所有進一步修改變得不可能。
\item {\tt (compile)}（$l$ $x_1$ \dots $x_n$ $n$ $e$ -- $l'$），擴展 {\em WordList} $l$，使其在呼叫時將 $0\leq n\leq 255$ 個值 $x_1$、\ldots、$x_n$ 推入堆疊並執行執行令牌 $e$，其中 $0\leq n\leq 255$ 是 {\em Integer}。如果 $e$ 等於特殊值 {\tt 'nop}，則省略最後一步。
\item {\tt does}（$x_1$ \dots $x_n$ $n$ $e$ -- $e'$），建立一個新的執行令牌 $e'$，它會將 $n$ 個值 $x_1$、\dots、$x_n$ 推入堆疊，然後執行 $e$。它大致等同於 {\tt (\{)}、{\tt (compile)} 和 {\tt (\})} 的組合。
\end{itemize}

\mysubsection{自訂定義詞彙}\label{p:custom.defw}
詞彙 {\tt does} 實際上是根據更簡單的詞彙定義的：
\begin{verbatim}
{ swap ({) over 2+ -roll swap (compile) (}) } : does
\end{verbatim}
它對於定義自訂定義詞彙特別有用。例如，{\tt constant} 和 {\tt 2constant} 可以藉助 {\tt does} 和 {\tt create} 來定義：
\begin{verbatim}
{ 1 'nop does create } : constant
{ 2 'nop does create } : 2constant
\end{verbatim}
當然，通過這種自訂定義詞彙定義的詞彙可以執行非平凡的動作。例如，
\begin{verbatim}
{ 1 { type space } does create } : says
"hello" says hello
"unknown error" says error
{ hello error } : test
test
\end{verbatim}
將印出「{\tt hello unknown error ok}」，因為 {\tt hello} 是通過自訂定義詞彙 {\tt says} 定義的，每當呼叫時會印出「{\tt hello}」，類似地，{\tt error} 在呼叫時印出「{\tt unknown error}」。上述定義本質上等同於
\begin{verbatim}
{ ."hello" } : hello
{ ."unknown error" } : error
\end{verbatim}
然而，自訂定義詞彙在呼叫時可以執行更複雜的動作，並在編譯時預處理其引數。例如，可以以非平凡的方式計算訊息：
\begin{verbatim}
"Hello, " "world!" $+ says hw
\end{verbatim}
定義詞彙 {\tt hw}，當呼叫時印出「Hello, world!」。此訊息的字串在編譯時（當 {\tt says} 被呼叫時）計算一次，而不是在執行時（當 {\tt hw} 被呼叫時）。

\mysection{單元操作}
到目前為止，我們已經討論了與 TVM 或 TON 區塊鏈無關的基本 Fift 基本運算。現在我們將轉向用於操作 {\em Cell} 的 TON 特定詞彙。

\mysubsection{切片字面值}\label{p:slice.lit}
回想一下，（TVM）{\em Cell} 由最多 1023 個資料位元和最多四個對其他 {\em Cell} 的參照組成，{\em Slice} 是 {\em Cell} 一部分的唯讀視圖，{\em Builder} 用於建立新 {\em Cell}。Fift 對定義 {\em Slice} 字面值（即未命名常數）有特殊規定，如果需要，這些字面值也可以轉換為 {\em Cell}。

{\em Slice} 字面值通過活躍前綴詞彙 {\tt x\{} 和 {\tt b\{} 來引入：
\begin{itemize}
\item {\tt b\{$\langle\textit{binary-data}\rangle$\}}（ -- $s$），建立一個 {\em Slice} $s$，它不包含參照，並包含最多 1023 個資料位元，這些位元在 $\langle\textit{binary-data}\rangle$ 中指定，$\langle\textit{binary-data}\rangle$ 必須是僅由字元「{\tt 0}」和「{\tt 1}」組成的字串。
\item {\tt x\{$\langle\textit{hex-data}\rangle$\}}（ -- $s$），建立一個 {\em Slice} $s$，它不包含參照，並包含最多 1023 個資料位元，這些位元在 $\langle\textit{hex-data}\rangle$ 中指定。更確切地說，$\langle\textit{hex-data}\rangle$ 中的每個十六進位數字以通常的方式轉換為四個二進位數字。之後，如果 $\langle\textit{hex-data}\rangle$ 的最後一個字元是底線 {\tt \_}，則從結果二進位字串中移除所有尾隨二進位零和緊接在它們之前的二進位一（有關更多詳細資訊，請參見~\cite[1.0]{TVM}）。
\end{itemize}
這樣，{\tt b\{00011101\}} 和 {\tt x\{1d\}} 都推入由八個資料位元和零個參照組成的相同 {\em Slice}。類似地，{\tt b\{111010\}} 和 {\tt x\{EA\_\}} 推入由六個資料位元組成的相同 {\em Slice}。空 {\em Slice} 可以表示為 {\tt b\{\}} 或 {\tt x\{\}}。

如果想要定義帶有一些 {\em Cell} 參照的常數 {\em Slice}，可以使用以下詞彙：
\begin{itemize}
\item {\tt |\_}（$s$ $s'$ -- $s''$），給定兩個 {\em Slice} $s$ 和 $s'$，建立一個新的 {\em Slice} $s''$，它從 $s$ 獲得，方法是附加一個對包含 $s'$ 的 {\em Cell} 的新參照。
\item {\tt |+}（$s$ $s'$ -- $s''$），連接兩個 {\em Slice} $s$ 和 $s'$。這意味著新 {\em Slice} $s''$ 的資料位元通過連接 $s$ 和 $s'$ 的資料位元獲得，$s''$ 的 {\em Cell} 參照串列類似地通過連接 $s$ 和 $s'$ 的對應串列來建構。
\end{itemize}

\mysubsection{建構器基本運算}\label{p:builder.ops}
以下詞彙可用於操作 {\em Builder}，稍後可用於建構新 {\em Cell}：
\begin{itemize}
\item {\tt <b}（ -- $b$），建立一個新的空 {\em Builder}。
\item {\tt b>}（$b$ -- $c$），將 {\em Builder} $b$ 轉換為包含與 $b$ 相同資料的新 {\em Cell} $c$。
\item {\tt i,}（$b$ $x$ $y$ -- $b'$），將有號 $y$ 位元整數 $x$ 的大端序二進位表示附加到 {\em Builder} $b$，其中 $0\leq y\leq 257$。如果 $b$ 中沒有足夠的空間（即，如果 $b$ 已包含超過 $1023-y$ 個資料位元），或者如果 {\em Integer} $x$ 不適合 $y$ 位元，則拋出例外。
\item {\tt u,}（$b$ $x$ $y$ -- $b'$），將無號 $y$ 位元整數 $x$ 的大端序二進位表示附加到 {\em Builder} $b$，其中 $0\leq y\leq 256$。如果操作不可能，則拋出例外。
\item {\tt ref,}（$b$ $c$ -- $b'$），將對 {\em Cell} $c$ 的參照附加到 {\em Builder} $b$。如果 $b$ 已包含四個參照，則拋出例外。
\item {\tt s,}（$b$ $s$ -- $b'$），將從 {\em Slice} $s$ 取得的資料位元和參照附加到 {\em Builder} $b$。
\item {\tt sr,}（$b$ $s$ -- $b'$），建構一個包含來自 {\em Slice} $s$ 的所有資料和參照的新 {\em Cell}，並將對此單元的參照附加到 {\em Builder} $b$。等同於 {\tt <b swap s, b> ref,}。
\item {\tt \$,}（$b$ $S$ -- $b'$），將 {\em String} $S$ 附加到 {\em Builder} $b$。字串被解釋為長度為 $8n$ 的二進位字串，其中 $n$ 是 $S$ 的 UTF-8 表示中的位元組數。
\item {\tt B,}（$b$ $B$ -- $b'$），將 {\em Bytes} $B$ 附加到 {\em Builder} $b$。
\item {\tt b+}（$b$ $b'$ -- $b''$），連接兩個 {\em Builder} $b$ 和 $b'$。
\item {\tt bbits}（$b$ -- $x$），回傳已儲存在 {\em Builder} $b$ 中的資料位元數。結果 $x$ 是範圍 $0\dots1023$ 中的 {\em Integer}。
\item {\tt brefs}（$b$ -- $x$），回傳已儲存在 {\em Builder} $b$ 中的參照數。結果 $x$ 是範圍 $0\dots4$ 中的 {\em Integer}。
\item {\tt bbitrefs}（$b$ -- $x$ $y$），回傳已儲存在 {\em Builder} $b$ 中的資料位元數 $x$ 和參照數 $y$。
\item {\tt brembits}（$b$ -- $x$），回傳可在 {\em Builder} $b$ 中儲存的額外資料位元的最大數量。等同於 {\tt bbits 1023 swap -}。
\item {\tt bremrefs}（$b$ -- $x$），回傳可在 {\em Builder} $b$ 中儲存的額外單元參照的最大數量。
\item {\tt brembitrefs}（$b$ -- $x$ $y$），回傳可在 {\em Builder} $b$ 中儲存的額外資料位元的最大數量 $0\leq x\leq 1023$ 和額外單元參照的最大數量 $0\leq y\leq 4$。
\end{itemize}

結果 {\em Builder} 可以通過非破壞性堆疊傾印基本運算 {\tt .s} 或短語 {\tt b> <s csr.} 進行檢查。例如：
\begin{verbatim}
{ <b x{4A} s, rot 16 u, swap 32 i, .s b> } : mkTest
17239 -1000000001 mkTest
<s csr.
\end{verbatim}
輸出
\begin{verbatim}
BC{000e4a4357c46535ff}
 ok
x{4A4357C46535FF}
 ok
\end{verbatim}
可以觀察到 {\tt .s} 傾印 {\em Builder} 的內部表示，開頭有兩個標籤位元組（通常等於已儲存在 {\em Builder} 中的單元參照數，以及儲存在 {\em Builder} 中的完整位元組數的兩倍，如果存在不完整位元組則加一）。另一方面，{\tt csr.} 以類似於 {\tt x\{} 定義 {\em Slice} 字面值所使用的形式傾印 {\em Slice}（由 {\tt <s} 從 {\em Cell} 建構，參見~\ptref{p:slice.ops}）（參見~\ptref{p:slice.lit}）。

順便一提，上面顯示的詞彙 {\tt mkTest}（其定義中沒有 {\tt .s}）對應於 TL-B 建構器
\begin{verbatim}
test#4a first:uint16 second:int32 = Test;
\end{verbatim}
並可用於序列化此 TL-B 型別的值。

\mysubsection{切片基本運算}\label{p:slice.ops}
以下詞彙可用於操作 {\em Slice} 型別的值，它表示 {\em Cell} 一部分的唯讀視圖。這樣，先前儲存到 {\em Cell} 中的資料可以被反序列化，方法是首先將 {\em Cell} 轉換為 {\em Slice}，然後從此 {\em Slice} 逐步提取所需的資料。
\begin{itemize}
\item {\tt <s}（$c$ -- $s$），將 {\em Cell} $c$ 轉換為包含相同資料的 {\em Slice} $s$。它通常標記單元反序列化的開始。
\item {\tt s>}（$s$ -- ），如果 {\em Slice} $s$ 非空，則拋出例外。它通常標記單元反序列化的結束，檢查是否還有未處理的資料位元或參照。
\item {\tt i@}（$s$ $x$ -- $y$），從 {\em Slice} $s$ 的前 $x$ 個位元中提取有號大端序 $x$ 位元整數。如果 $s$ 包含少於 $x$ 個資料位元，則拋出例外。
\item {\tt i@+}（$s$ $x$ -- $y$ $s'$），類似於 {\tt i@} 從 {\em Slice} $s$ 的前 $x$ 個位元提取有號大端序 $x$ 位元整數，但也回傳 $s$ 的剩餘部分。
\item {\tt i@?}（$s$ $x$ -- $y$ $-1$ 或 $0$），類似於 {\tt i@} 從 {\em Slice} 提取有號整數，但在成功時之後推入整數 $-1$。如果 $s$ 中剩餘的位元少於 $x$ 個，則推入整數 $0$ 表示失敗。
\item {\tt i@?+}（$s$ $x$ -- $y$ $s'$ $-1$ 或 $s$ $0$），從 {\em Slice} $s$ 提取有號整數並計算此 {\em Slice} 的剩餘部分，類似於 {\tt i@+}，但之後推入 $-1$ 表示成功。失敗時，推入未改變的 {\em Slice} $s$ 和 $0$ 表示失敗。
\item {\tt u@}、{\tt u@+}、{\tt u@?}、{\tt u@?+}，{\tt i@}、{\tt i@+}、{\tt i@?}、{\tt i@?+} 的對應版本，用於反序列化無號整數。
\item {\tt B@}（$s$ $x$ -- $B$），從 {\em Slice} $s$ 提取前 $x$ 個位元組（即 $8x$ 個位元），並將它們作為 {\em Bytes} 值 $B$ 回傳。如果 $s$ 中沒有足夠的資料位元，則拋出例外。
\item {\tt B@+}（$s$ $x$ -- $B$ $s'$），類似於 {\tt B@}，但也回傳 {\em Slice} $s$ 的剩餘部分。
\item {\tt B@?}（$s$ $x$ -- $B$ $-1$ 或 $0$），類似於 {\tt B@}，但使用旗標表示失敗，而不是拋出例外。
\item {\tt B@?+}（$s$ $x$ -- $B$ $s'$ $-1$ 或 $s$ $0$），類似於 {\tt B@+}，但使用旗標表示失敗，而不是拋出例外。
\item {\tt \$@}、{\tt \$@+}、{\tt \$@?}、{\tt \$@?+}，{\tt B@}、{\tt B@+}、{\tt B@?}、{\tt B@?+} 的對應版本，將結果作為（UTF-8）{\em String} 而不是 {\em Bytes} 值回傳。這些基本運算不檢查讀取的位元組序列是否為有效的 UTF-8 字串。
\item {\tt ref@}（$s$ -- $c$），從 {\em Slice} $s$ 提取第一個參照，並回傳所參照的 {\em Cell} $c$。如果沒有剩餘參照，則拋出例外。
\item {\tt ref@+}（$s$ -- $s'$ $c$），類似於 {\tt ref@}，但也回傳 $s$ 的剩餘部分。
\item {\tt ref@?}（$s$ -- $c$ $-1$ 或 $0$），類似於 {\tt ref@}，但使用旗標表示失敗，而不是拋出例外。
\item {\tt ref@?+}（$s$ -- $s'$ $c$ $-1$ 或 $s$ $0$），類似於 {\tt ref@+}，但使用旗標表示失敗，而不是拋出例外。
\item {\tt empty?}（$s$ -- $?$），檢查 {\em Slice} 是否為空（即沒有剩餘資料位元和參照），並相應地回傳 $-1$ 或 $0$。
\item {\tt remaining}（$s$ -- $x$ $y$），回傳 {\em Slice} $s$ 中剩餘的資料位元數 $x$ 和單元參照數 $y$。
\item {\tt sbits}（$s$ -- $x$），回傳 {\em Slice} $s$ 中剩餘的資料位元數 $x$。
\item {\tt srefs}（$s$ -- $x$），回傳 {\em Slice} $s$ 中剩餘的單元參照數 $x$。
\item {\tt sbitrefs}（$s$ -- $x$ $y$），回傳 {\em Slice} $s$ 中剩餘的資料位元數 $x$ 和單元參照數 $y$。等同於 {\tt remaining}。
\item {\tt \$>s}（$S$ -- $s$），將 {\em String} $S$ 轉換為 {\em Slice}。等同於 {\tt <b swap \$, b> <s}。
\item {\tt s>c}（$s$ -- $c$），直接從 {\em Slice} $s$ 建立 {\em Cell} $c$。等同於 {\tt <b swap s, b>}。
\item {\tt csr.}（$s$ -- ），遞迴印出 {\em Slice} $s$。在第一行，$s$ 的資料位元以十六進位形式顯示，嵌入在類似於用於 {\em Slice} 字面值的 {\tt x\{\dots\}} 構造中（參見~\ptref{p:slice.lit}）。在接下來的行中，$s$ 參照的單元以更大的縮排印出。
\end{itemize}
例如，~\ptref{p:builder.ops} 中討論的 TL-B 型別 {\tt Test} 的值
\begin{verbatim}
test#4a first:uint16 second:int32 = Test;
\end{verbatim}
可以如下反序列化：
\begin{verbatim}
{ <s 8 u@+ swap 0x4a <> abort"constructor tag mismatch"
     16 u@+ 32 i@+ s> } : unpackTest
x{4A4357C46535FF} s>c unpackTest swap . .
\end{verbatim}
如預期印出「{\tt 17239 -1000000001 ok}」。

當然，如果經常需要檢查建構器標籤，可以為此目的定義一個輔助詞彙：
\begin{verbatim}
{ dup remaining abort"references in constructor tag"
  tuck u@ -rot u@+ -rot <> abort"constructor tag mismatch"
} : tag?
{ <s x{4a} tag? 16 u@+ 32 i@+ s> } : unpackTest
x{4A4357C46535FF} s>c unpackTest swap . .
\end{verbatim}
藉助活躍前綴詞彙（參見~\ptref{p:active.words} 和~\ptref{p:def.active}），我們可以做得更好：
\begin{verbatim}
{ dup remaining abort"references in constructor tag"
  dup 256 > abort"constructor tag too long"
  tuck u@ 2 { -rot u@+ -rot <> abort"constructor tag mismatch" }
} : (tagchk)
{ [compile] x{ 2drop (tagchk) } ::_ ?x{
{ [compile] b{ 2drop (tagchk) } ::_ ?b{
{ <s ?x{4a} 16 u@+ 32 i@+ s> } : unpackTest
x{4A4357C46535FF} s>c unpackTest swap . .
\end{verbatim}
一個更短但效率較低的解決方案是重用先前定義的 {\tt tag?}：
\begin{verbatim}
{ [compile] x{ drop ' tag? } ::_ ?x{
{ [compile] b{ drop ' tag? } ::_ ?b{
x{11EF55AA} ?x{11E} dup csr.
?b{110} csr.
\end{verbatim}
首先輸出「{\tt x\{F55AA\}}」，然後拋出訊息為「constructor tag mismatch」的例外。

\mysubsection{單元雜湊運算}\label{p:hash.ops}
很少有直接對 {\em Cell} 進行操作的詞彙。其中最重要的計算給定單元的{\em（基於 $\Sha$ 的）表示雜湊值}（參見~\cite[3.1]{TVM}），可以粗略地描述為單元的資料位元與此單元參照的單元的遞迴計算雜湊值連接後的 $\Sha$ 雜湊：
\begin{itemize}
\item {\tt hashB}（$c$ -- $B$），計算 {\em Cell} $c$ 的基於 $\Sha$ 的表示雜湊值（參見~\cite[3.1]{TVM}），它明確定義了 $c$ 及其所有後代（前提是 $\Sha$ 沒有碰撞）。結果作為恰好由 32 個位元組組成的 {\em Bytes} 值回傳。
\item {\tt hashu}（$c$ -- $x$），如上計算 $c$ 的基於 $\Sha$ 的表示雜湊值，但將結果作為大端序無號 256 位元 {\em Integer} 回傳。
\item {\tt shash}（$s$ -- $B$），通過首先將 {\em Slice} 轉換為單元來計算其基於 $\Sha$ 的表示雜湊值。等同於 {\tt s>c hashB}。
\end{itemize}

\mysubsection{單元集合運算}\label{p:boc.ops}
{\em 單元集合}（bag of cells）是一個或多個單元及其所有後代的集合。它通常可以序列化為位元組序列（在 Fift 中由 {\em Bytes} 值表示），然後儲存到檔案或通過網路傳輸。之後，它可以被反序列化以恢復原始單元。TON 區塊鏈系統地根據某個 TL-B 方案將不同的資料結構（包括 TON 區塊鏈區塊）表示為單元樹（參見~\cite{TBC}，其中詳細說明了此方案），然後這些單元樹被例行匯入單元集合並序列化為二進位檔案。

用於操作單元集合的 Fift 詞彙包括：
\begin{itemize}
\item {\tt B>boc}（$B$ -- $c$），反序列化由 {\em Bytes} $B$ 表示的「標準」單元集合（即恰好有一個根單元的單元集合），並回傳根 {\em Cell} $c$。
\item {\tt boc+>B}（$c$ $x$ -- $B$），建立並序列化一個「標準」單元集合，包含一個根 {\em Cell} $c$ 及其所有後代。{\em Integer} 參數 $0\leq x\leq 31$ 用於傳遞指示單元集合序列化額外選項的旗標，各個位元具有以下效果：
  \begin{itemize}
  \item $+1$ 啟用單元集合索引建立（對於大型單元集合的延遲反序列化有用）。
  \item $+2$ 在序列化中包含所有資料的 CRC32-C（對於檢查資料完整性有用）。
  \item $+4$ 將根單元的雜湊值明確儲存到序列化中（以便之後可以快速恢復而無需完整反序列化）。
  \item $+8$ 儲存一些中間（非葉）單元的雜湊值（對於大型單元集合的延遲反序列化有用）。
  \item $+16$ 儲存單元快取位元以控制反序列化單元的快取。
  \end{itemize}
$x$ 的典型值對於非常小的單元集合（例如，TON 區塊鏈外部訊息）是 $x=0$ 或 $x=2$，對於大型單元集合（例如，TON 區塊鏈區塊）是 $x=31$。
\item {\tt boc>B}（$c$ -- $B$），序列化帶有根 {\em Cell} $c$ 及其所有後代的小型「標準」單元集合。等同於 {\tt 0 boc+>B}。
\end{itemize}
例如，在~\ptref{p:builder.ops} 中建立的具有 TL-B {\tt Test} 型別值的單元可以如下序列化：
\begin{verbatim}
{ <b x{4A} s, rot 16 u, swap 32 i, b> } : mkTest
17239 -1000000001 mkTest boc>B Bx.
\end{verbatim}
輸出「{\tt B5EE9C7201040101000000000900000E4A4357C46535FF ok}」。這裡 {\tt Bx.} 是印出 {\em Bytes} 值的十六進位表示的詞彙。

\mysubsection{二進位檔案 I/O 和位元組操作}\label{p:bytes.ops}
以下詞彙可用於操作 {\em Bytes} 型別的值（任意位元組序列），並從二進位檔案讀取它們或將它們寫入二進位檔案：
\begin{itemize}
\item {\tt B\{$\langle{\textit{hex-digits}}\rangle$\}}（ -- $B$），推入包含由偶數個十六進位數字表示的資料的 {\em Bytes} 字面值。
\item {\tt Bx.}（$B$ -- ），印出 {\em Bytes} 值的十六進位表示。每個位元組由恰好兩個大寫十六進位數字表示。
\item {\tt file>B}（$S$ -- $B$），讀取名稱在 {\em String} $S$ 中指定的（二進位）檔案，並將其內容作為 {\em Bytes} 值回傳。如果檔案不存在，則拋出例外。
\item {\tt B>file}（$B$ $S$ -- ），建立一個名稱在 {\em String} $S$ 中指定的新（二進位）檔案，並將來自 {\em Bytes} $B$ 的資料寫入新檔案。如果指定的檔案已存在，則會被覆寫。
\item {\tt file-exists?}（$S$ -- $?$），檢查名稱在 {\em String} $S$ 中指定的檔案是否存在。
\end{itemize}
例如，在~\ptref{p:boc.ops} 的例子中建立的單元集合可以如下儲存到磁碟為 {\tt sample.boc}：
\begin{verbatim}
{ <b x{4A} s, rot 16 u, swap 32 i, b> } : mkTest
17239 -1000000001 mkTest boc>B "sample.boc" B>file
\end{verbatim}
之後可以通過 {\tt file>B} 和 {\tt B>boc} 載入並反序列化（即使在另一個 Fift 會話中）：
\begin{verbatim}
{ <s 8 u@+ swap 0x4a <> abort"constructor tag mismatch"
     16 u@+ 32 i@+ s> } : unpackTest
"sample.boc" file>B B>boc unpackTest swap . .
\end{verbatim}
印出「{\tt 17239 -1000000001 ok}」。

此外，還有幾個詞彙用於直接將資料打包（序列化）到 {\em Bytes} 值中，並在之後解包（反序列化）它們。它們可以與 {\tt B>file} 和 {\tt file>B} 結合使用，直接將資料儲存到二進位檔案中，並在之後載入它們。
\begin{itemize}
\item {\tt Blen}（$B$ -- $x$），回傳 {\em Bytes} 值 $B$ 的長度（以位元組為單位）。
\item {\tt BhashB}（$B$ -- $B'$），計算 {\em Bytes} 值的 $\Sha$ 雜湊。雜湊作為 32 位元組 {\em Bytes} 值回傳。
\item {\tt Bhashu}（$B$ -- $x$），計算 {\em Bytes} 值的 $\Sha$ 雜湊，並將雜湊作為無號 256 位元大端序整數回傳。
\item {\tt B=}（$B$ $B'$ -- $?$），檢查兩個 {\em Bytes} 序列是否相等。
\item {\tt Bcmp}（$B$ $B'$ -- $x$），按字典順序比較兩個 {\em Bytes} 序列，並根據比較結果回傳 $-1$、$0$ 或 $1$。
\item {\tt B>i@}（$B$ $x$ -- $y$），將 {\em Bytes} 值 $B$ 的前 $x/8$ 個位元組反序列化為有號大端序 $x$ 位元 {\em Integer} $y$。
\item {\tt B>i@+}（$B$ $x$ -- $B'$ $y$），類似於 {\tt B>i@} 將 $B$ 的前 $x/8$ 個位元組反序列化為有號大端序 $x$ 位元 {\em Integer} $y$，但也回傳 $B$ 的剩餘位元組。
\item {\tt B>u@}、{\tt B>u@+}，反序列化無號整數的 {\tt B>i@} 和 {\tt B>i@+} 變體。
\item {\tt B>Li@}、{\tt B>Li@+}、{\tt B>Lu@}、{\tt B>Lu@+}，{\tt B>i@}、{\tt B>i@+}、{\tt B>u@}、{\tt B>u@+} 的小端序變體。
\item {\tt B|}（$B$ $x$ -- $B'$ $B''$），從 {\em Bytes} 值 $B$ 中切割前 $x$ 個位元組，並將前 $x$ 個位元組（$B'$）和剩餘部分（$B''$）都作為新的 {\em Bytes} 值回傳。
\item {\tt i>B}（$x$ $y$ -- $B$），將有號大端序 $y$ 位元 {\em Integer} $x$ 儲存到恰好由 $y/8$ 個位元組組成的 {\em Bytes} 值 $B$ 中。整數 $y$ 必須是範圍 $0\ldots256$ 中的八的倍數。
\item {\tt u>B}（$x$ $y$ -- $B$），類似於 {\tt i>B}，將無號大端序 $y$ 位元 {\em Integer} $x$ 儲存到恰好由 $y/8$ 個位元組組成的 {\em Bytes} 值 $B$ 中。
\item {\tt Li>B}、{\tt Lu>B}，{\tt i>B} 和 {\tt u>B} 的小端序變體。
\item {\tt B+}（$B'$ $B''$ -- $B$），連接兩個 {\em Bytes} 序列。
\end{itemize}

\mysection{TON 特定運算}
本章描述 TON 特定的 Fift 詞彙，但不包括前一章已討論的用於 {\em Cell} 操作的詞彙。

\mysubsection{Ed25519 密碼學}\label{p:ed25519.ops}
Fift 提供了與 TVM 使用的相同 Ed25519 橢圓曲線密碼學的介面，在~\cite{TBC} 的附錄 $A$ 中描述：
\begin{itemize}
\item {\tt now}（ -- $x$），將當前 Unixtime 作為 {\em Integer} 回傳。
\item {\tt newkeypair}（ -- $B$ $B'$），生成新的 Ed25519 私鑰/公鑰對，並將私鑰 $B$ 和公鑰 $B'$ 都作為 32 位元組 {\em Bytes} 值回傳。金鑰的品質足以用於測試目的。實際應用程式必須在生成 Ed25519 金鑰對之前向 OpenSSL PRNG 提供足夠的熵。
\item {\tt priv>pub}（$B$ -- $B'$），計算與私有 Ed25519 金鑰對應的公鑰。公鑰 $B'$ 和私鑰 $B$ 都由 32 位元組 {\em Bytes} 值表示。
\item {\tt ed25519\_sign}（$B$ $B'$ -- $B''$），使用 Ed25519 私鑰 $B'$（32 位元組 {\em Bytes} 值）簽署資料 $B$，並將簽章作為 64 位元組 {\em Bytes} 值 $B''$ 回傳。
\item {\tt ed25519\_sign\_uint}（$x$ $B'$ -- $B''$），將大端序無號 256 位元整數 $x$ 轉換為 32 位元組序列，並使用 Ed25519 私鑰 $B'$ 對其進行簽署，類似於 {\tt ed25519\_sign}。等同於 {\tt swap 256 u>B swap ed25519\_sign}。要簽署的整數 $x$ 通常計算為某些資料的雜湊值。
\item {\tt ed25519\_chksign}（$B$ $B'$ $B''$ -- $?$），檢查 $B'$ 是否為使用公鑰 $B''$ 對資料 $B$ 的有效 Ed25519 簽章。
\end{itemize}

\mysubsection{智慧合約地址解析器}\label{p:smc.addr.ops}
兩個特殊詞彙可用於解析人類可讀（base64 或 base64url）形式的 TON 智慧合約地址：
\begin{itemize}
\item {\tt smca>\$}（$x$ $y$ $z$ -- $S$），根據旗標 $z$ 將帶有工作鏈 $x$（有號 32 位元 {\em Integer}）和工作鏈內地址 $y$（無號 256 位元 {\em Integer}）的標準 TON 智慧合約地址打包到 48 字元字串 $S$（地址的人類可讀表示）中。$z$ 中的可能單獨旗標為：$+1$ 表示不可反彈地址，$+2$ 表示僅測試網地址，$+4$ 表示 base64url 輸出而不是 base64。
\item {\tt \$>smca}（$S$ -- $x$ $y$ $z$ $-1$ 或 $0$），從其人類可讀字串表示 $S$ 解包標準 TON 智慧合約地址。成功時，回傳有號 32 位元工作鏈 $x$、無號 256 位元工作鏈內地址 $y$、旗標 $z$（其中 $+1$ 表示地址不可反彈，$+2$ 表示地址僅限測試網）和 $-1$。失敗時，推入 $0$。
\end{itemize}
人類可讀的智慧合約地址範例可以如下反序列化和顯示：
\begin{verbatim}
"Ef9Tj6fMJP-OqhAdhKXxq36DL-HYSzCc3-9O6UNzqsgPfYFX"
$>smca 0= abort"bad address"
rot . swap x. . cr
\end{verbatim}
輸出「{\tt -1 538fa7\dots 0f7d 0}」，意味著指定的地址在工作鏈 $-1$（TON 區塊鏈的主鏈）中，並且工作鏈 $-1$ 內的 256 位元地址是 0x538\dots f7d。

\mysubsection{字典操作}\label{p:hashmap.ops}
Fift 有幾個用於{\em 雜湊映射}或{\em（TVM）字典}操作的詞彙，對應於~\cite[3.3]{TVM} 中描述的 TL-B 型別 {\tt HashmapE $n$ $X$} 的值。這些（TVM）字典不要與 Fift 字典混淆，後者是完全不同的東西。TL-B 型別 {\tt HashmapE $n$ $X$} 的字典本質上是一個鍵值集合，具有不同的 $n$ 位元金鑰（其中 $0\leq n\leq 1023$）和任意 TL-B 型別 $X$ 的值。字典由單元樹表示（完整佈局可在~\cite[3.3]{TVM} 中找到），並作為 {\em Cell} 或 {\em Slice} 型別的值儲存在 Fift 堆疊中。有時空字典由 {\em Null} 值表示。
\begin{itemize}
\item {\tt dictnew}（ -- $D$），推入表示新空字典的 {\em Null} 值。
\item {\tt idict!}（$v$ $x$ $D$ $n$ -- $D'$ $-1$ 或 $D$ $0$），將由有號大端序 $n$ 位元整數 $x$ 給定金鑰的新值 $v$（由 {\em Slice} 表示）新增到具有 $n$ 位元金鑰的字典 $D$（由 {\em Cell} 或 {\em Null} 表示）中，成功時回傳新字典 $D'$ 和 $-1$。否則回傳未改變的字典 $D$ 和 $0$。
\item {\tt idict!+}（$v$ $x$ $D$ $n$ -- $D'$ $-1$ 或 $D$ $0$），類似於 {\tt idict!} 將新鍵值對 $(x,v)$ 新增到字典 $D$ 中，但如果金鑰已存在則失敗，回傳未改變的字典 $D$ 和 $0$。
\item {\tt b>idict!}、{\tt b>idict!+}，{\tt idict!} 和 {\tt idict!+} 的變體，接受 {\em Builder} 而不是 {\em Slice} 中的新值 $v$。
\item {\tt udict!}、{\tt udict!+}、{\tt b>udict!}、{\tt b>udict!+}，{\tt idict!}、{\tt idict!+}、{\tt b>idict!}、{\tt b>idict!+} 的變體，但使用無號 $n$ 位元整數 $x$ 作為金鑰。
\item {\tt sdict!}、{\tt sdict!+}、{\tt b>sdict!}、{\tt b>sdict!+}，{\tt idict!}、{\tt idict!+}、{\tt b>idict!}、{\tt b>idict!+} 的變體，但使用 {\em Slice} $x$ 的前 $n$ 個資料位元作為金鑰。
\item {\tt idict@}（$x$ $D$ $n$ -- $v$ $-1$ 或 $0$），在由 {\em Cell} $D$ 表示的字典中查找由有號大端序 $n$ 位元 {\em Integer} $x$ 表示的金鑰。如果找到金鑰，則將對應值作為 {\em Slice} $v$ 和 $-1$ 回傳。否則回傳 $0$。
\item {\tt idict@-}（$x$ $D$ $n$ -- $D'$ $v$ $-1$ 或 $D$ $0$），在由 {\em Cell} $D$ 表示的字典中查找由有號大端序 $n$ 位元 {\em Integer} $x$ 表示的金鑰。如果找到金鑰，則從字典中刪除它，並回傳修改後的字典 $D'$、對應值作為 {\em Slice} $v$ 和 $-1$。否則回傳未修改的字典 $D$ 和 $0$。
\item {\tt idict-}（$x$ $D$ $n$ -- $D'$ $-1$ 或 $D$ $0$），類似於 {\tt idict@-} 從字典 $D$ 中刪除整數金鑰 $x$，但不回傳舊字典 $D$ 中與 $x$ 對應的值。
\item {\tt udict@}、{\tt udict@-}、{\tt udict-}，{\tt idict@}、{\tt idict@-}、{\tt idict-} 的變體，但使用{\em 無}號大端序 $n$ 位元 {\em Integer} $x$ 作為金鑰。
\item {\tt sdict@}、{\tt sdict@-}、{\tt sdict-}，{\tt idict@}、{\tt idict@-}、{\tt idict-} 的變體，但金鑰由 {\em Slice} $k$ 的前 $n$ 個位元提供。
\item {\tt dictmap}（$D$ $n$ $e$ -- $s'$），將執行令牌 $e$（即匿名函數）應用於儲存在具有 $n$ 位元金鑰的字典 $D$ 中的每個鍵值對。執行令牌對每個鍵值對執行一次，在執行 $e$ 之前將 {\em Builder} $b$ 和 {\em Slice} $v$（包含值）推入堆疊。執行後 $e$ 必須在堆疊中留下修改後的 {\em Builder} $b'$（包含來自 $b$ 的所有資料以及新值 $v'$）和 $-1$，或 $0$ 表示失敗。在後一種情況下，對應的金鑰從新字典中省略。
\item {\tt dictmerge}（$D$ $D'$ $n$ $e$ -- $D''$），將兩個具有 $n$ 位元金鑰的字典 $D$ 和 $D'$ 組合成一個具有相同金鑰的字典 $D''$。如果金鑰僅存在於字典 $D$ 和 $D'$ 中的一個，則此金鑰和對應值逐字複製到新字典 $D''$。否則，呼叫執行令牌（匿名函數）$e$ 來合併分別對應於 $D$ 和 $D'$ 中相同金鑰 $k$ 的兩個值 $v$ 和 $v'$。在呼叫 $e$ 之前，推入 {\em Builder} $b$ 和兩個表示要合併的兩個值的 {\em Slice} $v$ 和 $v'$。執行後 $e$ 留下修改後的 {\em Builder} $b'$（包含來自 $b$ 的原始資料以及組合值）和 $-1$，或 $0$ 表示失敗。在後一種情況下，對應的金鑰從新字典中省略。
\end{itemize}
Fift 還為前綴字典提供了一些支援：
\begin{itemize}
\item {\tt pfxdict!}（$v$ $k$ $s$ $n$ -- $s'$ $-1$ 或 $s$ $0$），將鍵值對 $(k,v)$（都由 {\em Slice} 表示）新增到金鑰長度最多為 $n$ 的前綴字典 $s$ 中。成功時，回傳修改後的字典 $s'$ 和 $-1$。失敗時，回傳原始字典 $s$ 和 $0$。
\item {\tt pfxdict!+}（$v$ $k$ $s$ $n$ -- $s'$ $-1$ 或 $s$ $0$），類似於 {\tt pfxdict!} 將鍵值對 $(k,v)$ 新增到前綴字典 $s$ 中，但如果金鑰已存在則失敗。
\item {\tt pfxdict@}（$k$ $s$ $n$ -- $v$ $-1$ 或 $0$），在金鑰長度限制為 $n$ 位元的前綴字典 $s$ 中查找金鑰 $k$（由 {\em Slice} 表示）。成功時，回傳找到的值 $v$ 和 $-1$。失敗時，回傳 $0$。
\end{itemize}

\mysubsection{從 Fift 呼叫 TVM}\label{p:tvm.ops}
TVM 可以與 Fift 解譯器連結。在這種情況下，有幾個 Fift 基本運算可用，可用於使用從 Fift 提供的引數呼叫 TVM。引數可以在 Fift 堆疊中準備，該堆疊完整地傳遞給 TVM 的新實例。結果堆疊和退出代碼傳回 Fift，之後可以檢查。
\begin{itemize}
\item {\tt runvmcode}（\dots $s$ -- \dots $x$），使用從 {\em Slice} $s$ 初始化的當前延續 {\tt cc} 呼叫 TVM 的新實例，從而在 TVM 中執行程式碼 $s$。原始 Fift 堆疊（不包含 $s$）完整地作為 TVM 的初始堆疊傳遞。當 TVM 終止時，其結果堆疊用作新的 Fift 堆疊，退出代碼 $x$ 推入其頂部。如果 $x$ 非零，表示 TVM 已被未處理的例外終止，則從頂部開始的下一個堆疊項目包含此例外的參數，$x$ 是例外代碼。在這種情況下，所有其他項目都從堆疊中移除。
\item {\tt runvmdict}（\dots $s$ -- \dots $x$），類似於 {\tt runvmcode} 使用從 {\em Slice} $s$ 初始化的當前延續 {\tt cc} 呼叫 TVM 的新實例，但也使用相同的值初始化特殊暫存器 {\tt c3}，並在 TVM 執行開始之前將零推入初始 TVM 堆疊。在典型應用中，{\em Slice} $s$ 由子例程選擇程式碼組成，該程式碼使用堆疊頂部 {\em Integer} 來選擇要執行的子例程，從而啟用幾個相互遞迴子例程的定義和執行（參見~\cite[4.6]{TVM} 和~\ptref{p:asm.prog}）。等於零的選擇器對應於大型 TVM 程式中的 {\tt main()} 子例程。
\item {\tt runvm}（\dots $s$ $c$ -- \dots $x$ $c'$），類似於 {\tt runvmdict}（不將額外的零推入初始 TVM 堆疊；如有必要，可以在 $s$ 下明確推入），使用從 {\em Slice} $s$ 初始化的當前延續 {\tt cc} 和特殊暫存器 {\tt c3} 呼叫 TVM 的新實例，並且還使用 {\em Cell} $c$ 初始化特殊暫存器 {\tt c4}（「持久性資料的根」，參見~\cite[1.4]{TVM}）。{\tt c4} 的最終值在最終 Fift 堆疊的頂部作為另一個 {\em Cell} $c'$ 回傳。這樣可以模擬檢查或修改其持久性儲存的智慧合約的執行。
\item {\tt runvmctx}（\dots $s$ $c$ $t$ -- \dots $x$ $c'$），{\tt runvm} 的變體，也使用 {\em Tuple} $t$ 初始化 {\tt c7}（「上下文」）。這樣，如果將正確的上下文載入到 {\tt c7} 中，可以完全模擬 TON 區塊鏈內 TVM 智慧合約的執行（參見~\cite[4.4.10]{TBC}）。
\item {\tt gasrunvmcode}（\dots $s$ $z$ -- \dots $x$ $z'$），{\tt runvmcode} 的 gas 感知版本，在堆疊頂部接受額外的 {\em Integer} 引數 $z$（原始 gas 限制），並將此 TVM 執行消耗的 gas 作為新的堆疊頂部 {\em Integer} 值 $z'$ 回傳。
\item {\tt gasrunvmdict}（\dots $s$ $z$ -- \dots $x$ $z'$），{\tt runvmdict} 的 gas 感知版本。
\item {\tt gasrunvm}（\dots $s$ $c$ $z$ -- \dots $x$ $c'$ $z'$），{\tt runvm} 的 gas 感知版本。
\item {\tt gasrunvmctx}（\dots $s$ $c$ $t$ $z$ -- \dots $x$ $c'$ $z'$），{\tt runvmctx} 的 gas 感知版本。
\end{itemize}
例如，可以建立執行一些簡單程式碼的 TVM 實例，如下所示：
\begin{verbatim}
2 3 9 x{1221} runvmcode .s
\end{verbatim}
TVM 堆疊由三個整數 $2$、$3$ 和 $9$（依此順序；$9$ 是最頂端項目）初始化，然後包含 16 個資料位元且無參照的 {\em Slice} {\tt x\{1221\}} 轉換為 TVM 延續並執行。通過查閱~\cite{TVM} 的附錄 A，我們看到 {\tt x\{12\}} 是 TVM 指令 {\tt XCHG s1, s2} 的程式碼，{\tt x\{21\}} 是 TVM 指令 {\tt OVER} 的程式碼（不要與 Fift 基本運算 {\tt over} 混淆，順便說一下，它對堆疊有相同的效果）。上述執行的結果是：
\begin{verbatim}
execute XCHG s1,s2
execute OVER
execute implicit RET
3 2 9 2 0
 ok
\end{verbatim}
這裡 $0$ 是退出代碼（表示 TVM 成功終止），{\tt 3 2 9 2} 是最終 TVM 堆疊狀態。

如果在 TVM 執行期間生成未處理的例外，則此例外的代碼作為退出代碼回傳：
\begin{verbatim}
2 3 9 x{122} runvmcode .s
\end{verbatim}
產生
\begin{verbatim}
execute XCHG s1,s2
handling exception code 6: invalid or too short opcode
default exception handler, terminating vm with exit code 6
0 6
 ok
\end{verbatim}
請注意，TVM 在啟用內部日誌記錄的情況下執行，其日誌顯示在標準輸出中。

簡單的 TVM 程式可以藉助 {\tt x\{\dots\}} 構造用 {\em Slice} 字面值表示，類似於上述範例。更複雜的程式通常藉助下一章說明的 Fift 組譯器建立。

\mysection{使用 Fift 組譯器}
{\em Fift 組譯器}是一個完全用 Fift 編寫的短程式（目前不到 30KiB），它將 TVM 指令的人類可讀助憶符號轉換為其二進位表示。例如，可以在~\ptref{p:tvm.ops} 中討論的範例中寫 {\tt <\{ s1 s2 XCHG OVER \}>s} 而不是 {\tt x\{1221\}}，前提是事先載入了 Fift 組譯器（通常通過短語 {\tt "Asm.fif" include}）。

\mysubsection{載入 Fift 組譯器}\label{p:asm.load}
Fift 組譯器通常位於 Fift 函式庫目錄（通常包含標準 Fift 函式庫檔案，如 {\tt Fift.fif}）中的檔案 {\tt Asm.fif} 中。它通常通過在需要使用 Fift 組譯器的程式的最開始放置短語 {\tt "Asm.fif" include} 來載入：
\begin{itemize}
\item {\tt include}（$S$ -- ），從由 {\em String} $S$ 給定的路徑載入並解譯 Fift 來源檔案。如果檔名 $S$ 不以斜線開頭，則使用 Fift 包含搜尋路徑（通常取自 {\tt FIFTPATH} 環境變數或 Fift 解譯器的 {\tt -I} 命令列引數，如果兩者都不存在則等於 {\tt /usr/lib/fift}）來定位 $S$。
\end{itemize}
Fift 組譯器的當前實現大量使用自訂定義詞彙（參見~\ptref{p:custom.defw}）；它的原始碼可以作為如何使用定義詞彙編寫非常緊湊的 Fift 程式的良好範例（另請參見~\cite{Brodie} 的原始版本，其中討論了一個簡單的 8080 Forth 組譯器）。

將來，Fift 組譯器定義的幾乎所有詞彙都將移到單獨的詞彙表（命名空間）中。目前它們在全域命名空間中定義，因為 Fift 尚不支援命名空間。

\mysubsection{Fift 組譯器基礎}
Fift 組譯器從 Fift 繼承了其後綴運算表示法，即引數或參數寫在相應指令之前。例如，在~\cite{TVM} 中表示為 {\tt XCHG s1,s2} 的 TVM 組譯器指令在 Fift 組譯器中表示為 {\tt s1 s2 XCHG}。

Fift 組譯器程式碼通常由特殊的開啟詞彙（如 {\tt <\{}）開啟，並由關閉詞彙（如 {\tt \}>} 或 {\tt \}>s}）終止。例如，
\begin{verbatim}
"Asm.fif" include
<{ s1 s2 XCHG OVER }>s
csr.
\end{verbatim}
編譯兩個 TVM 指令 {\tt XCHG s1,s2} 和 {\tt OVER}，並將結果作為 {\em Slice} 回傳（因為使用了 {\tt \}>s}）。結果 {\em Slice} 由 {\tt csr.} 顯示，產生
\begin{verbatim}
x{1221}
\end{verbatim}
可以使用~\cite{TVM} 的附錄 A 並驗證 {\tt x\{12\}} 確實是 TVM 指令 {\tt XCHG s1,s2} 的（代碼頁零）程式碼，{\tt x\{21\}} 是 TVM 指令 {\tt OVER} 的程式碼（不要與 Fift 基本運算 {\tt over} 混淆）。

將來，我們將假設 Fift 組譯器已載入，並從範例中省略短語 {\tt "Asm.fif" include}。

Fift 組譯器以直接的方式使用 Fift 堆疊，使用頂部的幾個堆疊項目來保存帶有正在組譯的程式碼的 {\em Builder}，以及 TVM 指令的引數。例如：
\begin{itemize}
\item {\tt <\{}（ -- $b$），通過將空 {\em Builder} 推入 Fift 堆疊（並可能將命名空間切換到包含所有 Fift 組譯器特定詞彙的命名空間）來開始 Fift 組譯器程式碼的一部分。大致等同於 {\tt <b}。
\item {\tt \}>}（$b$ -- $b'$），終止 Fift 組譯器程式碼的一部分，並將組譯部分作為 {\em Builder} 回傳（並可能恢復原始命名空間）。在大多數情況下大致等同於 {\tt nop}。
\item {\tt \}>c}（$b$ -- $c$），終止 Fift 組譯器程式碼的一部分，並將組譯部分作為 {\em Cell} 回傳（並可能恢復原始命名空間）。大致等同於 {\tt b>}。
\item {\tt \}>s}（$b$ -- $s$），類似於 {\tt \}>} 終止 Fift 組譯器程式碼的一部分，但將組譯部分作為 {\em Slice} 回傳。等同於 {\tt \}>c <s}。
\item {\tt OVER}（$b$ -- $b'$），通過將其附加到堆疊頂部的 {\em Builder} 來組譯 TVM 指令 {\tt OVER} 的程式碼。大致等同於 {\tt x\{21\} s,}。
\item {\tt s1}（ -- $s$），推入 Fift 組譯器用來表示 TVM 的「堆疊暫存器」{\tt s1} 的特殊 {\em Slice}。
\item {\tt s0}\dots{\tt s15}（ -- $s$），與 {\tt s1} 類似的詞彙，但推入表示 TVM 其他「堆疊暫存器」的 {\em Slice}。請注意，{\tt s16}\dots{\tt s255} 必須使用詞彙 {\tt s()} 存取。
\item {\tt s()}（$x$ -- $s$），取 {\em Integer} 引數 $0\leq x\leq 255$，並回傳 Fift 組譯器用來表示「堆疊暫存器」${\texttt s}(x)$ 的特殊 {\em Slice}。
\item {\tt XCHG}（$b$ $s$ $s'$ -- $b'$），從堆疊中取兩個表示兩個「堆疊暫存器」${\texttt s}(i)$ 和 ${\texttt s}(j)$ 的特殊 {\em Slice}，並將 TVM 指令 {\tt XCHG s$(i)$,s$(j)$} 的程式碼附加到 {\em Builder} $b$。
\end{itemize}
特別要注意，Fift 組譯器定義的詞彙 {\tt OVER} 與 Fift 基本運算 {\tt over} 的效果完全不同。

{\tt OVER} 和其他 Fift 組譯器詞彙的實際動作比 {\tt x\{21\} s,} 的動作更複雜。如果新指令程式碼不適合 {\em Builder} $b$（即，如果在新增新指令程式碼後 $b$ 將包含超過 1023 個資料位元），則此指令和所有後續指令被組譯到新的 {\em Builder} $\tilde b$ 中，並且一旦 $\tilde b$ 的生成完成，舊 {\em Builder} $b$ 通過對從 $\tilde b$ 獲得的 {\em Cell} 的參照來增強。這樣，長段的 TVM 程式碼被自動分割成有效 {\em Cell} 的鏈，每個最多包含 1023 個位元。因為 TVM 將延續末尾的單獨單元參照解釋為隱式 {\tt JMPREF}，所以將 TVM 程式碼分割成單元對執行幾乎沒有影響。

\mysubsection{推入整數常數}
TVM 指令 {\tt PUSHINT $x$}（呼叫時推入 {\em Integer} 常數 $x$）可以藉助 Fift 組譯器詞彙 {\tt INT} 或 {\tt PUSHINT} 組譯：
\begin{itemize}
\item {\tt PUSHINT}（$b$ $x$ -- $b'$），將 TVM 指令 {\tt PUSHINT $x$} 組譯到 {\em Builder} 中。
\item {\tt INT}（$b$ $x$ -- $b'$），等同於 {\tt PUSHINT}。
\end{itemize}
請注意，{\tt PUSHINT} 的引數是從 Fift 堆疊中取得的 {\em Integer} 值，不一定是字面值。例如，{\tt <\{ 239 17 * INT \}>s} 是組譯 {\tt PUSHINT 4063} 指令的有效方式，因為 $239\cdot17=4063$。請注意，乘法由 Fift 在組譯時執行，而不是在 TVM 執行時執行。後者的計算可以通過 {\tt <\{ 239 INT 17 INT MUL \}>s} 執行：
\begin{verbatim}
<{ 239 17 * INT }>s dup csr. runvmcode .s 2drop
<{ 239 INT 17 INT MUL }>s dup csr. runvmcode .s 2drop
\end{verbatim}
產生
\begin{verbatim}
x{810FDF}
execute PUSHINT 4063
execute implicit RET
4063 0
 ok
x{8100EF8011A8}
execute PUSHINT 239
execute PUSHINT 17
execute MUL
execute implicit RET
4063 0
 ok
\end{verbatim}
請注意，Fift 組譯器根據其引數 $x$ 選擇 {\tt PUSHINT} $x$ 指令的最短編碼。

\mysubsection{立即引數}
某些 TVM 指令（如 {\tt PUSHINT}）接受立即引數。這些引數通常在 Fift 堆疊中傳遞給組譯相應指令的 Fift 詞彙。整數立即引數通常由 {\em Integer} 表示，單元由 {\em Cell} 表示，延續由 {\em Builder} 和 {\em Cell} 表示，單元切片由 {\em Slice} 表示。例如，{\tt 17 ADDCONST} 組譯 TVM 指令 {\tt ADDCONST 17}，{\tt x\{ABCD\_\} PUSHSLICE} 組譯 {\tt PUSHSLICE xABCD\_}：
\begin{verbatim}
239 <{ 17 ADDCONST x{ABCD_} PUSHSLICE }>s dup csr.
runvmcode . swap . csr.
\end{verbatim}
產生
\begin{verbatim}
x{A6118B2ABCD0}
execute ADDINT 17
execute PUSHSLICE xABCD_
execute implicit RET
0 256 x{ABCD_}
\end{verbatim}

在某些情況下，Fift 組譯器假裝能夠接受超出相應 TVM 指令範圍的立即引數。例如，{\tt ADDCONST $x$} 僅為 $-128\leq x<128$ 定義，但 Fift 組譯器接受 {\tt 239 ADDCONST}：
\begin{verbatim}
17 <{ 239 ADDCONST }>s dup csr. runvmcode .s
\end{verbatim}
產生
\begin{verbatim}
x{8100EFA0}
execute PUSHINT 239
execute ADD
execute implicit RET
256 0
\end{verbatim}
我們可以看到「{\tt ADDCONST 239}」已被默默替換為 {\tt PUSHINT 239} 和 {\tt ADD}。當 {\tt ADDCONST} 的立即引數本身是 Fift 計算的結果，並且很難估計它是否總是適合所需範圍時，此功能很方便。

在某些情況下，同一 TVM 指令有幾個版本，一個接受立即引數，另一個沒有任何引數。例如，有 {\tt LSHIFT $n$} 和 {\tt LSHIFT} 指令。在 Fift 組譯器中，這些變體被分配了不同的助憶符號。特別是，{\tt LSHIFT $n$} 由 {\tt $n$ LSHIFT\#} 表示，{\tt LSHIFT} 由其本身表示。

\mysubsection{立即延續}\label{p:imm.cont}
當立即引數是延續時，通過巢狀的 {\tt <\{} \dots {\tt \}>} 構造在 Fift 堆疊中建立相應的 {\em Builder} 很方便。例如，TVM 組譯器指令
\begin{verbatim}
PUSHINT 1
SWAP
PUSHCONT {
    MULCONST 10
}
REPEAT
\end{verbatim}
可以通過以下方式組譯和執行
\begin{verbatim}
7
<{ 1 INT SWAP <{ 10 MULCONST }> PUSHCONT REPEAT }>s dup csr.
runvmcode drop .
\end{verbatim}
產生
\begin{verbatim}
x{710192A70AE4}
execute PUSHINT 1
execute SWAP
execute PUSHCONT xA70A
execute REPEAT
repeat 7 more times
execute MULINT 10
execute implicit RET
repeat 6 more times
...
repeat 1 more times
execute MULINT 10
execute implicit RET
repeat 0 more times
execute implicit RET
10000000
\end{verbatim}

存在更方便的方式來使用通過 Fift 組譯器建立的字面值延續。例如，上述範例也可以通過以下方式組譯
\begin{verbatim}
<{ 1 INT SWAP CONT:<{ 10 MULCONST }> REPEAT }>s csr.
\end{verbatim}
或甚至
\begin{verbatim}
<{ 1 INT SWAP REPEAT:<{ 10 MULCONST }> }>s csr.
\end{verbatim}
兩者都產生「{\tt x\{710192A70AE4\} ok}」。

順便一提，實現上述迴圈的更好方式是使用 {\tt REPEATEND}：
\begin{verbatim}
7 <{ 1 INT SWAP REPEATEND 10 MULCONST }>s dup csr.
runvmcode drop .
\end{verbatim}
或
\begin{verbatim}
7 <{ 1 INT SWAP REPEAT: 10 MULCONST }>s dup csr.
runvmcode drop .
\end{verbatim}
兩者都產生「{\tt x\{7101E7A70A\}}」，並在迴圈的七次迭代後輸出「{\tt 10000000}」。

請注意，幾個將延續儲存在單獨單元參照中的 TVM 指令（如 {\tt JMPREF}）接受 {\em Cell} 而不是 {\em Builder} 中的引數。在這種情況下，可以使用 {\tt <\{ \dots\ \}>c} 構造來產生此立即引數。

\mysubsection{控制流：迴圈和條件式}
幾乎所有 TVM 控制流指令——如 {\tt IF}、{\tt IFNOT}、{\tt IFRET}、{\tt IFNOTRET}、{\tt IFELSE}、{\tt WHILE}、{\tt WHILEEND}、{\tt REPEAT}、{\tt REPEATEND}、{\tt UNTIL} 和 {\tt UNTILEND}——在應用於字面值延續時，可以類似於~\ptref{p:imm.cont} 範例中的 {\tt REPEAT} 和 {\tt REPEATEND} 組譯。例如，TVM 組譯器程式碼
\begin{verbatim}
DUP
PUSHINT 1
AND
PUSHCONT {
    MULCONST 3
    INC
}
PUSHCONT {
    RSHIFT 1
}
IFELSE
\end{verbatim}
根據其引數 $n$ 是奇數還是偶數來計算 $3n+1$ 或 $n/2$，可以組譯並應用於 $n=7$：
\begin{verbatim}
<{ DUP 1 INT AND
   IF:<{ 3 MULCONST INC }>ELSE<{ 1 RSHIFT# }>
}>s dup csr.
7 swap runvmcode drop .
\end{verbatim}
產生
\begin{verbatim}
x{2071B093A703A492AB00E2}
 ok
execute DUP
execute PUSHINT 1
execute AND
execute PUSHCONT xA703A4
execute PUSHCONT xAB00
execute IFELSE
execute MULINT 3
execute INC
execute implicit RET
execute implicit RET
22  ok
\end{verbatim}
當然，實現此條件表示式的更緊湊和高效的方式是
\begin{verbatim}
<{ DUP 1 INT AND
   IF:<{ 3 MULCONST INC }>ELSE: 1 RSHIFT#
}>s dup csr.
\end{verbatim}
或
\begin{verbatim}
<{ DUP 1 INT AND
   CONT:<{ 3 MULCONST INC }> IFJMP
   1 RSHIFT#
}>s dup csr.
\end{verbatim}
兩者都產生相同的程式碼「{\tt x\{2071B093A703A4DCAB00\}}」。

可用於產生這種「高階」條件式和迴圈的 Fift 組譯器詞彙包括 {\tt IF:<\{}、{\tt IFNOT:<\{}、{\tt IFJMP:<\{}、{\tt \}>ELSE<\{}、{\tt \}>ELSE:}、{\tt \}>IF}、{\tt REPEAT:<\{}、{\tt UNTIL:<\{}、{\tt WHILE:<\{}、{\tt \}>DO<\{}、{\tt \}>DO:}、{\tt AGAIN:<\{}、{\tt \}>AGAIN}、{\tt \}>REPEAT} 和 {\tt \}>UNTIL}。它們的完整列表可以在原始檔 {\tt Asm.fif} 中找到。例如，UNTIL 迴圈可以通過 {\tt UNTIL:<\{ \dots\ \}>} 或 {\tt <\{ \dots\ \}>UNTIL} 建立，WHILE 迴圈可以通過 {\tt WHILE:<\{ \dots\ \}>DO<\{ \dots\ \}>} 建立。

如果我們選擇將條件分支保存在單獨的單元中，我們可以使用 {\tt <\{ \dots\ \}>c} 構造以及諸如 {\tt IFJMPREF} 之類的指令：
\begin{verbatim}
<{ DUP 1 INT AND
   <{ 3 MULCONST INC }>c IFJMPREF
   1 RSHIFT#
}>s dup csr.
3 swap runvmcode .s
\end{verbatim}
執行時與前一個範例的程式碼具有相同的效果，但它包含在兩個單獨的單元中：
\begin{verbatim}
x{2071B0E302AB00}
 x{A703A4}
execute DUP
execute PUSHINT 1
execute AND
execute IFJMPREF (2946....A1DD)
execute MULINT 3
execute INC
execute implicit RET
10 0
\end{verbatim}

\mysubsection{巨集定義}
因為 TVM 指令在 Fift 組譯器中使用對 Fift 堆疊具有可預測效果的 Fift 詞彙實現，所以 Fift 組譯器自動成為巨集組譯器，支援巨集定義。例如，假設我們希望定義巨集定義 {\tt RANGE $x$ $y$}，它檢查 TVM 堆疊頂部值是否在整數字面值 $x$ 和 $y$（包含）之間。此巨集定義可以如下實現：
\begin{verbatim}
{ 2dup > ' swap if
  rot DUP rot GEQINT SWAP swap LEQINT AND
} : RANGE
<{ DUP 17 239 RANGE IFNOT: DROP ZERO }>s dup csr.
66 swap runvmcode drop .
\end{verbatim}
這產生
\begin{verbatim}
x{2020C210018100F0B9B0DC3070}
execute DUP
execute DUP
execute GTINT 16
execute SWAP
execute PUSHINT 240
execute LESS
execute AND
execute IFRET
66
\end{verbatim}
注意 {\tt GEQINT} 和 {\tt LEQINT} 本身是在 {\tt Asm.fif} 中定義的巨集定義，因為它們不直接對應於 TVM 指令。例如，{\tt $x$ GEQINT} 對應於 TVM 指令 {\tt GTINT $x-1$}。

順帶一提，上述程式碼可以透過將 {\tt IFNOT: DROP ZERO} 替換為 {\tt AND} 來縮短兩個位元組。

\mysubsection{更大的程式和子例程}\label{p:asm.prog}
更大的 TVM 程式，例如 TON 區塊鏈智慧合約，通常由數個相互遞迴的子例程組成，其中一個或數個被選為頂層子例程（對於智慧合約稱為 {\tt main()} 或 {\tt recv\_internal()}）。執行從其中一個頂層子例程開始，該子例程可自由呼叫任何其他已定義的子例程，而這些子例程又可以呼叫它們需要的任何其他子例程。

此類 TVM 程式是透過選擇器函數實現的，該函數在 TVM 堆疊中接受一個額外的整數引數；這個整數選擇要呼叫的實際子例程（參見\cite[4.6]{TVM}）。在執行之前，此選擇器函數的程式碼被載入到特殊暫存器 {\tt c3} 和目前接續 {\tt cc} 中。主函數的選擇器（通常為零）被推入初始堆疊中，然後啟動 TVM 執行。之後可以透過適當的 TVM 指令呼叫子例程，例如 {\tt CALLDICT $n$}，其中 $n$ 是要呼叫的子例程的（整數）選擇器。

Fift 組譯器提供了數個詞彙來促進此類大型 TVM 程式的實現。特別是，子例程可以分別定義並指派符號名稱（而非數字選擇器），之後可以使用這些名稱來呼叫它們。Fift 組譯器會自動從這些分離的子例程建立選擇器函數，並將其作為頂層組譯結果返回。

以下是一個由數個子例程組成的程式的簡單範例。此程式計算複數 $(5+i)^4\cdot(239-i)$：
\begin{verbatim}
"Asm.fif" include

PROGRAM{

NEWPROC add
NEWPROC sub
NEWPROC mul

sub <{ s3 s3 XCHG2 SUB s2 XCHG0 SUB }>s PROC

// compute (5+i)^4 * (239-i)
main PROC:<{
  5 INT 1 INT  // 5+i
  2DUP
  mul CALL
  2DUP
  mul CALL
  239 INT -1 INT
  mul JMP
}>

add PROC:<{
  s1 s2 XCHG
  ADD -ROT ADD SWAP
}>

// a b c d -- ac-bd ad+bc : complex number multiplication
mul PROC:<{
  s3 s1 PUSH2  // a b c d a c
  MUL          // a b c d ac
  s3 s1 PUSH2  // a b c d ac b d
  MUL          // a b c d ac bd
  SUB          // a b c d ac-bd
  s4 s4 XCHG2  // ac-bd b c a d
  MUL          // ac-bd b c ad
  -ROT MUL ADD
}>

}END>s
 dup csr.
runvmdict .s
\end{verbatim}
此程式產生：
\begin{verbatim}
x{FF00F4A40EF4A0F20B}
 x{D9_}
  x{2_}
   x{1D5C573C00D73C00E0403BDFFC5000E_}
   x{04A81668006_}
  x{2_}
   x{140CE840A86_}
   x{14CC6A14CC6A2854112A166A282_}
implicit PUSH 0 at start
execute SETCP 0
execute DICTPUSHCONST 14 (xC_,1)
execute DICTIGETJMP
execute PUSHINT 5
execute PUSHINT 1
execute 2DUP
execute CALLDICT 3
execute SETCP 0
execute DICTPUSHCONST 14 (xC_,1)
execute DICTIGETJMP
execute PUSH2 s3,s1
execute MUL
...
execute ROTREV
execute MUL
execute ADD
execute implicit RET
114244 114244 0
\end{verbatim}

基於前一個範例的一些觀察和評論如下：
\begin{itemize}
\item TVM 程式由 {\tt PROGRAM\{} 開啟，並由 {\tt \}END>c}（將組譯的程式作為 {\em Cell} 返回）或 {\tt \}END>s}（返回 {\em Slice}）關閉。
\item 新子例程透過片語 {\tt NEWPROC $\langle\textit{name}\rangle$} 宣告。此宣告將下一個正整數指派為新宣告子例程的選擇器，並將此整數儲存到常數 $\langle\textit{name}\rangle$ 中。例如，上述宣告將 {\tt add}、{\tt sub} 和 {\tt mul} 定義為分別等於 1、2 和 3 的整數常數。
\item 某些子例程是預先宣告的，不需要透過 {\tt NEWPROC} 再次宣告。例如，{\tt main} 是綁定到整數常數（選擇器）0 的子例程識別符。
\item 其他預定義的子例程選擇器，例如 {\tt recv\_internal}（等於 $0$）或 {\tt recv\_external}（等於 $-1$），對於實現 TON 區塊鏈智慧合約很有用（參見\cite[4.4]{TBC}），可以透過 {\tt constant} 宣告（例如，{\tt -1 constant recv\_external}）。
\item 子例程可以透過詞彙 {\tt PROC}（接受子例程的整數選擇器和包含此子例程程式碼的 {\em Slice}）定義，或透過結構 {\tt $\langle\textit{selector}\rangle$ PROC:<\{ \dots\ \}>}（方便定義較大的子例程）定義。
\item {\tt CALLDICT} 和 {\tt JMPDICT} 指令可以透過詞彙 {\tt CALL} 和 {\tt JMP} 組譯，這些詞彙接受要呼叫的子例程的整數選擇器作為在 Fift 堆疊中傳遞的立即引數。
\item Fift 組譯器的目前實現將所有子例程收集到具有 14 位元有號整數金鑰的字典中。因此，所有子例程選擇器必須在 $-2^{13}\dots 2^{13}-1$ 範圍內。
\item 如果在執行期間呼叫具有未知選擇器的子例程，則 Fift 組譯器自動插入的程式碼會拋出程式碼為 $11$ 的例外。此程式碼還會透過 {\tt SETCP0} 指令自動為指令編碼選擇第零代碼頁。
\item Fift 組譯器檢查由 {\tt NEWPROC} 宣告的所有子例程在程式結束前是否確實由 {\tt PROC} 或 {\tt PROC:<\{} 定義。它還檢查子例程是否未被重新定義。
\end{itemize}

應該記住，非常簡單的程式（包括最簡單的智慧合約）可以透過消除這種通用子例程選擇機制，改用自訂子例程選擇程式碼並移除未使用的子例程來使其更加緊湊。例如，上述範例可以轉換為
\begin{verbatim}
<{ 11 THROWIF
   CONT:<{ s3 s1 PUSH2 MUL s3 s1 PUSH2 MUL SUB
           s4 s4 XCHG2 MUL -ROT MUL ADD }>
   5 INT 1 INT 2DUP s4 PUSH CALLX
   2DUP s4 PUSH CALLX
   ROT 239 INT -1 INT ROT JMPX
}>s
 dup csr.
runvmdict .s
\end{verbatim}
這產生
\begin{verbatim}
x{F24B9D5331A85331A8A15044A859A8A075715C24D85C24D8588100EF7F58D9}
implicit PUSH 0 at start
execute THROWIF 11
execute PUSHCONT x5331A85331A8A15044A859A8A0
execute PUSHINT 5
execute PUSHINT 1
execute 2DUP
execute PUSH s4
execute EXECUTE
execute PUSH2 s3,s1
execute MUL
...
execute XCHG2 s4,s4
execute MUL
execute ROTREV
execute MUL
execute ADD
execute implicit RET
114244 114244 0
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%                  bibliography
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\markbothsame{\textsc{參考文獻}}

\begin{thebibliography}{2}
\bibitem{Brodie}
  {\sc L.~Brodie}, {\sl Starting Forth: Introduction to the FORTH Language and Operating System for Beginners and Professionals}, 2nd edition, Prentice Hall, 1987. 可於 \url{https://www.forth.com/starting-forth/} 取得。

\bibitem{Brodie2}
  {\sc L.~Brodie}, {\sl Thinking Forth: A language and philosophy for solving problems}, Prentice Hall, 1984. 可於 \url{http://thinking-forth.sourceforge.net/} 取得。

\bibitem{TON}
  {\sc N.~Durov}, {\sl Telegram Open Network}, 2017.

\bibitem{TVM}
  {\sc N.~Durov}, {\sl Telegram Open Network Virtual Machine}, 2018.

\bibitem{TBC}
  {\sc N.~Durov}, {\sl Telegram Open Network Blockchain}, 2018.
\end{thebibliography}

\clearpage
\appendix\myappendix{Fift 詞彙列表}\label{app:words}
本附錄提供幾乎所有 Fift 詞彙的字母順序列表——包括來自標準函式庫 {\tt Fift.fif} 的基本詞彙和定義，但不包括在 {\tt Asm.fif} 中定義的 Fift 組譯器詞彙（因為從 Fift 的角度來看，Fift 組譯器只是一個應用程式）。某些實驗性詞彙已從此列表中省略。在本文撰寫後，可能已向 Fift 新增或移除其他詞彙。您的 Fift 解譯器中可用的所有詞彙列表可以透過執行 {\tt words} 來檢查。

每個詞彙由其名稱描述，後面是括號中的{\em 堆疊記法}，指示在詞彙執行前後 Fift 堆疊頂部附近的數個值；通常假設所有更深層的堆疊項目保持不變。之後，提供詞彙效果的文字說明。如果該詞彙已在本文件的前面章節中討論過，則包含對該章節的參考。

活動詞彙和活動前綴詞彙（在其出現後立即解析輸入串流的一部分）以修改的方式在此列出。首先，這些詞彙與它們解析的輸入部分一起列出；為了強調，每個項目中實際上是 Fift 詞彙的部分會加上底線。其次，它們的堆疊效果通常從使用者的角度描述，並反映在包含區塊和詞彙定義的執行階段期間執行的動作。

例如，用於定義{\em 位元組}字面值的活動前綴詞彙 {\tt B\{}（參見\ptref{p:bytes.ops}）列為 {\tt \underline{B\{}$\langle\textit{hex-digits}\rangle$\}}，其堆疊效果顯示為（-- $B$）而不是（-- $B$ $1$ $e$），儘管在包含區塊或詞彙定義的編譯階段期間執行活動詞彙 {\tt B\{} 的真實效果是後者（參見\ptref{p:active.words}）。

\begin{itemize}
\item {\tt !} ($x$ $p$ -- )，將新值~$x$ 儲存到{\em Box}~$p$ 中，參見\ptref{p:variables}。
\item {\tt\underline{"}$\langle\textit{string}\rangle$"} ( -- $S$)，將{\em String} 字面值推入堆疊，參見\ptref{p:string.lit} 和~\ptref{p:string.ops}。
\item {\tt \#} ($x$ $S$ -- $x'$ $S'$)，執行將{\em Integer}~$x$ 轉換為其十進位表示的一個步驟，方法是向{\em String}~$S$ 附加一個表示 $x\bmod10$ 的十進位數字。商 $x':=\lfloor x/10\rfloor$ 也會返回。
\item {\tt \#>} ($S$ -- $S'$)，透過反轉{\em String~$S$} 來完成使用 {\tt <\#} 開始的將{\em Integer} 轉換為其可讀表示（十進位或其他）的轉換。等同於 {\tt \$reverse}。
\item {\tt \#s} ($x$ $S$ -- $x'$ $S'$)，執行 {\tt \#} 一次或多次，直到商 $x'$ 變為非正數。等同於 {\tt \{ \# over 0<= \} until}。
\item {\tt \$\#} ( -- $x$)，推送傳遞給 Fift 程式的命令列引數總數，參見\ptref{p:cmdline.ops}。僅在 Fift 解譯器以腳本模式呼叫時（使用 {\tt -s} 命令列引數）定義。
\item {\tt\underline{\$(}$\langle\textit{string\/}\rangle$)} ( -- \dots)，在執行期間查詢詞彙 {\tt \$$\langle\textit{string\/}\rangle$} 並執行其目前定義。通常用於存取命令列引數的目前值，例如，{\tt \$(2)} 本質上等同於 {\tt @' \$2}。
\item {\tt \$()} ($x$ -- $S$)，類似於 {\tt \$$n$} 推送第 $x$ 個命令列引數，但{\em Integer}~$x\geq0$ 從堆疊中取得，參見\ptref{p:cmdline.ops}。僅在 Fift 解譯器以腳本模式呼叫時（使用 {\tt -s} 命令列引數）定義。
\item {\tt \$+} ($S$ $S'$ -- $S.S'$)，串接兩個字串，參見\ptref{p:string.ops}。
\item {\tt \$,} ($b$ $S$ -- $b'$)，將{\em String}~$S$ 附加到{\em Builder}~$b$，參見\ptref{p:builder.ops}。該字串被解釋為長度為 $8n$ 的二進位字串，其中 $n$ 是~$S$ 的 UTF-8 表示中的位元組數。
\item {\tt \$$n$} ( -- $S$)，將第 $n$ 個命令列引數作為{\em String}~$S$ 推送，參見\ptref{p:cmdline.ops}。例如，{\tt \$0} 推送正在執行的腳本名稱，{\tt \$1} 推送第一個命令列引數，依此類推。僅在 Fift 解譯器以腳本模式呼叫時（使用 {\tt -s} 命令列引數）定義。
\item {\tt \$=} ($S$ $S'$ -- $?$)，如果字串 $S$ 和 $S'$ 相等則返回 $-1$，否則返回 $0$，參見\ptref{p:string.cmp.ops}。等同於 {\tt \$cmp 0=}。
\item {\tt \$>s} ($S$ -- $s$)，將{\em String}~$S$ 轉換為{\em Slice}，參見\ptref{p:slice.ops}。等同於 {\tt <b swap \$, b> <s}。
\item {\tt \$>smca} ($S$ -- $x$ $y$ $z$ $-1$ or $0$)，從其可讀字串表示~$S$ 解包標準 TON 智慧合約地址，參見\ptref{p:smc.addr.ops}。成功時，返回有號 32 位元工作鏈 $x$、無號 256 位元工作鏈內地址 $y$、旗標 $z$（其中 $+1$ 表示地址不可彈回，$+2$ 表示地址僅限測試網），以及 $-1$。失敗時，推送 $0$。
\item {\tt \$@} ($s$ $x$ -- $S$)，從{\em Slice}~$s$ 提取前 $x$ 個位元組（即 $8x$ 位元），並將它們作為 UTF-8 {\em String}~$S$ 返回，參見\ptref{p:slice.ops}。如果 $s$ 中沒有足夠的資料位元，則拋出例外。
\item {\tt \$@+} ($s$ $x$ -- $S$ $s'$)，類似於 {\tt \$@}，但也返回{\em Slice} $s$ 的剩餘部分，參見\ptref{p:slice.ops}。
\item {\tt \$@?} ($s$ $x$ -- $S$ $-1$ or $0$)，類似於 {\tt \$@}，但使用旗標來指示失敗而不是拋出例外，參見\ptref{p:slice.ops}。
\item {\tt \$@?+} ($s$ $x$ -- $S$ $s'$ $-1$ or $s$ $0$)，類似於 {\tt \$@+}，但使用旗標來指示失敗而不是拋出例外，參見\ptref{p:slice.ops}。
\item {\tt \$cmp} ($S$ $S'$ -- $x$)，如果字串 $S$ 和 $S'$ 相等則返回 $0$，如果 $S$ 在字典序上小於 $S'$ 則返回 $-1$，如果 $S$ 在字典序上大於 $S'$ 則返回 $1$，參見\ptref{p:string.cmp.ops}。
\item {\tt \$len} ($S$ -- $x$)，計算字串的位元組長度（而非 UTF-8 字元長度！），參見\ptref{p:string.ops}。
\item {\tt \$pos} ($S$ $S'$ -- $x$ or $-1$)，返回子字串 $S'$ 在字串~$S$ 中第一次出現的位置（位元組偏移量）~$x$，或 $-1$。
\item {\tt \$reverse} ($S$ -- $S'$)，反轉{\em String}~$S$ 中 UTF-8 字元的順序。如果 $S$ 不是有效的 UTF-8 字串，返回值未定義且也可能無效。
\item {\tt \%1<{<}} ($x$ $y$ -- $z$)，對於兩個{\em Integer}s $x$ 和 $0\leq y\leq 256$，計算 $z:=x\bmod 2^y=x\&(2^y-1)$。
\item {\tt \underline{'} $\langle\textit{word-name}\rangle$} ( -- $e$)，返回等於 $\langle\textit{word-name}\rangle$ 的目前（編譯期）定義的執行權杖，參見\ptref{p:blocks}。如果找不到指定的詞彙，則拋出例外。
\item {\tt 'nop} ( -- $e$)，推送 {\tt nop} 的預設定義——一個在執行時不執行任何操作的執行權杖，參見\ptref{p:dict.lookup}。
\item {\tt \underline{(')} $\langle\textit{word-name}\rangle$} ( -- $e$)，類似於 {\tt '}，但在執行期間返回指定詞彙的定義，每次呼叫時執行字典查詢，參見\ptref{p:dict.lookup}。可用於透過使用片語 {\tt (') $\langle\textit{word-name}\rangle$ execute} 在詞彙定義和其他區塊內復原常數的目前值。
\item {\tt (-trailing)} ($S$ $x$ -- $S'$)，從{\em String}~$S$ 中移除所有具有 UTF-8 程式碼點~$x$ 的尾隨字元。
\item {\tt (.)} ($x$ -- $S$)，返回具有{\em Integer}~$x$ 的十進位表示的{\em String}。等同於 {\tt dup abs <\# \#s rot sign \#> nip}。
\item {\tt (atom)} ($S$ $x$ -- $a$ $-1$ or $0$)，返回名稱由{\em String}~$S$ 給出的唯一{\em Atom} $a$，參見\ptref{p:atoms}。如果尚無此{\em Atom}，則建立它（如果{\em Integer} $x$ 為非零）或返回單個零以指示失敗（如果 $x$ 為零）。
\item {\tt (b.)} ($x$ -- $S$)，返回具有{\em Integer}~$x$ 的二進位表示的{\em String}。
\item {\tt (compile)} ($l$ $x_1$ \dots $x_n$ $n$ $e$ -- $l'$)，擴展{\em WordList}~$l$，使其在呼叫時將 $0\leq n\leq 255$ 個值 $x_1$、\ldots、$x_n$ 推入堆疊並執行執行權杖 $e$，其中 $0\leq n\leq 255$ 是{\em Integer}，參見\ptref{p:wordlist.ops}。如果 $e$ 等於特殊值 {\tt 'nop}，則省略最後一步。
\item {\tt (create)} ($e$ $S$ $x$ -- )，建立一個新詞彙，名稱等於{\em String}~$S$，定義等於{\em WordDef}~$e$，使用在{\em Integer} $0\leq x\leq 3$ 中傳遞的旗標，參見\ptref{p:dict.create}。如果 $x$ 中設定了位元 $+1$，則建立活動詞彙；如果設定了位元 $+2$，則建立前綴詞彙。
\item {\tt (def?)} ($S$ -- $?$)，檢查詞彙 $S$ 是否已定義。
\item {\tt (dump)} ($x$ -- $S$)，返回一個{\em String}，其中包含最頂部堆疊值~$x$ 的傾印，格式與 {\tt .dump} 使用的格式相同。
\item {\tt (execute)} ($x_1$ \dots $x_n$ $n$ $e$ -- \dots)，執行執行權杖 $e$，但首先檢查堆疊中除 $n$ 和 $e$ 本身外是否至少有 $0\leq n\leq 255$ 個值。它是 {\tt (compile)} 的對應詞，可用於在活動詞彙的立即執行後立即「執行」（執行其預期的執行期動作），如\ptref{p:active.words} 中所述。
\item {\tt (forget)} ($S$ -- )，忘記在{\em String}~$S$ 中指定名稱的詞彙，參見\ptref{p:dict.create}。如果找不到詞彙，則拋出例外。
\item {\tt (number)} ($S$ -- $0$ or $x$ $1$ or $x$ $y$ $2$)，嘗試將{\em String} $S$ 解析為整數或分數字面值，參見\ptref{p:string.ops} 和~\ptref{p:int.lit}。失敗時，返回單個 $0$。成功時，如果 $S$ 是值為 $x$ 的有效整數字面值，則返回 $x$ $1$，或者如果 $S$ 是值為 $x/y$ 的有效分數字面值，則返回 $x$ $y$ $2$。
\item {\tt (x.)} ($x$ -- $S$)，返回具有{\em Integer}~$x$ 的十六進位表示的{\em String}。
\item {\tt (\{)} ( -- $l$)，將空的{\em WordList} 推入堆疊，參見\ptref{p:wordlist.ops}
\item {\tt (\})} ($l$ -- $e$)，將{\em WordList} 轉換為執行權杖（{\em WordDef}），使所有進一步的修改不可能，參見\ptref{p:wordlist.ops}。
\item {\tt *} ($x$ $y$ -- $xy$)，計算兩個{\em Integer}s $x$ 和 $y$ 的乘積 $xy$，參見\ptref{p:arith.op}。
\item {\tt */} ($x$ $y$ $z$ -- $\lfloor xy/z\rfloor$)，「先乘後除」：將兩個整數 $x$ 和 $y$ 相乘產生 513 位元中間結果，然後將乘積除以 $z$，參見\ptref{p:arith.op}。
\item {\tt */c} ($x$ $y$ $z$ -- $\lceil xy/z\rceil$)，帶有向上取整的「先乘後除」：將兩個整數 $x$ 和 $y$ 相乘產生 513 位元中間結果，然後將乘積除以 $z$，參見\ptref{p:arith.op}。
\item {\tt */cmod} ($x$ $y$ $z$ -- $q$ $r$)，類似於 {\tt */c}，但同時計算商 $q:=\lceil xy/z\rceil$ 和餘數 $r:=xy-qz$，參見\ptref{p:arith.op}。
\item {\tt */mod} ($x$ $y$ $z$ -- $q$ $r$)，類似於 {\tt */}，但同時計算商 $q:=\lfloor xy/z\rfloor$ 和餘數 $r:=xy-qz$，參見\ptref{p:arith.op}。
\item {\tt */r} ($x$ $y$ $z$ -- $q:=\lfloor xy/z+1/2\rfloor$)，帶有最接近整數取整的「先乘後除」：將兩個整數 $x$ 和 $y$ 相乘產生 513 位元中間結果，然後將乘積除以 $z$，參見\ptref{p:arith.op}。
\item {\tt */rmod} ($x$ $y$ $z$ -- $q$ $r$)，類似於 {\tt */r}，但同時計算商 $q:=\lfloor xy/z+1/2\rfloor$ 和餘數 $r:=xy-qz$，參見\ptref{p:arith.op}。
\item {\tt *>{}>} ($x$ $y$ $z$ -- $q$)，類似於 {\tt */}，但將除法替換為右移，參見\ptref{p:arith.op}。對於 $0\leq z\leq 256$ 計算 $q:=\lfloor xy/2^z\rfloor$。等同於 {\tt 1<{}< */}。
\item {\tt *>{}>c} ($x$ $y$ $z$ -- $q$)，類似於 {\tt */c}，但將除法替換為右移，參見\ptref{p:arith.op}。對於 $0\leq z\leq 256$ 計算 $q:=\lceil xy/2^z\rceil$。等同於 {\tt 1<{}< */c}。
\item {\tt *>{}>r} ($x$ $y$ $z$ -- $q$)，類似於 {\tt */r}，但將除法替換為右移，參見\ptref{p:arith.op}。對於 $0\leq z\leq 256$ 計算 $q:=\lfloor xy/2^z+1/2\rfloor$。等同於 {\tt 1<{}< */r}。
\item {\tt *mod} ($x$ $y$ $z$ -- $r$)，類似於 {\tt */mod}，但僅計算餘數 $r:=xy-qz$，其中 $q:=\lfloor xy/z\rfloor$。等同於 {\tt */mod nip}。
\item {\tt +} ($x$ $y$ -- $x+y$)，計算兩個{\em Integer}s $x$ 和 $y$ 的和 $x+y$，參見\ptref{p:arith.op}。
\item {\tt +!} ($x$ $p$ -- )，將儲存在{\em Box}~$p$ 中的整數值增加{\em Integer}~$x$，參見\ptref{p:variables}。等同於 {\tt tuck @ + swap !}。
\item {\tt\underline{+"}$\langle\textit{string}\rangle$"} ($S$ -- $S'$)，將{\em String}~$S$ 與字串字面值串接，參見\ptref{p:string.ops}。等同於 {\tt "$\langle\textit{string}\rangle$" \$+}。
\item {\tt ,} ($t$ $x$ -- $t'$)，將 $x$ 附加到{\em Tuple}~$t$ 的末尾，並返回結果{\em Tuple}~$t'$，參見\ptref{p:tuples}。
\item {\tt -} ($x$ $y$ -- $x-y$)，計算兩個{\em Integer}s $x$ 和 $y$ 的差 $x-y$，參見\ptref{p:arith.op}。
\item {\tt -!} ($x$ $p$ -- )，將儲存在{\em Box}~$p$ 中的整數值減少{\em Integer}~$x$。等同於 {\tt swap negate swap +!}。
\item {\tt -1} ( -- $-1$)，推送{\em Integer} $-1$。
\item {\tt -1<{}<} ($x$ -- $-2^x$)，對於 $0\leq x\leq 256$ 計算 $-2^x$。大約等同於 {\tt 1<{}< negate} 或 {\tt -1 swap <{}<}，但對於 $x=256$ 也能運作。
\item {\tt -roll} ($x_n$ \dots $x_0$ $n$ -- $x_0$ $x_n$ \dots $x_1$)，將頂部 $n$ 個堆疊項目向相反方向旋轉，其中 $n\geq0$ 也在堆疊中傳遞，參見\ptref{p:stack.ops}。特別是，{\tt 1 -roll} 等同於 {\tt swap}，{\tt 2 -roll} 等同於 {\tt -rot}。
\item {\tt -rot} ($x$ $y$ $z$ -- $z$ $x$ $y$)，將最頂部的三個堆疊項目向相反方向旋轉，參見\ptref{p:stack.ops}。等同於 {\tt rot rot}。
\item {\tt -trailing} ($S$ -- $S'$)，從{\em String}~$S$ 中移除所有尾隨空格。等同於 {\tt bl (-trailing)}。
\item {\tt -trailing0} ($S$ -- $S'$)，從{\em String}~$S$ 中移除所有尾隨 `{\tt 0}' 字元。等同於 {\tt char 0 (-trailing)}。
\item {\tt .} ($x$ -- )，列印{\em Integer}~$x$ 的十進位表示，後面跟著一個空格，參見\ptref{p:arith.op}。等同於 {\tt .\_ space}。
\item {\tt\underline{."}$\langle\textit{string}\rangle$"} ( -- )，將常數字串列印到標準輸出，參見\ptref{p:string.ops}。
\item {\tt .\_} ($x$ -- )，列印{\em Integer}~$x$ 的十進位表示，不包含任何空格。等同於 {\tt (.)~type}。
\item {\tt .dump} ($x$ -- )，以與 {\tt .s} 傾印所有堆疊元素相同的方式傾印最頂部的堆疊項目，參見\ptref{p:tuples}。等同於 {\tt (dump) type space}。
\item {\tt .l} ($l$ -- )，列印 Lisp 風格列表~$l$，參見\ptref{p:lists}。
\item {\tt .s} ( -- )，從最深處開始傾印所有堆疊項目，保持它們不變，參見\ptref{p:stack.ops}。堆疊項目的可讀表示以空格分隔輸出，後面跟著換行字元。
\item {\tt .sl} ( -- )，類似於 {\tt .s} 傾印所有堆疊項目並保持它們不變，但像 {\tt .l} 一樣將每個項目顯示為 List 風格列表~$l$。
\item {\tt .tc} ( -- )，將分配的單元總數輸出到標準錯誤串流。
\item {\tt /} ($x$ $y$ -- $q:=\lfloor x/y\rfloor$)，計算兩個{\em Integer}s 的向下取整商 $\lfloor x/y\rfloor$，參見\ptref{p:arith.op}。
\item {\tt \underline{/*} $\langle\textit{multiline-comment}\rangle$ */} ( -- )，跳過由詞彙「{\tt */}」（後面跟著空白或換行字元）分隔的多行註釋，參見\ptref{p:comments}。
\item {\tt \underline{//} $\langle\textit{comment-to-eol}\rangle$} ( -- )，跳過單行註釋直到當前行結束，參見\ptref{p:comments}。
\item {\tt /c} ($x$ $y$ -- $q:=\lceil x/y\rceil$)，計算兩個{\em Integer}s 的向上取整商 $\lceil x/y\rceil$，參見\ptref{p:arith.op}。
\item {\tt /cmod} ($x$ $y$ -- $q$ $r$)，同時計算向上取整商 $q:=\lceil x/y\rceil$ 和餘數 $r:=x-qy$，參見\ptref{p:arith.op}。
\item {\tt /mod} ($x$ $y$ -- $q$ $r$)，同時計算向下取整商 $q:=\lfloor x/y\rfloor$ 和餘數 $r:=x-qy$，參見\ptref{p:arith.op}。
\item {\tt /r} ($x$ $y$ -- $q$)，計算兩個{\em Integer}s 的最接近整數取整商 $\lfloor x/y+1/2\rfloor$，參見\ptref{p:arith.op}。
\item {\tt /rmod} ($x$ $y$ -- $q$ $r$)，同時計算最接近整數取整商 $q:=\lfloor x/y+1/2\rfloor$ 和餘數 $r:=x-qy$，參見\ptref{p:arith.op}。
\item {\tt 0} ( -- $0$)，推送{\em Integer} $0$。
\item {\tt 0!} ($p$ -- )，將{\em Integer} $0$ 儲存到{\em Box}~$p$ 中，參見\ptref{p:variables}。等同於 {\tt 0 swap !}。
\item {\tt 0<} ($x$ -- $?$)，檢查 $x<0$（即如果 $x$ 為負數則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。等同於 {\tt 0 <}。
\item {\tt 0<=} ($x$ -- $?$)，檢查 $x\leq0$（即如果 $x$ 為非正數則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。等同於 {\tt 0 <=}。
\item {\tt 0<>} ($x$ -- $?$)，檢查 $x\neq0$（即如果 $x$ 為非零則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。等同於 {\tt 0 <>}。
\item {\tt 0=} ($x$ -- $?$)，檢查 $x=0$（即如果 $x$ 為零則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。等同於 {\tt 0 =}。
\item {\tt 0>} ($x$ -- $?$)，檢查 $x>0$（即如果 $x$ 為正數則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。等同於 {\tt 0 >}。
\item {\tt 0>=} ($x$ -- $?$)，檢查 $x\geq0$（即如果 $x$ 為非負數則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。等同於 {\tt 0 >=}。
\item {\tt 1} ( -- $1$)，推送{\em Integer} $1$。
\item {\tt 1+} ($x$ -- $x+1$)，計算 $x+1$。等同於 {\tt 1 +}。
\item {\tt 1+!} ($p$ -- )，將儲存在{\em Box}~$p$ 中的整數值增加一，參見\ptref{p:variables}。等同於 {\tt 1 swap +!}。
\item {\tt 1-} ($x$ -- $x-1$)，計算 $x-1$。等同於 {\tt 1 -}。
\item {\tt 1-!} ($p$ -- )，將儲存在{\em Box}~$p$ 中的整數值減少一。等同於 {\tt -1 swap +!}。
\item {\tt 1<{}<} ($x$ -- $2^x$)，對於 $0\leq x\leq 255$ 計算 $2^x$。等同於 {\tt 1 swap <{}<}。
\item {\tt 1<{}<1-} ($x$ -- $2^x-1$)，對於 $0\leq x\leq 256$ 計算 $2^x-1$。幾乎等同於 {\tt 1<{}< 1-}，但對於 $x=256$ 也能運作。
\item {\tt 2} ( -- $2$)，推送{\em Integer} $2$。
\item {\tt 2*} ($x$ -- $2x$)，計算 $2x$。等同於 {\tt 2 *}。
\item {\tt 2+} ($x$ -- $x+2$)，計算 $x+2$。等同於 {\tt 2 +}。
\item {\tt 2-} ($x$ -- $x-2$)，計算 $x-2$。等同於 {\tt 2 -}。
\item {\tt 2/} ($x$ -- $\lfloor x/2\rfloor$)，計算 $\lfloor x/2\rfloor$。等同於 {\tt 2 /} 或 {\tt 1 >{}>}。
\item {\tt \underline{2=:} $\langle\textit{word-name}\rangle$} ($x$ $y$ -- )，{\tt 2constant} 的活動變體：定義一個新的普通詞彙 $\langle\textit{word-name}\rangle$，當呼叫時將推送給定值 $x$ 和 $y$，參見\ptref{p:constants}。
\item {\tt 2constant} ($x$ $y$ -- )，從輸入的其餘部分掃描一個以空白分隔的詞彙名稱 $S$，並將新的普通詞彙 $S$ 定義為雙常數，當呼叫時將推送給定值 $x$ 和 $y$（任意類型），參見\ptref{p:dict.create}。
\item {\tt 2drop} ($x$ $y$ -- )，移除最頂部的兩個堆疊項目，參見\ptref{p:stack.ops}。等同於 {\tt drop drop}。
\item {\tt 2dup} ($x$ $y$ -- $x$ $y$ $x$ $y$)，複製最頂部的堆疊項目對，參見\ptref{p:stack.ops}。等同於 {\tt over over}。
\item {\tt 2over} ($x$ $y$ $z$ $w$ -- $x$ $y$ $z$ $w$ $x$ $y$)，複製第二頂部的堆疊項目對。
\item {\tt 2swap} ($a$ $b$ $c$ $d$ -- $c$ $d$ $a$ $b$)，交換最頂部的兩對堆疊項目，參見\ptref{p:stack.ops}。
\item {\tt \underline{:} $\langle\textit{word-name}\rangle$} ($e$ -- )，使用{\em WordDef} $e$ 作為其定義在字典中定義新的普通詞彙 $\langle\textit{word-name}\rangle$，參見\ptref{p:dict.create}。如果指定的詞彙已存在於字典中，則會被默認重新定義。
\item {\tt \underline{::} $\langle\textit{word-name}\rangle$} ($e$ -- )，使用{\em WordDef} $e$ 作為其定義在字典中定義新的活動詞彙 $\langle\textit{word-name}\rangle$，參見\ptref{p:dict.create}。如果指定的詞彙已存在於字典中，則會被默認重新定義。
\item {\tt \underline{::\_} $\langle\textit{word-name}\rangle$} ($e$ -- )，使用{\em WordDef} $e$ 作為其定義在字典中定義新的活動前綴詞彙 $\langle\textit{word-name}\rangle$，參見\ptref{p:dict.create}。如果指定的詞彙已存在於字典中，則會被默認重新定義。
\item {\tt \underline{:\_} $\langle\textit{word-name}\rangle$} ($e$ -- )，使用{\em WordDef} $e$ 作為其定義在字典中定義新的普通前綴詞彙 $\langle\textit{word-name}\rangle$，參見\ptref{p:dict.create}。如果指定的詞彙已存在於字典中，則會被默認重新定義。
\item {\tt <} ($x$ $y$ -- $?$)，檢查 $x<y$（即如果{\em Integer}~$x$ 小於{\em Integer}~$y$ 則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。
\item {\tt <\#} ( -- $S$)，推送空的{\em String}。通常用於開始將{\em Integer} 轉換為其可讀表示，十進位或其他基數。等同於 {\tt ""}。
\item {\tt <{}<} ($x$ $y$ -- $x\cdot 2^y$)，計算二進位數字 $x$ 左移 $y\geq0$ 個位置的算術左移，產生 $x\cdot 2^y$，參見\ptref{p:arith.op}。
\item {\tt <{}</} ($x$ $y$ $z$ -- $q$)，對於 $0\leq z\leq 256$ 計算 $q:=\lfloor 2^zx/y\rfloor$，產生 513 位元中間結果，類似於 {\tt */}，參見\ptref{p:arith.op}。等同於 {\tt 1<{}< swap */}。
\item {\tt <{}</c} ($x$ $y$ $z$ -- $q$)，對於 $0\leq z\leq 256$ 計算 $q:=\lceil 2^zx/y\rceil$，產生 513 位元中間結果，類似於 {\tt */c}，參見\ptref{p:arith.op}。等同於 {\tt 1<{}< swap */c}。
\item {\tt <{}</r} ($x$ $y$ $z$ -- $q$)，對於 $0\leq z\leq 256$ 計算 $q:=\lfloor 2^zx/y+1/2\rfloor$，產生 513 位元中間結果，類似於 {\tt */r}，參見\ptref{p:arith.op}。等同於 {\tt 1<{}< swap */r}。
\item {\tt <=} ($x$ $y$ -- $?$)，檢查 $x\leq y$（即如果{\em Integer}~$x$ 小於或等於{\em Integer}~$y$ 則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。
\item {\tt <>} ($x$ $y$ -- $?$)，檢查 $x\neq y$（即如果{\em Integer}s~$x$ 和~$y$ 不相等則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。
\item {\tt <b} ( -- $b$)，建立新的空{\em Builder}，參見\ptref{p:builder.ops}。
\item {\tt <s} ($c$ -- $s$)，將{\em Cell}~$c$ 轉換為包含相同資料的{\em Slice}~$s$，參見\ptref{p:slice.ops}。它通常標記單元反序列化的開始。
\item {\tt =} ($x$ $y$ -- $?$)，檢查 $x=y$（即如果{\em Integer}s~$x$ 和~$y$ 相等則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。
\item {\tt \underline{=:} $\langle\textit{word-name}\rangle$} ($x$ -- )，{\tt constant} 的活動變體：定義一個新的普通詞彙 $\langle\textit{word-name}\rangle$，當呼叫時將推送給定值 $x$，參見\ptref{p:constants}。
\item {\tt >} ($x$ $y$ -- $?$)，檢查 $x>y$（即如果{\em Integer}~$x$ 大於{\em Integer}~$y$ 則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。
\item {\tt >=} ($x$ $y$ -- $?$)，檢查 $x\geq y$（即如果{\em Integer}~$x$ 大於或等於{\em Integer}~$y$ 則推送 $-1$，否則推送 $0$），參見\ptref{p:int.comp}。
\item {\tt >{}>} ($x$ $y$ -- $q:=\lfloor x\cdot 2^{-y}\rfloor$)，計算二進位數字 $x$ 右移 $0\leq y\leq 256$ 個位置的算術右移，參見\ptref{p:arith.op}。等同於 {\tt 1<{}< /}。
\item {\tt >{}>c} ($x$ $y$ -- $q:=\lceil x\cdot 2^{-y}\rceil$)，對於 $0\leq y\leq 256$ 計算 $x$ 除以 $2^y$ 的向上取整商 $q$，參見\ptref{p:arith.op}。等同於 {\tt 1<{}< /c}。
\item {\tt >{}>r} ($x$ $y$ -- $q:=\lfloor x\cdot 2^{-y}+1/2\rfloor$)，對於 $0\leq y\leq 256$ 計算 $x$ 除以 $2^y$ 的最接近整數取整商 $q$，參見\ptref{p:arith.op}。等同於 {\tt 1<{}< /r}。
\item {\tt ?dup} ($x$ -- $x$ $x$ or $0$)，複製{\em Integer} $x$，但僅在其為非零時，參見\ptref{p:stack.ops}。否則保持不變。
\item {\tt @} ($p$ -- $x$)，提取當前儲存在{\em Box}~$p$ 中的值，參見\ptref{p:variables}。
\item {\tt \underline{@'} $\langle\textit{word-name}\rangle$} ( -- $e$)，在執行期間復原指定詞彙的定義，每次呼叫時執行字典查詢，然後執行此定義，參見\ptref{p:constants} 和~\ptref{p:dict.lookup}。可用於透過使用片語 {\tt @' $\langle\textit{word-name}\rangle$} 在詞彙定義和其他區塊內復原常數的目前值，等同於 {\tt (') $\langle\textit{word-name}\rangle$ execute}。
\item {\tt B+} ($B'$ $B''$ -- $B$)，串接兩個{\em Bytes} 值，參見\ptref{p:bytes.ops}。
\item {\tt B,} ($b$ $B$ -- $b'$)，將{\em Bytes}~$B$ 附加到{\em Builder}~$b$，參見\ptref{p:builder.ops}。如果 $b$ 中沒有足夠的空間容納 $B$，則拋出例外。
\item {\tt B=} ($B$ $B'$ -- $?$)，檢查兩個{\em Bytes} 序列是否相等，並根據比較結果返回 $-1$ 或 $0$，參見\ptref{p:bytes.ops}。
\item {\tt B>Li@} ($B$ $x$ -- $y$)，將 {\tt Bytes} 值~$B$ 的前 $x/8$ 個位元組反序列化為有號小端序 $x$ 位元{\em Integer}~$y$，參見\ptref{p:bytes.ops}。
\item {\tt B>Li@+} ($B$ $x$ -- $B'$ $y$)，類似於 {\tt B>Li@} 將 $B$ 的前 $x/8$ 個位元組反序列化為有號小端序 $x$ 位元{\em Integer}~$y$，但也返回~$B$ 的剩餘位元組，參見\ptref{p:bytes.ops}。
\item {\tt B>Lu@} ($B$ $x$ -- $y$)，將 {\tt Bytes} 值~$B$ 的前 $x/8$ 個位元組反序列化為無號小端序 $x$ 位元{\em Integer}~$y$，參見\ptref{p:bytes.ops}。
\item {\tt B>Lu@+} ($B$ $x$ -- $B'$ $y$)，類似於 {\tt B>Lu@} 將 $B$ 的前 $x/8$ 個位元組反序列化為無號小端序 $x$ 位元{\em Integer}~$y$，但也返回~$B$ 的剩餘位元組，參見\ptref{p:bytes.ops}。
\item {\tt B>boc} ($B$ -- $c$)，反序列化由{\em Bytes}~$B$ 表示的「標準」單元集合（即恰好具有一個根單元的單元集合），並返回根{\em Cell}~$c$，參見\ptref{p:boc.ops}。
\item {\tt B>file} ($B$ $S$ -- )，建立一個名稱由{\em String}~$S$ 指定的新（二進位）檔案，並將來自{\em Bytes}~$B$ 的資料寫入新檔案，參見\ptref{p:bytes.ops}。如果指定的檔案已存在，則會被覆寫。
\item {\tt B>i@} ($B$ $x$ -- $y$)，將 {\tt Bytes} 值~$B$ 的前 $x/8$ 個位元組反序列化為有號大端序 $x$ 位元{\em Integer}~$y$，參見\ptref{p:bytes.ops}。
\item {\tt B>i@+} ($B$ $x$ -- $B'$ $y$)，類似於 {\tt B>i@} 將 $B$ 的前 $x/8$ 個位元組反序列化為有號大端序 $x$ 位元{\em Integer}~$y$，但也返回~$B$ 的剩餘位元組，參見\ptref{p:bytes.ops}。
\item {\tt B>u@} ($B$ $x$ -- $y$)，將 {\tt Bytes} 值~$B$ 的前 $x/8$ 個位元組反序列化為無號大端序 $x$ 位元{\em Integer}~$y$，參見\ptref{p:bytes.ops}。
\item {\tt B>u@+} ($B$ $x$ -- $B'$ $y$)，類似於 {\tt B>u@} 將 $B$ 的前 $x/8$ 個位元組反序列化為無號大端序 $x$ 位元{\em Integer}~$y$，但也返回~$B$ 的剩餘位元組，參見\ptref{p:bytes.ops}。
\item {\tt B@} ($s$ $x$ -- $B$)，從{\em Slice}~$s$ 提取前 $x$ 個位元組（即 $8x$ 位元），並將它們作為{\em Bytes} 值~$B$ 返回，參見\ptref{p:slice.ops}。如果 $s$ 中沒有足夠的資料位元，則拋出例外。
\item {\tt B@+} ($s$ $x$ -- $B$ $s'$)，類似於 {\tt B@}，但也返回{\em Slice} $s$ 的剩餘部分，參見\ptref{p:slice.ops}。
\item {\tt B@?} ($s$ $x$ -- $B$ $-1$ or $0$)，類似於 {\tt B@}，但使用旗標來指示失敗而不是拋出例外，參見\ptref{p:slice.ops}。
\item {\tt B@?+} ($s$ $x$ -- $B$ $s'$ $-1$ or $s$ $0$)，類似於 {\tt B@+}，但使用旗標來指示失敗而不是拋出例外，參見\ptref{p:slice.ops}。
\item {\tt Bcmp} ($B$ $B'$ -- $x$)，按字典序比較兩個{\em Bytes} 序列，並根據比較結果返回 $-1$、$0$ 或 $1$，參見\ptref{p:bytes.ops}。
\item {\tt Bhash} ($B$ -- $x$)，{\tt Bhashu} 的已棄用版本。請使用 {\tt Bhashu} 或 {\tt BhashB} 代替。
\item {\tt BhashB} ($B$ -- $B'$)，計算{\em Bytes} 值的 $\Sha$ 雜湊，參見\ptref{p:bytes.ops}。雜湊作為 32 位元組{\em Bytes} 值返回。
\item {\tt Bhashu} ($B$ -- $x$)，計算{\em Bytes} 值的 $\Sha$ 雜湊，參見\ptref{p:bytes.ops}。雜湊作為大端序無號 256 位元{\em Integer} 值返回。
\item {\tt Blen} ($B$ -- $x$)，返回{\em Bytes} 值~$B$ 的長度（以位元組為單位），參見\ptref{p:bytes.ops}。
\item {\tt Bx.} ($B$ -- )，列印{\em Bytes} 值的十六進位表示，參見\ptref{p:bytes.ops}。每個位元組恰好由兩個大寫十六進位數字表示。
\item {\tt \underline{B\{}$\langle{\textit{hex-digits}}\rangle$\}} ( -- $B$)，推送包含由偶數個十六進位數字表示的資料的{\em Bytes} 字面值，參見\ptref{p:bytes.ops}。
\item {\tt B|} ($B$ $x$ -- $B'$ $B''$)，從{\em Bytes} 值~$B$ 中切出前 $x$ 個位元組，並將前 $x$ 個位元組（$B'$）和剩餘部分（$B''$）作為新的{\em Bytes} 值返回，參見\ptref{p:bytes.ops}。
\item {\tt Li>B} ($x$ $y$ -- $B$)，將有號小端序 $y$ 位元{\em Integer}~$x$ 儲存到恰好由 $y/8$ 個位元組組成的{\em Bytes} 值 $B$ 中。整數 $y$ 必須是 $0\ldots256$ 範圍內的八的倍數，參見\ptref{p:bytes.ops}。
\item {\tt Lu>B} ($x$ $y$ -- $B$)，將無號小端序 $y$ 位元{\em Integer}~$x$ 儲存到恰好由 $y/8$ 個位元組組成的{\em Bytes} 值 $B$ 中。整數 $y$ 必須是 $0\ldots256$ 範圍內的八的倍數，參見\ptref{p:bytes.ops}。
\item {\tt \underline{[}} ( -- )，即使 {\tt state} 大於零也開啟內部解譯器會話，即所有後續詞彙都會立即執行而不是被編譯。
\item {\tt []} ($t$ $i$ -- $x$)，返回{\em Tuple}~$t$ 的第 $(i+1)$ 個分量 $t_{i+1}$，其中 $0\leq i<|t|$，參見\ptref{p:tuples}。
\item {\tt \underline{[compile]} $\langle\textit{word-name}\rangle$} ( -- )，編譯 $\langle\textit{word-name}\rangle$，就好像它是普通詞彙一樣，即使它是活動的，參見\ptref{p:dict.lookup}。本質上等同於 {\tt ' $\langle\textit{word-name}\rangle$ execute}。
\item {\tt \underline{]}} ($x_1$ \dots $x_n$ $n$ -- )，關閉由 {\tt [} 開啟的內部解譯器會話，並根據 {\tt state} 是否大於零之後呼叫 {\tt (compile)} 或 {\tt (execute)}。例如，{\tt \{ [ 2 3 + 1 ] * \}} 等同於 {\tt \{ 5 * \}}。
\item {\tt \underline{`}$\langle\textit{word\/}\rangle$} ( -- $a$)，引入{\em Atom} 字面值，等於名稱等於 $\langle\textit{word\/}\rangle$ 的唯一{\em Atom}，參見\ptref{p:atoms}。等同於 {\tt "$\langle\textit{word\/}\rangle$" atom}。
\item {\tt abort} ($S$ -- )，拋出一個錯誤訊息取自{\em String}~$S$ 的例外，參見\ptref{p:exception.ops}。
\item {\tt \underline{abort"}$\langle\textit{message}\rangle$"} ($x$ -- )，如果{\em Integer}~$x$ 為非零，則拋出一個錯誤訊息為 $\langle\textit{message}\rangle$ 的例外，參見\ptref{p:exception.ops}。
\item {\tt abs} ($x$ -- $|x|$)，計算{\em Integer}~$x$ 的絕對值 $|x|=\max(x,-x)$。等同於 {\tt dup negate max}。
\item {\tt allot} ($n$ -- $t$)，建立新陣列，即由 $n$ 個新空{\em Box}es 組成的{\em Tuple}，參見\ptref{p:tuples}。等同於 {\tt | \{ hole , \} rot times}。
\item {\tt and} ($x$ $y$ -- $x\& y$)，計算兩個{\em Integer}s 的位元 AND，參見\ptref{p:arith.op}。
\item {\tt anon} ( -- $a$)，建立一個新的唯一匿名{\em Atom}，參見\ptref{p:atoms}。
\item {\tt atom} ($S$ -- $a$)，返回唯一名稱為~$S$ 的{\em Atom}~$a$，必要時建立此原子，參見\ptref{p:atoms}。等同於 {\tt true (atom) drop}。
\item {\tt atom?} ($u$ -- $?$)，檢查 $u$ 是否為{\em Atom}，參見\ptref{p:atoms}。
\item {\tt b+} ($b$ $b'$ -- $b''$)，串接兩個{\em Builders} $b$ 和~$b'$，參見\ptref{p:builder.ops}。
\item {\tt b.} ($x$ -- )，列印{\em Integer}~$x$ 的二進位表示，後面跟著一個空格。等同於 {\tt b.\_ space}。
\item {\tt b.\_} ($x$ -- )，列印{\em Integer}~$x$ 的二進位表示，不包含任何空格。等同於 {\tt (b.)~type}。
\item {\tt b>} ($b$ -- $c$)，將{\em Builder}~$b$ 轉換為包含與~$b$ 相同資料的新{\em Cell}~$c$，參見\ptref{p:builder.ops}。
\item {\tt b>idict!} ($v$ $x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，將新值 $v$（由{\em Builder} 表示）與由有號大端序 $n$ 位元整數 $x$ 給定的金鑰加入到具有 $n$ 位元金鑰的字典 $D$ 中，並在成功時返回新字典 $D'$ 和 $-1$，參見\ptref{p:hashmap.ops}。否則返回未更改的字典 $D$ 和 $0$。
\item {\tt b>idict!+} ($v$ $x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，類似於 {\tt b>idict!} 將新金鑰-值對 $(x,v)$ 加入字典 $D$，但如果金鑰已存在則失敗，返回未更改的字典 $D$ 和 $0$，參見\ptref{p:hashmap.ops}。
\item {\tt b>sdict!} ($v$ $k$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，將新值 $v$（由{\em Builder} 表示）與由{\em Slice}~$k$ 的前 $n$ 個位元給定的金鑰加入到具有 $n$ 位元金鑰的字典 $D$ 中，並在成功時返回新字典 $D'$ 和 $-1$，參見\ptref{p:hashmap.ops}。否則返回未更改的字典 $D$ 和 $0$。
\item {\tt b>sdict!+} ($v$ $k$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，類似於 {\tt b>sdict!} 將新金鑰-值對 $(k,v)$ 加入字典 $D$，但如果金鑰已存在則失敗，返回未更改的字典 $D$ 和 $0$，參見\ptref{p:hashmap.ops}。
\item {\tt b>udict!} ($v$ $x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，將新值 $v$（由{\em Builder} 表示）與由無號大端序 $n$ 位元整數 $x$ 給定的金鑰加入到具有 $n$ 位元金鑰的字典 $D$ 中，並在成功時返回新字典 $D'$ 和 $-1$，參見\ptref{p:hashmap.ops}。否則返回未更改的字典 $D$ 和 $0$。
\item {\tt b>udict!+} ($v$ $x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，類似於 {\tt b>udict!} 將新金鑰-值對 $(x,v)$ 加入字典 $D$，但如果金鑰已存在則失敗，返回未更改的字典 $D$ 和 $0$，參見\ptref{p:hashmap.ops}。
\item {\tt bbitrefs} ($b$ -- $x$ $y$)，返回已儲存在{\em Builder}~$b$ 中的資料位元數 $x$ 和參照數 $y$，參見\ptref{p:builder.ops}。
\item {\tt bbits} ($b$ -- $x$)，返回已儲存在{\em Builder}~$b$ 中的資料位元數。結果 $x$ 是範圍 $0\dots1023$ 內的{\em Integer}，參見\ptref{p:builder.ops}。
\item {\tt bl} ( -- $x$)，推送空格的 Unicode 程式碼點，即 32，參見\ptref{p:string.ops}。
\item {\tt boc+>B} ($c$ $x$ -- $B$)，建立並序列化「標準」單元集合，包含一個根{\em Cell}~$c$ 及其所有後代，參見\ptref{p:boc.ops}。{\em Integer} 參數 $0\leq x\leq 31$ 用於傳遞指示單元集合序列化附加選項的旗標，個別位元具有以下效果：
  \begin{itemize}
  \item $+1$ 啟用單元集合索引建立（對於大型單元集合的惰性反序列化很有用）。
  \item $+2$ 將所有資料的 CRC32-C 包含在序列化中（對於檢查資料完整性很有用）。
  \item $+4$ 明確地將根單元的雜湊儲存到序列化中（以便之後可以快速復原而無需完整反序列化）。
  \item $+8$ 儲存某些中間（非葉）單元的雜湊（對於大型單元集合的惰性反序列化很有用）。
  \item $+16$ 儲存單元快取位元以控制反序列化單元的快取。
  \end{itemize}
對於非常小的單元集合（例如，TON 區塊鏈外部訊息），$x$ 的典型值為 $x=0$ 或 $x=2$，對於大型單元集合（例如，TON 區塊鏈區塊），則為 $x=31$。
\item {\tt boc>B} ($c$ -- $B$)，序列化具有根{\em Cell}~$c$ 及其所有後代的小型「標準」單元集合，參見\ptref{p:boc.ops}。等同於 {\tt 0 boc+>B}。
\item {\tt box} ($x$ -- $p$)，建立包含指定值~$x$ 的新{\em Box}，參見\ptref{p:variables}。等同於 {\tt hole tuck !}。
\item {\tt brefs} ($b$ -- $x$)，返回已儲存在{\em Builder}~$b$ 中的參照數，參見\ptref{p:builder.ops}。結果 $x$ 是範圍 $0\dots4$ 內的{\em Integer}。
\item {\tt brembitrefs} ($b$ -- $x$ $y$)，返回可儲存在{\em Builder}~$b$ 中的最大附加資料位元數 $0\leq x\leq 1023$ 和最大附加單元參照數 $0\leq y\leq 4$，參見\ptref{p:builder.ops}。
\item {\tt brembits} ($b$ -- $x$)，返回可儲存在{\em Builder}~$b$ 中的最大附加資料位元數，參見\ptref{p:builder.ops}。等同於 {\tt bbits 1023 swap -}。
\item {\tt bremrefs} ($b$ -- $x$)，返回可儲存在{\em Builder}~$b$ 中的最大附加單元參照數，參見\ptref{p:builder.ops}。
\item {\tt bye} ( -- )，以零退出碼退出 Fift 解譯器到作業系統，參見\ptref{p:exit.fift}。等同於 {\tt 0 halt}。
\item {\tt \underline{b\{}$\langle\textit{binary-data}\rangle$\}} ( -- $s$)，建立{\em Slice}~$s$，它不包含參照且包含最多 1023 個資料位元，在 $\langle\textit{binary-data}\rangle$ 中指定，它必須是僅由字元 `{\tt 0}' 和 `{\tt 1}' 組成的字串，參見\ptref{p:slice.lit}。
\item {\tt caddr} ($l$ -- $h''$)，返回列表的第三個元素。等同於 {\tt cddr car}。
\item {\tt cadr} ($l$ -- $h'$)，返回列表的第二個元素，參見\ptref{p:lists}。等同於 {\tt cdr car}。
\item {\tt car} ($l$ -- $h$)，返回列表的頭部，參見\ptref{p:lists}。等同於 {\tt first}。
\item {\tt cddr} ($l$ -- $t'$)，返回列表的尾部的尾部。等同於 {\tt cdr cdr}。
\item {\tt cdr} ($l$ -- $t$)，返回列表的尾部，參見\ptref{p:lists}。等同於 {\tt second}。
\item {\tt \underline{char} $\langle\textit{string}\rangle$} ( -- $x$)，推送具有 {\tt $\langle\textit{string}\rangle$} 第一個字元的 Unicode 程式碼點的{\em Integer}，參見\ptref{p:string.ops}。例如，{\tt char *} 等同於 {\tt 42}。
\item {\tt chr} ($x$ -- $S$)，返回由一個 UTF-8 編碼字元組成的新{\em String}~$S$，其 Unicode 程式碼點為~$x$。
\item {\tt cmp} ($x$ $y$ -- $z$)，比較兩個{\em Integer}s $x$ 和~$y$，如果 $x>y$ 則推送 $1$，如果 $x<y$ 則推送 $-1$，如果 $x=y$ 則推送 $0$，參見\ptref{p:int.comp}。大約等同於 {\tt - sgn}。
\item {\tt cond} ($x$ $e$ $e'$ -- )，如果{\em Integer} $x$ 為非零，則執行 $e$，否則執行 $e'$，參見\ptref{p:cond.ops}。
\item {\tt cons} ($h$ $t$ -- $l$)，從其頭部（第一個元素）$h$ 和其尾部（由所有剩餘元素組成的列表）~$t$ 建構列表，參見\ptref{p:lists}。等同於 {\tt pair}。
\item {\tt constant} ($x$ -- )，從輸入的其餘部分掃描一個以空白分隔的詞彙名稱 $S$，並將新的普通詞彙 $S$ 定義為常數，當呼叫時將推送給定值 $x$（任意類型），參見\ptref{p:dict.create} 和~\ptref{p:constants}。
\item {\tt count} ($t$ -- $n$)，返回{\em Tuple}~$t$ 的長度 $n=|t|$，參見\ptref{p:tuples}。
\item {\tt cr} ( -- )，將回車（或換行字元）輸出到標準輸出，參見\ptref{p:string.ops}。
\item {\tt create} ($e$ -- )，定義一個新的普通詞彙，名稱等於從輸入掃描的下一個詞彙，使用{\em WordDef} $e$ 作為其定義，參見\ptref{p:dict.create}。如果詞彙已存在，則會被默認重新定義。
\item {\tt csr.} ($s$ -- )，遞迴地列印{\em Slice}~$s$，參見\ptref{p:slice.ops}。在第一行上，$s$ 的資料位元以十六進位形式顯示，嵌入到類似於用於{\em Slice} 字面值的 {\tt x\{\dots\}} 結構中（參見\ptref{p:slice.lit}）。在接下來的幾行上，$s$ 所參照的單元以更大的縮排列印。
\item {\tt \underline{def?} $\langle\textit{word-name\/}\rangle$} ( -- $?$)，在執行期間檢查詞彙 $\langle\textit{word-name\/}\rangle$ 是否已定義，並相應地返回 $-1$ 或 $0$。
\item {\tt depth} ( -- $n$)，將 Fift 堆疊的目前深度（項目總數）作為{\em Integer} $n\geq0$ 返回。
\item {\tt dictmap} ($D$ $n$ $e$ -- $D'$)，將執行權杖 $e$（即匿名函數）應用於儲存在具有 $n$ 位元金鑰的字典 $D$ 中的每個金鑰-值對，參見\ptref{p:hashmap.ops}。執行權杖為每個金鑰-值對執行一次，在執行 $e$ 之前將{\em Builder} $b$ 和{\em Slice} $v$（包含值）推入堆疊。執行後 $e$ 必須在堆疊中留下修改後的{\em Builder} $b'$（包含來自~$b$ 的所有資料以及新值 $v'$）和 $-1$，或 $0$ 指示失敗。在後一種情況下，從新字典中省略相應的金鑰。
\item {\tt dictmerge} ($D$ $D'$ $n$ $e$ -- $D''$)，將兩個具有 $n$ 位元金鑰的字典 $D$ 和 $D'$ 組合成一個具有相同金鑰的字典 $D''$，參見\ptref{p:hashmap.ops}。如果金鑰僅存在於字典 $D$ 和 $D'$ 中的一個中，則此金鑰和相應值會逐字複製到新字典 $D''$。否則呼叫執行權杖（匿名函數）$e$ 來合併 $D$ 和 $D'$ 中對應於相同金鑰 $k$ 的兩個值 $v$ 和 $v'$。在呼叫 $e$ 之前，推入{\em Builder}~$b$ 和兩個{\em Slice}s $v$ 和 $v'$，表示要合併的兩個值。執行後 $e$ 留下修改後的{\em Builder}~$b'$（包含來自 $b$ 的原始資料以及組合值）和 $-1$，或在失敗時留下 $0$。在後一種情況下，從新字典中省略相應的金鑰。
\item {\tt dictnew} ( -- $D$)，推送表示新空字典的{\em Null} 值，參見\ptref{p:hashmap.ops}。等同於 {\tt null}。
\item {\tt does} ($x_1$ \dots $x_n$ $n$ $e$ -- $e'$)，建立一個新執行權杖 $e'$，當呼叫時將 $n$ 個值 $x_1$、\dots、$x_n$ 推入堆疊，然後執行 $e$，參見\ptref{p:wordlist.ops}。它大致等同於 {\tt (\{)}、{\tt (compile)} 和 {\tt (\})} 的組合。
\item {\tt drop} ($x$ -- )，移除堆疊頂部項目，參見\ptref{p:stack.ops}。
\item {\tt dup} ($x$ -- $x$ $x$)，複製堆疊頂部項目，參見\ptref{p:stack.ops}。如果堆疊為空，則拋出例外。
\item {\tt ed25519\_chksign} ($B$ $B'$ $B''$ -- $?$)，檢查 $B'$ 是否為使用公鑰 $B''$ 對資料 $B$ 的有效 Ed25519 簽章，參見\ptref{p:ed25519.ops}。
\item {\tt ed25519\_sign} ($B$ $B'$ -- $B''$)，使用 Ed25519 私鑰 $B'$（一個 32 位元組{\em Bytes} 值）對資料 $B$ 進行簽名，並將簽名作為 64 位元組{\em Bytes} 值~$B''$ 返回，參見\ptref{p:ed25519.ops}。
\item {\tt ed25519\_sign\_uint} ($x$ $B'$ -- $B''$)，將大端序無號 256 位元整數 $x$ 轉換為 32 位元組序列，並使用 Ed25519 私鑰 $B'$ 類似於 {\tt ed25519\_sign} 進行簽名，參見\ptref{p:ed25519.ops}。等同於 {\tt swap 256 u>B swap ed25519\_sign}。要簽名的整數 $x$ 通常計算為某些資料的雜湊。
\item {\tt emit} ($x$ -- )，將由{\em Integer} $x$ 給出的 Unicode 程式碼點的 UTF-8 編碼字元列印到標準輸出，參見\ptref{p:string.ops}。例如，{\tt 42 emit} 列印星號「{\tt *}」，{\tt 916 emit} 列印希臘字母 Delta「{\tt $\Delta$}」。等同於 {\tt chr type}。
\item {\tt empty?} ($s$ -- $?$)，檢查{\em Slice} 是否為空（即沒有資料位元和剩餘參照），並相應地返回 $-1$ 或 $0$，參見\ptref{p:slice.ops}。
\item {\tt eq?} ($u$ $v$ -- $?$)，檢查 $u$ 和 $v$ 是否為相等的{\em Integer}s、{\em Atom}s 或{\em Null}s，參見\ptref{p:atoms}。如果它們不相等，或者它們的類型不同，或者不是列出的類型之一，則返回零。
\item {\tt exch} ($x_n$ \dots $x_0$ $n$ -- $x_0$ \dots $x_n$)，將堆疊頂部與從頂部開始的第 $n$ 個堆疊項目交換，其中 $n\geq0$ 也從堆疊中取得，參見\ptref{p:stack.ops}。特別是，{\tt 1 exch} 等同於 {\tt swap}，{\tt 2 exch} 等同於 {\tt swap rot}。
\item {\tt exch2} (\dots $n$ $m$ -- \dots)，將從頂部開始的第 $n$ 個堆疊項目與從頂部開始的第 $m$ 個堆疊項目交換，其中 $n\geq0$、$m\geq0$ 從堆疊中取得，參見\ptref{p:stack.ops}。
\item {\tt execute} ($e$ -- \dots)，執行執行權杖（{\em WordDef}）$e$，參見\ptref{p:blocks}。
\item {\tt explode} ($t$ -- $x_1$ \dots $x_n$ $n$)，解包未知長度~$n$ 的{\em Tuple}~$t=(x_1,\ldots,x_n)$，並返回該長度，參見\ptref{p:tuples}。
\item {\tt false} ( -- $0$)，將 $0$ 推入堆疊，參見\ptref{p:bool}。等同於 {\tt 0}。
\item {\tt file-exists?} ($S$ -- $?$)，檢查名稱由{\em String}~$S$ 指定的檔案是否存在，參見\ptref{p:bytes.ops}。
\item {\tt file>B} ($S$ -- $B$)，讀取名稱由{\em String}~$S$ 指定的（二進位）檔案，並將其內容作為{\em Bytes} 值返回，參見\ptref{p:bytes.ops}。如果檔案不存在，則拋出例外。
\item {\tt find} ($S$ -- $e$ $-1$ or $e$ $1$ or $0$)，在字典中查詢{\em String} $S$，如果找到，則將其定義作為{\em WordDef}~$e$ 返回，對於普通詞彙後面跟著 $-1$，對於活動詞彙後面跟著 $1$，參見\ptref{p:dict.lookup}。否則推送 $0$。
\item {\tt first} ($t$ -- $x$)，返回{\em Tuple} 的第一個分量，參見\ptref{p:tuples}。等同於 {\tt 0 []}。
\item {\tt fits} ($x$ $y$ -- $?$)，檢查{\em Integer}~$x$ 是否為有號 $y$ 位元整數（即對於 $0\leq y\leq 1023$，是否為 $-2^{y-1}\leq x<2^{y-1}$），並相應地返回 $-1$ 或 $0$。
\item {\tt forget} ( -- )，忘記（從字典中移除）從輸入掃描的下一個詞彙的定義，參見\ptref{p:dict.create}。
\item {\tt gasrunvm} (\dots $s$ $c$ $z$ -- \dots $x$ $c'$ $z'$)，{\tt runvm} 的 gas 感知版本，參見\ptref{p:tvm.ops}：呼叫一個新的 TVM 實例，將目前接續 {\tt cc} 和特殊暫存器 {\tt c3} 都從{\em Slice}~$s$ 初始化，並使用{\em Cell}~$c$ 初始化特殊暫存器 {\tt c4}（「持久資料根」，參見\cite[1.4]{TVM}）。然後以 gas 限制設定為 $z$ 啟動新的 TVM 實例。實際消耗的 gas $z'$ 在最終 Fift 堆疊頂部返回，{\tt c4} 的最終值在最終 Fift 堆疊頂部下方作為另一個{\em Cell}~$c'$ 返回。
\item {\tt gasrunvmcode} (\dots $s$ $z$ -- \dots $x$ $z'$)，{\tt runvmcode} 的 gas 感知版本，參見\ptref{p:tvm.ops}：呼叫一個新的 TVM 實例，從{\em Slice} $s$ 初始化目前接續 {\tt cc} 並將 gas 限制設定為 $z$，從而在 TVM 中執行程式碼~$s$。原始 Fift 堆疊（不含 $s$）完整傳遞為新 TVM 實例的初始堆疊。當 TVM 終止時，其結果堆疊用作新的 Fift 堆疊，退出碼 $x$ 和實際消耗的 gas $z'$ 推入其頂部。如果 $x$ 為非零，表示 TVM 已被未處理的例外終止，則從頂部開始的下一個堆疊項目包含此例外的參數，$x$ 是例外代碼。在這種情況下，所有其他項目都從堆疊中移除。
\item {\tt gasrunvmctx} (\dots $s$ $c$ $t$ $z$ -- \dots $x$ $c'$ $z'$)，{\tt runvmctx} 的 gas 感知版本，參見\ptref{p:tvm.ops}。與 {\tt gasrunmv} 的不同之處在於它使用{\em Tuple}~$t$ 初始化 {\tt c7}。
\item {\tt gasrunvmdict} (\dots $s$ $z$ -- \dots $x$ $z'$)，{\tt runvmdict} 的 gas 感知版本，參見\ptref{p:tvm.ops}：呼叫一個新的 TVM 實例，從{\em Slice} $s$ 初始化目前接續 {\tt cc} 並將 gas 限制設定為 $z$，類似於 {\tt gasrunvmcode}，但也使用相同值初始化特殊暫存器 {\tt c3}，並在 TVM 執行開始之前將零推入初始 TVM 堆疊。實際消耗的 gas 作為{\em Integer} $z'$ 返回。在典型應用中，{\em Slice}~$s$ 由子例程選擇程式碼組成，該程式碼使用堆疊頂部{\em Integer} 來選擇要執行的子例程，從而實現數個相互遞迴子例程的定義和執行（參見\cite[4.6]{TVM} 和~\ptref{p:asm.prog}）。等於零的選擇器對應於大型 TVM 程式中的 {\tt main()} 子例程。
\item {\tt halt} ($x$ -- )，類似於 {\tt bye} 退出到作業系統，但使用{\em Integer} $x$ 作為退出碼，參見\ptref{p:exit.fift}。
\item {\tt hash} ($c$ -- $x$)，{\tt hashu} 的已棄用版本。請使用 {\tt hashu} 或 {\tt hashB} 代替。
\item {\tt hashB} ($c$ -- $B$)，計算{\em Cell}~$c$ 的基於 $\Sha$ 的表示雜湊（參見\cite[3.1]{TVM}），它明確定義 $c$ 及其所有後代（假設 $\Sha$ 沒有碰撞），參見\ptref{p:hash.ops}。結果作為恰好由 32 個位元組組成的{\em Bytes} 值返回。
\item {\tt hashu} ($c$ -- $x$)，類似於 {\tt hashB} 計算{\em Cell}~$c$ 的基於 $\Sha$ 的表示雜湊，但將結果作為大端序無號 256 位元{\em Integer} 返回。
\item {\tt hold} ($S$ $x$ -- $S'$)，向{\em String}~$S$ 附加一個 Unicode 程式碼點為~$x$ 的 UTF-8 編碼字元。等同於 {\tt chr \$+}。
\item {\tt hole} ( -- $p$)，建立一個不持有任何值的新{\em Box}~$p$，參見\ptref{p:variables}。等同於 {\tt null box}。
\item {\tt i,} ($b$ $x$ $y$ -- $b'$)，將有號 $y$ 位元整數~$x$ 的大端序二進位表示附加到{\em Builder}~$b$，其中 $0\leq y\leq 257$，參見\ptref{p:builder.ops}。如果 $b$ 中沒有足夠的空間（即如果 $b$ 已包含超過 $1023-y$ 個資料位元），或如果{\em Integer}~$x$ 不適合 $y$ 位元，則拋出例外。
\item {\tt i>B} ($x$ $y$ -- $B$)，將有號大端序 $y$ 位元{\em Integer}~$x$ 儲存到恰好由 $y/8$ 個位元組組成的{\em Bytes} 值 $B$ 中。整數 $y$ 必須是 $0\ldots256$ 範圍內的八的倍數，參見\ptref{p:bytes.ops}。
\item {\tt i@} ($s$ $x$ -- $y$)，從{\em Slice}~$s$ 的前 $x$ 個位元中提取有號大端序 $x$ 位元整數，參見\ptref{p:slice.ops}。如果 $s$ 包含少於 $x$ 個資料位元，則拋出例外。
\item {\tt i@+} ($s$ $x$ -- $y$ $s'$)，類似於 {\tt i@} 從{\em Slice}~$s$ 的前 $x$ 個位元中提取有號大端序 $x$ 位元整數，但也返回 $s$ 的剩餘部分，參見\ptref{p:slice.ops}。
\item {\tt i@?} ($s$ $x$ -- $y$ $-1$ or $0$)，類似於 {\tt i@} 從{\em Slice} 中提取有號大端序整數，但在成功時之後推送整數 $-1$，參見\ptref{p:slice.ops}。如果 $s$ 中剩餘少於 $x$ 個位元，則推送整數 $0$ 以指示失敗。
\item {\tt i@?+} ($s$ $x$ -- $y$ $s'$ $-1$ or $s$ $0$)，從{\em Slice}~$s$ 中提取有號大端序整數並計算此{\em Slice} 的剩餘部分，類似於 {\tt i@+}，但之後推送 $-1$ 以指示成功，參見\ptref{p:slice.ops}。失敗時，推送未更改的{\em Slice}~$s$ 和 $0$ 以指示失敗。
\item {\tt idict!} ($v$ $x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，將新值 $v$（由{\em Slice} 表示）與由有號大端序 $n$ 位元整數 $x$ 給定的金鑰加入到具有 $n$ 位元金鑰的字典 $D$ 中，並在成功時返回新字典 $D'$ 和 $-1$，參見\ptref{p:hashmap.ops}。否則返回未更改的字典 $D$ 和 $0$。
\item {\tt idict!+} ($v$ $x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，類似於 {\tt idict!} 將新金鑰-值對 $(x,v)$ 加入字典 $D$，但如果金鑰已存在則失敗，返回未更改的字典 $D$ 和 $0$，參見\ptref{p:hashmap.ops}。
\item {\tt idict-} ($x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，從由{\em Cell}~$D$ 表示的字典中刪除由有號大端序 $n$ 位元{\em Integer}~$x$ 表示的金鑰，參見\ptref{p:hashmap.ops}。如果找到金鑰，則從字典中刪除它並返回修改後的字典 $D'$ 和 $-1$。否則返回未修改的字典 $D$ 和 $0$。
\item {\tt idict@} ($x$ $D$ $n$ -- $v$ $-1$ or $0$)，在由{\em Cell} 或{\em Null}~$D$ 表示的字典中查詢由有號大端序 $n$ 位元{\em Integer}~$x$ 表示的金鑰，參見\ptref{p:hashmap.ops}。如果找到金鑰，則將相應值作為{\em Slice}~$v$ 和 $-1$ 返回。否則返回 $0$。
\item {\tt idict@-} ($x$ $D$ $n$ -- $D'$ $v$ $-1$ or $D$ $0$)，在由{\em Cell}~$D$ 表示的字典中查詢由有號大端序 $n$ 位元{\em Integer}~$x$ 表示的金鑰，參見\ptref{p:hashmap.ops}。如果找到金鑰，則從字典中刪除它並返回修改後的字典 $D'$、作為{\em Slice}~$v$ 的相應值和 $-1$。否則返回未修改的字典 $D$ 和 $0$。
\item {\tt if} ($x$ $e$ -- )，執行執行權杖（即{\em WordDef}）$e$，但僅當{\em Integer} $x$ 為非零時，參見\ptref{p:cond.ops}。
\item {\tt ifnot} ($x$ $e$ -- )，執行執行權杖 $e$，但僅當{\em Integer} $x$ 為零時，參見\ptref{p:cond.ops}。
\item {\tt include} ($S$ -- )，從由{\em String}~$S$ 給出的路徑載入並解譯 Fift 原始檔，參見\ptref{p:asm.load}。如果檔案名稱 $S$ 不以斜槓開頭，則使用 Fift 包含搜尋路徑（通常取自 {\tt FIFTPATH} 環境變數或 Fift 解譯器的 {\tt -I} 命令列引數，如果兩者都不存在則等於 {\tt /usr/lib/fift}）來定位~$S$。
\item {\tt list} ($x_1$ \dots $x_n$ $n$ -- $l$)，依序建構長度為~$n$、元素為 $x_1$、\ldots、$x_n$ 的列表 $l$，參見\ptref{p:lists}。等同於 {\tt null ' cons rot times}。
\item {\tt max} ($x$ $y$ -- $z$)，計算兩個{\em Integer}s $x$ 和~$y$ 的最大值 $z:=\max(x,y)$。等同於 {\tt minmax nip}。
\item {\tt min} ($x$ $y$ -- $z$)，計算兩個{\em Integer}s $x$ 和~$y$ 的最小值 $z:=\min(x,y)$。等同於 {\tt minmax drop}。
\item {\tt minmax} ($x$ $y$ -- $z$ $t$)，計算兩個{\em Integer}s $x$ 和~$y$ 的最小值 $z:=\min(x,y)$ 和最大值 $t:=\max(x,y)$。
\item {\tt mod} ($x$ $y$ -- $r:=x\bmod y$)，計算 $x$ 除以 $y$ 的餘數 $x\bmod y=x-y\cdot\lfloor x/y\rfloor$，參見\ptref{p:arith.op}。
\item {\tt negate} ($x$ -- $-x$)，改變{\em Integer} 的符號，參見\ptref{p:arith.op}。
\item {\tt newkeypair} ( -- $B$ $B'$)，產生新的 Ed25519 私鑰/公鑰對，並將私鑰 $B$ 和公鑰 $B'$ 都作為 32 位元組{\em Bytes} 值返回，參見\ptref{p:ed25519.ops}。金鑰的品質對於測試目的來說足夠好。實際應用必須在產生 Ed25519 金鑰對之前向 OpenSSL PRNG 提供足夠的熵。
\item {\tt nil} ( -- $t$)，推送空{\em Tuple}~$t=()$。等同於 {\tt 0 tuple}。
\item {\tt nip} ($x$ $y$ -- $y$)，從頂部移除第二個堆疊項目，參見\ptref{p:stack.ops}。等同於 {\tt swap drop}。
\item {\tt nop} ( -- )，什麼都不做，參見\ptref{p:dict.lookup}。
\item {\tt not} ($x$ -- $-1-x$)，計算{\em Integer} 的位元補數，參見\ptref{p:arith.op}。
\item {\tt now} ( -- $x$)，將目前 Unixtime 作為{\em Integer} 返回，參見\ptref{p:ed25519.ops}。
\item {\tt null} ( -- $\bot$)，推送{\em Null} 值，參見\ptref{p:lists}
\item {\tt null!} ($p$ -- )，將{\em Null} 值儲存到{\em Box}~$p$ 中。等同於 {\tt null swap !}。
\item {\tt null?} ($x$ -- $?$)，檢查 $x$ 是否為{\em Null}，參見\ptref{p:lists}。
\item {\tt or} ($x$ $y$ -- $x|y$)，計算兩個{\em Integer}s 的位元 OR，參見\ptref{p:arith.op}。
\item {\tt over} ($x$ $y$ -- $x$ $y$ $x$)，在堆疊頂部項目上方建立從頂部開始的第二個堆疊項目的複本，參見\ptref{p:stack.ops}。
\item {\tt pair} ($x$ $y$ -- $t$)，建立新對 $t=(x,y)$，參見\ptref{p:tuples}。等同於 {\tt 2 tuple} 或 {\tt | rot , swap ,}。
\item {\tt pfxdict!} ($v$ $k$ $s$ $n$ -- $s'$ $-1$ or $s$ $0$)，將金鑰-值對 $(k,v)$（都由{\em Slice}s 表示）加入到金鑰長度最多為~$n$ 的前綴字典 $s$ 中，參見\ptref{p:hashmap.ops}。成功時，返回修改後的字典 $s'$ 和 $-1$。失敗時，返回原始字典 $s$ 和 $0$。
\item {\tt pfxdict!+} ($v$ $k$ $s$ $n$ -- $s'$ $-1$ or $s$ $0$)，類似於 {\tt pfxdict!} 將金鑰-值對 $(k,v)$ 加入前綴字典 $s$，但如果金鑰已存在則失敗，參見\ptref{p:hashmap.ops}。
\item {\tt pfxdict@} ($k$ $s$ $n$ -- $v$ $-1$ or $0$)，在金鑰長度限制為 $n$ 位元的前綴字典 $s$ 中查詢金鑰 $k$（由{\em Slice} 表示），參見\ptref{p:hashmap.ops}。成功時，將找到的值作為{\em Slice} $v$ 和 $-1$ 返回。失敗時，返回 $0$。
\item {\tt pick} ($x_n$ \dots $x_0$ $n$ -- $x_n$ \dots $x_0$ $x_n$)，建立從堆疊頂部開始的第 $n$ 個項目的複本，其中 $n\geq0$ 也在堆疊中傳遞，參見\ptref{p:stack.ops}。特別是，{\tt 0 pick} 等同於 {\tt dup}，{\tt 1 pick} 等同於 {\tt over}。
\item {\tt priv>pub} ($B$ -- $B'$)，計算對應於私密 Ed25519 金鑰的公鑰，參見\ptref{p:ed25519.ops}。公鑰~$B'$ 和私鑰~$B$ 都由 32 位元組{\em Bytes} 值表示。
\item {\tt quit} ($\dots$ -- )，退出到 Fift 解譯器的最頂層（在互動模式下不列印 {\tt ok}）並清除堆疊，參見\ptref{p:exit.fift}。
\item {\tt ref,} ($b$ $c$ -- $b'$)，向{\em Builder}~$b$ 附加對{\em Cell}~$c$ 的參照，參見\ptref{p:builder.ops}。如果 $b$ 已包含四個參照，則拋出例外。
\item {\tt ref@} ($s$ -- $c$)，從{\em Slice}~$s$ 中提取第一個參照並返回所參照的{\em Cell}~$c$，參見\ptref{p:slice.ops}。如果沒有剩餘參照，則拋出例外。
\item {\tt ref@+} ($s$ -- $s'$ $c$)，類似於 {\tt ref@} 從{\em Slice} $s$ 中提取第一個參照，但也返回 $s$ 的剩餘部分，參見\ptref{p:slice.ops}。
\item {\tt ref@?} ($s$ -- $c$ $-1$ or $0$)，類似於 {\tt ref@} 從{\em Slice}~$s$ 中提取第一個參照，但使用旗標來指示失敗而不是拋出例外，參見\ptref{p:slice.ops}。
\item {\tt ref@?+} ($s$ -- $s'$ $c$ $-1$ or $s$ $0$)，類似於 {\tt ref@+}，但使用旗標來指示失敗而不是拋出例外，參見\ptref{p:slice.ops}。
\item {\tt remaining} ($s$ -- $x$ $y$)，返回{\em Slice}~$s$ 中剩餘的資料位元數 $x$ 和單元參照數 $y$，參見\ptref{p:slice.ops}。
\item {\tt reverse} ($x_1$ \dots $x_n$ $y_1$ \dots $y_m$ $n$ $m$ -- $x_n$ \dots $x_1$ $y_1$ \dots $y_m$)，反轉位於最頂部 $m$ 個元素正下方的 $n$ 個堆疊項目的順序，其中 $0\leq m,n\leq 255$ 都在堆疊中傳遞。
\item {\tt roll} ($x_n$ \dots $x_0$ $n$ -- $x_{n-1}$ \dots $x_0$ $x_n$)，旋轉頂部 $n$ 個堆疊項目，其中 $n\geq0$ 也在堆疊中傳遞，參見\ptref{p:stack.ops}。特別是，{\tt 1 roll} 等同於 {\tt swap}，{\tt 2 roll} 等同於 {\tt rot}。
\item {\tt rot} ($x$ $y$ $z$ -- $y$ $z$ $x$)，旋轉最頂部的三個堆疊項目。
\item {\tt runvm} (\dots $s$ $c$ -- \dots $x$ $c'$)，呼叫一個新的 TVM 實例，將目前接續 {\tt cc} 和特殊暫存器 {\tt c3} 都從{\em Slice}~$s$ 初始化，並使用{\em Cell}~$c$ 初始化特殊暫存器 {\tt c4}（「持久資料根」，參見\cite[1.4]{TVM}），參見\ptref{p:tvm.ops}。與 {\tt runvmdict} 相反，不會將隱式零推入初始 TVM 堆疊；如果需要，可以在~$s$ 下方明確傳遞。{\tt c4} 的最終值在最終 Fift 堆疊頂部作為另一個{\em Cell}~$c'$ 返回。透過這種方式，可以模擬檢查或修改其持久儲存的智慧合約的執行。
\item {\tt runvmcode} (\dots $s$ -- \dots $x$)，呼叫一個新的 TVM 實例，從{\em Slice} $s$ 初始化目前接續 {\tt cc}，從而在 TVM 中執行程式碼~$s$，參見\ptref{p:tvm.ops}。原始 Fift 堆疊（不含 $s$）完整傳遞為新 TVM 實例的初始堆疊。當 TVM 終止時，其結果堆疊用作新的 Fift 堆疊，退出碼 $x$ 推入其頂部。如果 $x$ 為非零，表示 TVM 已被未處理的例外終止，則從頂部開始的下一個堆疊項目包含此例外的參數，$x$ 是例外代碼。在這種情況下，所有其他項目都從堆疊中移除。
\item {\tt runvmctx} (\dots $s$ $c$ $t$ -- \dots $x$ $c'$)，{\tt runvm} 的變體，也使用{\em Tuple}~$t$ 初始化 {\tt c7}（TVM 的「上下文暫存器」），參見\ptref{p:tvm.ops}。
\item {\tt runvmdict} (\dots $s$ -- \dots $x$)，呼叫一個新的 TVM 實例，類似於 {\tt runvmcode} 從{\em Slice} $s$ 初始化目前接續 {\tt cc}，但也使用相同值初始化特殊暫存器 {\tt c3}，並在開始之前將零推入初始 TVM 堆疊，參見\ptref{p:tvm.ops}。在典型應用中，{\em Slice}~$s$ 由子例程選擇程式碼組成，該程式碼使用堆疊頂部{\em Integer} 來選擇要執行的子例程，從而實現數個相互遞迴子例程的定義和執行（參見\cite[4.6]{TVM} 和~\ptref{p:asm.prog}）。等於零的選擇器對應於大型 TVM 程式中的 {\tt main()} 子例程。
\item {\tt s,} ($b$ $s$ -- $b'$)，將從{\em Slice}~$s$ 取得的資料位元和參照附加到{\em Builder}~$b$，參見\ptref{p:builder.ops}。
\item {\tt s>} ($s$ -- )，如果{\em Slice}~$s$ 為非空，則拋出例外，參見\ptref{p:slice.ops}。它通常標記單元反序列化的結束，檢查是否還有未處理的資料位元或參照。
\item {\tt s>c} ($s$ -- $c$)，直接從{\em Slice}~$s$ 建立{\em Cell}~$c$，參見\ptref{p:slice.ops}。等同於 {\tt <b swap s, b>}。
\item {\tt sbitrefs} ($s$ -- $x$ $y$)，返回{\em Slice}~$s$ 中剩餘的資料位元數 $x$ 和單元參照數 $y$，參見\ptref{p:slice.ops}。等同於 {\tt remaining}。
\item {\tt sbits} ($s$ -- $x$)，返回{\em Slice}~$s$ 中剩餘的資料位元數 $x$，參見\ptref{p:slice.ops}。
\item {\tt sdict!} ($v$ $k$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，將新值 $v$（由{\em Slice} 表示）與由{\em Slice}~$k$ 的前 $n$ 個位元給定的金鑰加入到具有 $n$ 位元金鑰的字典 $D$ 中，並在成功時返回新字典 $D'$ 和 $-1$，參見\ptref{p:hashmap.ops}。否則返回未更改的字典 $D$ 和 $0$。
\item {\tt sdict!+} ($v$ $k$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，類似於 {\tt sdict!} 將新金鑰-值對 $(k,v)$ 加入字典 $D$，但如果金鑰已存在則失敗，返回未更改的字典 $D$ 和 $0$，參見\ptref{p:hashmap.ops}。
\item {\tt sdict-} ($x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，從由{\em Cell}~$D$ 表示的字典中刪除由{\em Slice}~$x$ 的前 $n$ 個資料位元給定的金鑰，參見\ptref{p:hashmap.ops}。如果找到金鑰，則從字典中刪除它並返回修改後的字典 $D'$ 和 $-1$。否則返回未修改的字典 $D$ 和 $0$。
\item {\tt sdict@} ($k$ $D$ $n$ -- $v$ $-1$ or $0$)，在由{\em Cell} 或{\em Null}~$D$ 表示的字典中查詢由{\em Slice}~$x$ 的前 $n$ 個資料位元給定的金鑰，參見\ptref{p:hashmap.ops}。如果找到金鑰，則將相應值作為{\em Slice}~$v$ 和 $-1$ 返回。否則返回 $0$。
\item {\tt sdict@-} ($x$ $D$ $n$ -- $D'$ $v$ $-1$ or $D$ $0$)，在由{\em Cell}~$D$ 表示的字典中查詢由{\em Slice}~$x$ 的前 $n$ 個資料位元給定的金鑰，參見\ptref{p:hashmap.ops}。如果找到金鑰，則從字典中刪除它並返回修改後的字典 $D'$、作為{\em Slice}~$v$ 的相應值和 $-1$。否則返回未修改的字典 $D$ 和 $0$。
\item {\tt second} ($t$ -- $x$)，返回{\em Tuple} 的第二個分量，參見\ptref{p:tuples}。等同於 {\tt 1 []}。
\item {\tt sgn} ($x$ -- $y$)，計算{\em Integer} $x$ 的符號（即如果 $x>0$ 則推送 $1$，如果 $x<0$ 則推送 $-1$，如果 $x=0$ 則推送 $0$），參見\ptref{p:int.comp}。等同於 {\tt 0 cmp}。
\item {\tt shash} ($s$ -- $B$)，透過首先將{\em Slice} 轉換為單元來計算其基於 $\Sha$ 的表示雜湊，參見\ptref{p:hash.ops}。等同於 {\tt s>c hashB}。
\item {\tt sign} ($S$ $x$ -- $S'$)，如果{\em Integer}~$x$ 為負數，則向{\em String}~$S$ 附加減號「{\tt -}」。否則保持 $S$ 不變。
\item {\tt single} ($x$ -- $t$)，建立新單例 $t=(x)$，即一個元素的{\em Tuple}。等同於 {\tt 1 tuple}。
\item {\tt skipspc} ( -- )，從當前輸入行跳過空白字元，直到找到非空白或行尾字元。
\item {\tt smca>\$} ($x$ $y$ $z$ -- $S$)，根據旗標~$z$，將具有工作鏈 $x$（有號 32 位元{\em Integer}）和工作鏈內地址 $y$（無號 256 位元{\em Integer}）的標準 TON 智慧合約地址打包到 48 字元字串 $S$（地址的可讀表示）中，參見\ptref{p:smc.addr.ops}。~$z$ 中可能的個別旗標為：$+1$ 用於不可彈回地址，$+2$ 用於僅限測試網地址，$+4$ 用於 base64url 輸出而非 base64。
\item {\tt space} ( -- )，輸出單個空格。等同於 {\tt bl emit} 或 {\tt ." "}。
\item {\tt sr,} ($b$ $s$ -- $b'$)，建構包含來自{\em Slice}~$s$ 的所有資料和參照的新{\em Cell}，並向{\em Builder}~$b$ 附加對此單元的參照，參見\ptref{p:builder.ops}。等同於 {\tt s>c ref,}。
\item {\tt srefs} ($s$ -- $x$)，返回{\em Slice}~$s$ 中剩餘的單元參照數 $x$，參見\ptref{p:slice.ops}。
\item {\tt swap} ($x$ $y$ -- $y$ $x$)，交換最頂部的兩個堆疊項目，參見\ptref{p:stack.ops}。
\item {\tt ten} ( -- $10$)，推送{\em Integer} 常數 10。
\item {\tt third} ($t$ -- $x$)，返回{\em Tuple} 的第三個分量，參見\ptref{p:tuples}。等同於 {\tt 2 []}。
\item {\tt times} ($e$ $n$ -- )，如果 $n\geq0$，則執行執行權杖（{\em WordDef}）$e$ 恰好 $n$ 次，參見\ptref{p:simple.loops}。如果 $n$ 為負數，則拋出例外。
\item {\tt totalcsize} ($c$ -- $x$ $y$ $z$)，遞迴地計算以{\em Cell}~$c$ 為根的單元樹中唯一單元的總數 $x$、資料位元 $y$ 和單元參照 $z$。
\item {\tt totalssize} ($s$ -- $x$ $y$ $z$)，遞迴地計算以{\em Slice}~$s$ 為根的單元樹中唯一單元的總數 $x$、資料位元 $y$ 和單元參照 $z$。
\item {\tt triple} ($x$ $y$ $z$ -- $t$)，建立新三元組 $t=(x,y,z)$，參見\ptref{p:tuples}。等同於 {\tt 3 tuple}。
\item {\tt true} ( -- $-1$)，將 $-1$ 推入堆疊，參見\ptref{p:bool}。等同於 {\tt -1}。
\item {\tt tuck} ($x$ $y$ -- $y$ $x$ $y$)，等同於 {\tt swap over}，參見\ptref{p:stack.ops}。
\item {\tt tuple} ($x_1$ \dots $x_n$ $n$ -- $t$)，從 $n\geq0$ 個最頂部堆疊值建立新{\em Tuple} $t:=(x_1,\ldots,x_n)$，參見\ptref{p:tuples}。等同於 {\tt dup 1 reverse | \{ swap , \} rot times}，但更有效率。
\item {\tt tuple?} ($t$ -- $?$)，檢查 $t$ 是否為{\em Tuple}，並相應地返回 $-1$ 或 $0$。
\item {\tt type} ($s$ -- )，將從堆疊頂部取得的{\em String} $s$ 列印到標準輸出，參見\ptref{p:string.ops}。
\item {\tt u,} ($b$ $x$ $y$ -- $b'$)，將無號 $y$ 位元整數~$x$ 的大端序二進位表示附加到{\em Builder}~$b$，其中 $0\leq y\leq 256$，參見\ptref{p:builder.ops}。如果運算不可能，則拋出例外。
\item {\tt u>B} ($x$ $y$ -- $B$)，將無號大端序 $y$ 位元{\em Integer}~$x$ 儲存到恰好由 $y/8$ 個位元組組成的{\em Bytes} 值 $B$ 中。整數 $y$ 必須是 $0\ldots256$ 範圍內的八的倍數，參見\ptref{p:bytes.ops}。
\item {\tt u@} ($s$ $x$ -- $y$)，從{\em Slice}~$s$ 的前 $x$ 個位元中提取無號大端序 $x$ 位元整數，參見\ptref{p:slice.ops}。如果 $s$ 包含少於 $x$ 個資料位元，則拋出例外。
\item {\tt u@+} ($s$ $x$ -- $y$ $s'$)，類似於 {\tt u@} 從{\em Slice}~$s$ 的前 $x$ 個位元中提取無號大端序 $x$ 位元整數，但也返回 $s$ 的剩餘部分，參見\ptref{p:slice.ops}。
\item {\tt u@?} ($s$ $x$ -- $y$ $-1$ or $0$)，類似於 {\tt u@} 從{\em Slice} 中提取無號大端序整數，但在成功時之後推送整數 $-1$，參見\ptref{p:slice.ops}。如果 $s$ 中剩餘少於 $x$ 個位元，則推送整數 $0$ 以指示失敗。
\item {\tt u@?+} ($s$ $x$ -- $y$ $s'$ $-1$ or $s$ $0$)，從{\em Slice}~$s$ 中提取無號大端序整數並計算此{\em Slice} 的剩餘部分，類似於 {\tt u@+}，但之後推送 $-1$ 以指示成功，參見\ptref{p:slice.ops}。失敗時，推送未更改的{\em Slice}~$s$ 和 $0$ 以指示失敗。
\item {\tt udict!} ($v$ $x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，將新值 $v$（由{\em Slice} 表示）與由大端序無號 $n$ 位元整數 $x$ 給定的金鑰加入到具有 $n$ 位元金鑰的字典 $D$ 中，並在成功時返回新字典 $D'$ 和 $-1$，參見\ptref{p:hashmap.ops}。否則返回未更改的字典 $D$ 和 $0$。
\item {\tt udict!+} ($v$ $x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，類似於 {\tt udict!} 將新金鑰-值對 $(x,v)$ 加入字典 $D$，但如果金鑰已存在則失敗，返回未更改的字典 $D$ 和 $0$，參見\ptref{p:hashmap.ops}。
\item {\tt udict-} ($x$ $D$ $n$ -- $D'$ $-1$ or $D$ $0$)，從由{\em Cell}~$D$ 表示的字典中刪除由無號大端序 $n$ 位元{\em Integer}~$x$ 表示的金鑰，參見\ptref{p:hashmap.ops}。如果找到金鑰，則從字典中刪除它並返回修改後的字典 $D'$ 和 $-1$。否則返回未修改的字典 $D$ 和 $0$。
\item {\tt udict@} ($x$ $D$ $n$ -- $v$ $-1$ or $0$)，在由{\em Cell} 或{\em Null}~$D$ 表示的字典中查詢由無號大端序 $n$ 位元{\em Integer}~$x$ 表示的金鑰，參見\ptref{p:hashmap.ops}。如果找到金鑰，則將相應值作為{\em Slice}~$v$ 和 $-1$ 返回。否則返回 $0$。
\item {\tt udict@-} ($x$ $D$ $n$ -- $D'$ $v$ $-1$ or $D$ $0$)，在由{\em Cell}~$D$ 表示的字典中查詢由無號大端序 $n$ 位元{\em Integer}~$x$ 表示的金鑰，參見\ptref{p:hashmap.ops}。如果找到金鑰，則從字典中刪除它並返回修改後的字典 $D'$、作為{\em Slice}~$v$ 的相應值和 $-1$。否則返回未修改的字典 $D$ 和 $0$。
\item {\tt ufits} ($x$ $y$ -- $?$)，檢查{\em Integer}~$x$ 是否為無號 $y$ 位元整數（即對於 $0\leq y\leq 1023$，是否為 $0\leq x<2^y$），並相應地返回 $-1$ 或 $0$。
\item {\tt uncons} ($l$ -- $h$ $t$)，將非空列表分解為其頭部和尾部，參見\ptref{p:lists}。等同於 {\tt unpair}。
\item {\tt \underline{undef?} $\langle\textit{word-name\/}\rangle$} ( -- $?$)，在執行期間檢查詞彙 $\langle\textit{word-name\/}\rangle$ 是否未定義，並相應地返回 $-1$ 或 $0$。
\item {\tt unpair} ($t$ -- $x$ $y$)，解包對 $t=(x,y)$，參見\ptref{p:tuples}。等同於 {\tt 2 untuple}。
\item {\tt unsingle} ($t$ -- $x$)，解包單例 $t=(x)$。等同於 {\tt 1 untuple}。
\item {\tt until} ($e$ -- )，一個 until 迴圈，參見\ptref{p:loops}：執行{\em WordDef}~$e$，然後移除堆疊頂部整數並檢查它是否為零。如果是，則透過執行 $e$ 開始迴圈的新迭代。否則退出迴圈。
\item {\tt untriple} ($t$ -- $x$ $y$ $z$)，解包三元組 $t=(x,y,z)$，參見\ptref{p:tuples}。等同於 {\tt 3 untuple}。
\item {\tt untuple} ($t$ $n$ -- $x_1$ \dots $x_n$)，返回{\em Tuple}~$t=(x_1,\ldots,x_n)$ 的所有分量，但僅當其長度等於~$n$ 時，參見\ptref{p:tuples}。否則拋出例外。
\item {\tt variable} ( -- )，從輸入的其餘部分掃描一個以空白分隔的詞彙名稱 $S$，分配一個空{\em Box}，並將新的普通詞彙 $S$ 定義為常數，當呼叫時將推送新的{\em Box}，參見\ptref{p:variables}。等同於 {\tt hole constant}。
\item {\tt while} ($e$ $e'$ -- )，一個 while 迴圈，參見\ptref{p:loops}：執行{\em WordDef}~$e$，然後移除並檢查堆疊頂部整數。如果為零，則退出迴圈。否則執行{\em WordDef}~$e'$，然後透過執行 $e$ 並在之後檢查退出條件來開始新的迴圈迭代。
\item {\tt word} ($x$ -- $s$)，從當前輸入行的其餘部分解析由 Unicode 程式碼點為 $x$ 的字元分隔的詞彙，並將結果作為{\em String} 推送，參見\ptref{p:string.ops}。例如，{\tt bl word abracadabra type} 將列印字串「{\tt abracadabra}」。如果 $x=0$，則跳過前導空格，然後掃描直到當前輸入行結束。如果 $x=32$，則在解析下一個詞彙之前跳過前導空格。
\item {\tt words} ( -- )，列印字典中當前定義的所有詞彙的名稱，參見\ptref{p:dict.lookup}。
\item {\tt x.} ($x$ -- )，列印{\em Integer}~$x$ 的十六進位表示（不含 {\tt 0x} 前綴），後面跟著一個空格。等同於 {\tt x.\_ space}。
\item {\tt x.\_} ($x$ -- )，列印{\em Integer}~$x$ 的十六進位表示（不含 {\tt 0x} 前綴），不包含任何空格。等同於 {\tt (x.)~type}。
\item {\tt xor} ($x$ $y$ -- $x\oplus y$)，計算兩個{\em Integer}s 的位元互斥 OR，參見\ptref{p:arith.op}。
\item {\tt \underline{x\{}$\langle\textit{hex-data}\rangle$\}} ( -- $s$)，建立{\em Slice}~$s$，它不包含參照且包含最多 1023 個資料位元，在 $\langle\textit{hex-data}\rangle$ 中指定，參見\ptref{p:slice.lit}。更準確地說，來自 $\langle\textit{hex-data}\rangle$ 的每個十六進位數字以通常的方式轉換為四個二進位數字。之後，如果 $\langle\textit{hex-data}\rangle$ 的最後一個字元是底線 {\tt \_}，則從結果二進位字串中移除所有尾隨二進位零以及緊接在它們之前的二進位一（參見\cite[1.0]{TVM} 以取得更多詳細資訊）。例如，{\tt x\{6C\_\}} 等同於 {\tt b\{01101\}}。
\item {\tt \underline{\{}} ( -- $l$)，一個活動詞彙，它將內部變數 {\tt state} 增加一，並將新的空{\em WordList} 推入堆疊，參見\ptref{p:wordlist.ops}。
\item {\tt |} ( -- $t$)，建立空{\em Tuple} $t=()$，參見\ptref{p:tuples}。等同於 {\tt nil} 和 {\tt 0 tuple}。
\item {\tt |+} ($s$ $s'$ -- $s''$)，串接兩個{\em Slice}s $s$ 和 $s'$，參見\ptref{p:slice.lit}。這意味著新{\em Slice} $s''$ 的資料位元透過串接 $s$ 和 $s'$ 的資料位元獲得，$s''$ 的{\em Cell} 參照列表類似地透過串接 $s$ 和 $s'$ 的相應列表建構。等同於 {\tt <b rot s, swap s, b> <s}。
\item {\tt |\_} ($s$ $s'$ -- $s''$)，給定兩個{\em Slice}s $s$ 和 $s'$，建立新{\em Slice} $s''$，它從 $s$ 獲得，透過附加對包含 $s'$ 的{\em Cell} 的新參照，參見\ptref{p:slice.lit}。等同於 {\tt <b rot s, swap s>c ref, b> <s}。
\item {\tt \underline{\}}} ($l$ -- $e$)，一個活動詞彙，它將{\em WordList}~$l$ 轉換為{\em WordDef}（執行權杖）$e$，從而使對~$l$ 的所有進一步修改不可能，並將內部變數 {\tt state} 減少一；然後推送整數 $1$，後面跟著 {\tt 'nop}，參見\ptref{p:wordlist.ops}。淨效果是將建構的{\em WordList} 轉換為執行權杖並將此執行權杖推入堆疊，立即或在外部區塊的執行期間。
\end{itemize}

\end{document}
